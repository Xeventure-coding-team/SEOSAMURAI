
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Version
 * 
 */
export type Version = $Result.DefaultSelection<Prisma.$VersionPayload>
/**
 * Model locations
 * 
 */
export type locations = $Result.DefaultSelection<Prisma.$locationsPayload>
/**
 * Model ScheduledPost
 * 
 */
export type ScheduledPost = $Result.DefaultSelection<Prisma.$ScheduledPostPayload>
/**
 * Model GmbIntegration
 * 
 */
export type GmbIntegration = $Result.DefaultSelection<Prisma.$GmbIntegrationPayload>
/**
 * Model CompetitorAnalysis
 * 
 */
export type CompetitorAnalysis = $Result.DefaultSelection<Prisma.$CompetitorAnalysisPayload>
/**
 * Model keywords
 * 
 */
export type keywords = $Result.DefaultSelection<Prisma.$keywordsPayload>
/**
 * Model KeywordRank
 * 
 */
export type KeywordRank = $Result.DefaultSelection<Prisma.$KeywordRankPayload>
/**
 * Model KeywordTracking
 * 
 */
export type KeywordTracking = $Result.DefaultSelection<Prisma.$KeywordTrackingPayload>
/**
 * Model BatchUpdate
 * 
 */
export type BatchUpdate = $Result.DefaultSelection<Prisma.$BatchUpdatePayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model RankAlert
 * 
 */
export type RankAlert = $Result.DefaultSelection<Prisma.$RankAlertPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model CompletedTask
 * 
 */
export type CompletedTask = $Result.DefaultSelection<Prisma.$CompletedTaskPayload>
/**
 * Model TaskExclusion
 * 
 */
export type TaskExclusion = $Result.DefaultSelection<Prisma.$TaskExclusionPayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model LocationProgress
 * 
 */
export type LocationProgress = $Result.DefaultSelection<Prisma.$LocationProgressPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model LocationMilestone
 * 
 */
export type LocationMilestone = $Result.DefaultSelection<Prisma.$LocationMilestonePayload>
/**
 * Model LocationAchievement
 * 
 */
export type LocationAchievement = $Result.DefaultSelection<Prisma.$LocationAchievementPayload>
/**
 * Model UserTaskRefresh
 * 
 */
export type UserTaskRefresh = $Result.DefaultSelection<Prisma.$UserTaskRefreshPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RankChangeType: {
  UP: 'UP',
  DOWN: 'DOWN',
  SAME: 'SAME',
  NEW: 'NEW',
  NOT_FOUND: 'NOT_FOUND'
};

export type RankChangeType = (typeof RankChangeType)[keyof typeof RankChangeType]


export const RankAlertType: {
  RANK_DROP: 'RANK_DROP',
  RANK_IMPROVEMENT: 'RANK_IMPROVEMENT',
  OUT_OF_TOP_10: 'OUT_OF_TOP_10',
  BACK_IN_TOP_10: 'BACK_IN_TOP_10',
  NEW_KEYWORD_RANKING: 'NEW_KEYWORD_RANKING'
};

export type RankAlertType = (typeof RankAlertType)[keyof typeof RankAlertType]


export const BatchUpdateStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type BatchUpdateStatus = (typeof BatchUpdateStatus)[keyof typeof BatchUpdateStatus]


export const ScheduledPostStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  PUBLISHED: 'PUBLISHED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type ScheduledPostStatus = (typeof ScheduledPostStatus)[keyof typeof ScheduledPostStatus]

}

export type RankChangeType = $Enums.RankChangeType

export const RankChangeType: typeof $Enums.RankChangeType

export type RankAlertType = $Enums.RankAlertType

export const RankAlertType: typeof $Enums.RankAlertType

export type BatchUpdateStatus = $Enums.BatchUpdateStatus

export const BatchUpdateStatus: typeof $Enums.BatchUpdateStatus

export type ScheduledPostStatus = $Enums.ScheduledPostStatus

export const ScheduledPostStatus: typeof $Enums.ScheduledPostStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Versions
 * const versions = await prisma.version.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Versions
   * const versions = await prisma.version.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.version`: Exposes CRUD operations for the **Version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versions
    * const versions = await prisma.version.findMany()
    * ```
    */
  get version(): Prisma.VersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locations`: Exposes CRUD operations for the **locations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.locations.findMany()
    * ```
    */
  get locations(): Prisma.locationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduledPost`: Exposes CRUD operations for the **ScheduledPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduledPosts
    * const scheduledPosts = await prisma.scheduledPost.findMany()
    * ```
    */
  get scheduledPost(): Prisma.ScheduledPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gmbIntegration`: Exposes CRUD operations for the **GmbIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GmbIntegrations
    * const gmbIntegrations = await prisma.gmbIntegration.findMany()
    * ```
    */
  get gmbIntegration(): Prisma.GmbIntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.competitorAnalysis`: Exposes CRUD operations for the **CompetitorAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompetitorAnalyses
    * const competitorAnalyses = await prisma.competitorAnalysis.findMany()
    * ```
    */
  get competitorAnalysis(): Prisma.CompetitorAnalysisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keywords`: Exposes CRUD operations for the **keywords** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keywords
    * const keywords = await prisma.keywords.findMany()
    * ```
    */
  get keywords(): Prisma.keywordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keywordRank`: Exposes CRUD operations for the **KeywordRank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeywordRanks
    * const keywordRanks = await prisma.keywordRank.findMany()
    * ```
    */
  get keywordRank(): Prisma.KeywordRankDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keywordTracking`: Exposes CRUD operations for the **KeywordTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeywordTrackings
    * const keywordTrackings = await prisma.keywordTracking.findMany()
    * ```
    */
  get keywordTracking(): Prisma.KeywordTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchUpdate`: Exposes CRUD operations for the **BatchUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BatchUpdates
    * const batchUpdates = await prisma.batchUpdate.findMany()
    * ```
    */
  get batchUpdate(): Prisma.BatchUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rankAlert`: Exposes CRUD operations for the **RankAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RankAlerts
    * const rankAlerts = await prisma.rankAlert.findMany()
    * ```
    */
  get rankAlert(): Prisma.RankAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.completedTask`: Exposes CRUD operations for the **CompletedTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompletedTasks
    * const completedTasks = await prisma.completedTask.findMany()
    * ```
    */
  get completedTask(): Prisma.CompletedTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskExclusion`: Exposes CRUD operations for the **TaskExclusion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskExclusions
    * const taskExclusions = await prisma.taskExclusion.findMany()
    * ```
    */
  get taskExclusion(): Prisma.TaskExclusionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationProgress`: Exposes CRUD operations for the **LocationProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationProgresses
    * const locationProgresses = await prisma.locationProgress.findMany()
    * ```
    */
  get locationProgress(): Prisma.LocationProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationMilestone`: Exposes CRUD operations for the **LocationMilestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationMilestones
    * const locationMilestones = await prisma.locationMilestone.findMany()
    * ```
    */
  get locationMilestone(): Prisma.LocationMilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationAchievement`: Exposes CRUD operations for the **LocationAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationAchievements
    * const locationAchievements = await prisma.locationAchievement.findMany()
    * ```
    */
  get locationAchievement(): Prisma.LocationAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userTaskRefresh`: Exposes CRUD operations for the **UserTaskRefresh** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTaskRefreshes
    * const userTaskRefreshes = await prisma.userTaskRefresh.findMany()
    * ```
    */
  get userTaskRefresh(): Prisma.UserTaskRefreshDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.14.0
   * Query Engine version: 717184b7b35ea05dfa71a3236b7af656013e1e49
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Version: 'Version',
    locations: 'locations',
    ScheduledPost: 'ScheduledPost',
    GmbIntegration: 'GmbIntegration',
    CompetitorAnalysis: 'CompetitorAnalysis',
    keywords: 'keywords',
    KeywordRank: 'KeywordRank',
    KeywordTracking: 'KeywordTracking',
    BatchUpdate: 'BatchUpdate',
    UserSettings: 'UserSettings',
    RankAlert: 'RankAlert',
    Task: 'Task',
    CompletedTask: 'CompletedTask',
    TaskExclusion: 'TaskExclusion',
    UserProgress: 'UserProgress',
    LocationProgress: 'LocationProgress',
    Milestone: 'Milestone',
    LocationMilestone: 'LocationMilestone',
    LocationAchievement: 'LocationAchievement',
    UserTaskRefresh: 'UserTaskRefresh'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "version" | "locations" | "scheduledPost" | "gmbIntegration" | "competitorAnalysis" | "keywords" | "keywordRank" | "keywordTracking" | "batchUpdate" | "userSettings" | "rankAlert" | "task" | "completedTask" | "taskExclusion" | "userProgress" | "locationProgress" | "milestone" | "locationMilestone" | "locationAchievement" | "userTaskRefresh"
      txIsolationLevel: never
    }
    model: {
      Version: {
        payload: Prisma.$VersionPayload<ExtArgs>
        fields: Prisma.VersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findFirst: {
            args: Prisma.VersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findMany: {
            args: Prisma.VersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          create: {
            args: Prisma.VersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          createMany: {
            args: Prisma.VersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          update: {
            args: Prisma.VersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          deleteMany: {
            args: Prisma.VersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          aggregate: {
            args: Prisma.VersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersion>
          }
          groupBy: {
            args: Prisma.VersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VersionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VersionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VersionCountArgs<ExtArgs>
            result: $Utils.Optional<VersionCountAggregateOutputType> | number
          }
        }
      }
      locations: {
        payload: Prisma.$locationsPayload<ExtArgs>
        fields: Prisma.locationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.locationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.locationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findFirst: {
            args: Prisma.locationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.locationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          findMany: {
            args: Prisma.locationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>[]
          }
          create: {
            args: Prisma.locationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          createMany: {
            args: Prisma.locationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.locationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          update: {
            args: Prisma.locationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          deleteMany: {
            args: Prisma.locationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.locationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.locationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$locationsPayload>
          }
          aggregate: {
            args: Prisma.LocationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocations>
          }
          groupBy: {
            args: Prisma.locationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.locationsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.locationsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.locationsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationsCountAggregateOutputType> | number
          }
        }
      }
      ScheduledPost: {
        payload: Prisma.$ScheduledPostPayload<ExtArgs>
        fields: Prisma.ScheduledPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduledPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduledPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findFirst: {
            args: Prisma.ScheduledPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduledPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          findMany: {
            args: Prisma.ScheduledPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>[]
          }
          create: {
            args: Prisma.ScheduledPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          createMany: {
            args: Prisma.ScheduledPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ScheduledPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          update: {
            args: Prisma.ScheduledPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          deleteMany: {
            args: Prisma.ScheduledPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduledPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduledPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduledPostPayload>
          }
          aggregate: {
            args: Prisma.ScheduledPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduledPost>
          }
          groupBy: {
            args: Prisma.ScheduledPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ScheduledPostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ScheduledPostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ScheduledPostCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduledPostCountAggregateOutputType> | number
          }
        }
      }
      GmbIntegration: {
        payload: Prisma.$GmbIntegrationPayload<ExtArgs>
        fields: Prisma.GmbIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GmbIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GmbIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>
          }
          findFirst: {
            args: Prisma.GmbIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GmbIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>
          }
          findMany: {
            args: Prisma.GmbIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>[]
          }
          create: {
            args: Prisma.GmbIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>
          }
          createMany: {
            args: Prisma.GmbIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.GmbIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>
          }
          update: {
            args: Prisma.GmbIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.GmbIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GmbIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GmbIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GmbIntegrationPayload>
          }
          aggregate: {
            args: Prisma.GmbIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGmbIntegration>
          }
          groupBy: {
            args: Prisma.GmbIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<GmbIntegrationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GmbIntegrationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.GmbIntegrationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.GmbIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<GmbIntegrationCountAggregateOutputType> | number
          }
        }
      }
      CompetitorAnalysis: {
        payload: Prisma.$CompetitorAnalysisPayload<ExtArgs>
        fields: Prisma.CompetitorAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompetitorAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompetitorAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          findFirst: {
            args: Prisma.CompetitorAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompetitorAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          findMany: {
            args: Prisma.CompetitorAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>[]
          }
          create: {
            args: Prisma.CompetitorAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          createMany: {
            args: Prisma.CompetitorAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompetitorAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          update: {
            args: Prisma.CompetitorAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.CompetitorAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompetitorAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompetitorAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompetitorAnalysisPayload>
          }
          aggregate: {
            args: Prisma.CompetitorAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompetitorAnalysis>
          }
          groupBy: {
            args: Prisma.CompetitorAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompetitorAnalysisGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CompetitorAnalysisFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CompetitorAnalysisAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CompetitorAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<CompetitorAnalysisCountAggregateOutputType> | number
          }
        }
      }
      keywords: {
        payload: Prisma.$keywordsPayload<ExtArgs>
        fields: Prisma.keywordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.keywordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.keywordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          findFirst: {
            args: Prisma.keywordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.keywordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          findMany: {
            args: Prisma.keywordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>[]
          }
          create: {
            args: Prisma.keywordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          createMany: {
            args: Prisma.keywordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.keywordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          update: {
            args: Prisma.keywordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          deleteMany: {
            args: Prisma.keywordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.keywordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.keywordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          aggregate: {
            args: Prisma.KeywordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeywords>
          }
          groupBy: {
            args: Prisma.keywordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.keywordsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.keywordsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.keywordsCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordsCountAggregateOutputType> | number
          }
        }
      }
      KeywordRank: {
        payload: Prisma.$KeywordRankPayload<ExtArgs>
        fields: Prisma.KeywordRankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordRankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordRankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>
          }
          findFirst: {
            args: Prisma.KeywordRankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordRankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>
          }
          findMany: {
            args: Prisma.KeywordRankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>[]
          }
          create: {
            args: Prisma.KeywordRankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>
          }
          createMany: {
            args: Prisma.KeywordRankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KeywordRankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>
          }
          update: {
            args: Prisma.KeywordRankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>
          }
          deleteMany: {
            args: Prisma.KeywordRankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordRankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KeywordRankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordRankPayload>
          }
          aggregate: {
            args: Prisma.KeywordRankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeywordRank>
          }
          groupBy: {
            args: Prisma.KeywordRankGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordRankGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.KeywordRankFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.KeywordRankAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.KeywordRankCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordRankCountAggregateOutputType> | number
          }
        }
      }
      KeywordTracking: {
        payload: Prisma.$KeywordTrackingPayload<ExtArgs>
        fields: Prisma.KeywordTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>
          }
          findFirst: {
            args: Prisma.KeywordTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>
          }
          findMany: {
            args: Prisma.KeywordTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>[]
          }
          create: {
            args: Prisma.KeywordTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>
          }
          createMany: {
            args: Prisma.KeywordTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.KeywordTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>
          }
          update: {
            args: Prisma.KeywordTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>
          }
          deleteMany: {
            args: Prisma.KeywordTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KeywordTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordTrackingPayload>
          }
          aggregate: {
            args: Prisma.KeywordTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeywordTracking>
          }
          groupBy: {
            args: Prisma.KeywordTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordTrackingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.KeywordTrackingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.KeywordTrackingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.KeywordTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordTrackingCountAggregateOutputType> | number
          }
        }
      }
      BatchUpdate: {
        payload: Prisma.$BatchUpdatePayload<ExtArgs>
        fields: Prisma.BatchUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>
          }
          findFirst: {
            args: Prisma.BatchUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>
          }
          findMany: {
            args: Prisma.BatchUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>[]
          }
          create: {
            args: Prisma.BatchUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>
          }
          createMany: {
            args: Prisma.BatchUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BatchUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>
          }
          update: {
            args: Prisma.BatchUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>
          }
          deleteMany: {
            args: Prisma.BatchUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BatchUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchUpdatePayload>
          }
          aggregate: {
            args: Prisma.BatchUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchUpdate>
          }
          groupBy: {
            args: Prisma.BatchUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchUpdateGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.BatchUpdateFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.BatchUpdateAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.BatchUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<BatchUpdateCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserSettingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserSettingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      RankAlert: {
        payload: Prisma.$RankAlertPayload<ExtArgs>
        fields: Prisma.RankAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RankAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RankAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>
          }
          findFirst: {
            args: Prisma.RankAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RankAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>
          }
          findMany: {
            args: Prisma.RankAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>[]
          }
          create: {
            args: Prisma.RankAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>
          }
          createMany: {
            args: Prisma.RankAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RankAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>
          }
          update: {
            args: Prisma.RankAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>
          }
          deleteMany: {
            args: Prisma.RankAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RankAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RankAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RankAlertPayload>
          }
          aggregate: {
            args: Prisma.RankAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRankAlert>
          }
          groupBy: {
            args: Prisma.RankAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<RankAlertGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RankAlertFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.RankAlertAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.RankAlertCountArgs<ExtArgs>
            result: $Utils.Optional<RankAlertCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TaskFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TaskAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      CompletedTask: {
        payload: Prisma.$CompletedTaskPayload<ExtArgs>
        fields: Prisma.CompletedTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompletedTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompletedTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>
          }
          findFirst: {
            args: Prisma.CompletedTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompletedTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>
          }
          findMany: {
            args: Prisma.CompletedTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>[]
          }
          create: {
            args: Prisma.CompletedTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>
          }
          createMany: {
            args: Prisma.CompletedTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CompletedTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>
          }
          update: {
            args: Prisma.CompletedTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>
          }
          deleteMany: {
            args: Prisma.CompletedTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompletedTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CompletedTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompletedTaskPayload>
          }
          aggregate: {
            args: Prisma.CompletedTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompletedTask>
          }
          groupBy: {
            args: Prisma.CompletedTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompletedTaskGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CompletedTaskFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.CompletedTaskAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.CompletedTaskCountArgs<ExtArgs>
            result: $Utils.Optional<CompletedTaskCountAggregateOutputType> | number
          }
        }
      }
      TaskExclusion: {
        payload: Prisma.$TaskExclusionPayload<ExtArgs>
        fields: Prisma.TaskExclusionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskExclusionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskExclusionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>
          }
          findFirst: {
            args: Prisma.TaskExclusionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskExclusionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>
          }
          findMany: {
            args: Prisma.TaskExclusionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>[]
          }
          create: {
            args: Prisma.TaskExclusionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>
          }
          createMany: {
            args: Prisma.TaskExclusionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TaskExclusionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>
          }
          update: {
            args: Prisma.TaskExclusionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>
          }
          deleteMany: {
            args: Prisma.TaskExclusionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskExclusionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TaskExclusionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskExclusionPayload>
          }
          aggregate: {
            args: Prisma.TaskExclusionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskExclusion>
          }
          groupBy: {
            args: Prisma.TaskExclusionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskExclusionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TaskExclusionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TaskExclusionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TaskExclusionCountArgs<ExtArgs>
            result: $Utils.Optional<TaskExclusionCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserProgressFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserProgressAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      LocationProgress: {
        payload: Prisma.$LocationProgressPayload<ExtArgs>
        fields: Prisma.LocationProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>
          }
          findFirst: {
            args: Prisma.LocationProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>
          }
          findMany: {
            args: Prisma.LocationProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>[]
          }
          create: {
            args: Prisma.LocationProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>
          }
          createMany: {
            args: Prisma.LocationProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>
          }
          update: {
            args: Prisma.LocationProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>
          }
          deleteMany: {
            args: Prisma.LocationProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationProgressPayload>
          }
          aggregate: {
            args: Prisma.LocationProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationProgress>
          }
          groupBy: {
            args: Prisma.LocationProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationProgressGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocationProgressFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocationProgressAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocationProgressCountArgs<ExtArgs>
            result: $Utils.Optional<LocationProgressCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MilestoneFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MilestoneAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      LocationMilestone: {
        payload: Prisma.$LocationMilestonePayload<ExtArgs>
        fields: Prisma.LocationMilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationMilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationMilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>
          }
          findFirst: {
            args: Prisma.LocationMilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationMilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>
          }
          findMany: {
            args: Prisma.LocationMilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>[]
          }
          create: {
            args: Prisma.LocationMilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>
          }
          createMany: {
            args: Prisma.LocationMilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationMilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>
          }
          update: {
            args: Prisma.LocationMilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>
          }
          deleteMany: {
            args: Prisma.LocationMilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationMilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationMilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationMilestonePayload>
          }
          aggregate: {
            args: Prisma.LocationMilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationMilestone>
          }
          groupBy: {
            args: Prisma.LocationMilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationMilestoneGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocationMilestoneFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocationMilestoneAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocationMilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<LocationMilestoneCountAggregateOutputType> | number
          }
        }
      }
      LocationAchievement: {
        payload: Prisma.$LocationAchievementPayload<ExtArgs>
        fields: Prisma.LocationAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>
          }
          findFirst: {
            args: Prisma.LocationAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>
          }
          findMany: {
            args: Prisma.LocationAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>[]
          }
          create: {
            args: Prisma.LocationAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>
          }
          createMany: {
            args: Prisma.LocationAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>
          }
          update: {
            args: Prisma.LocationAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>
          }
          deleteMany: {
            args: Prisma.LocationAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationAchievementPayload>
          }
          aggregate: {
            args: Prisma.LocationAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationAchievement>
          }
          groupBy: {
            args: Prisma.LocationAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationAchievementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LocationAchievementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LocationAchievementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LocationAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<LocationAchievementCountAggregateOutputType> | number
          }
        }
      }
      UserTaskRefresh: {
        payload: Prisma.$UserTaskRefreshPayload<ExtArgs>
        fields: Prisma.UserTaskRefreshFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTaskRefreshFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTaskRefreshFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>
          }
          findFirst: {
            args: Prisma.UserTaskRefreshFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTaskRefreshFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>
          }
          findMany: {
            args: Prisma.UserTaskRefreshFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>[]
          }
          create: {
            args: Prisma.UserTaskRefreshCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>
          }
          createMany: {
            args: Prisma.UserTaskRefreshCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserTaskRefreshDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>
          }
          update: {
            args: Prisma.UserTaskRefreshUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>
          }
          deleteMany: {
            args: Prisma.UserTaskRefreshDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTaskRefreshUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTaskRefreshUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskRefreshPayload>
          }
          aggregate: {
            args: Prisma.UserTaskRefreshAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTaskRefresh>
          }
          groupBy: {
            args: Prisma.UserTaskRefreshGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTaskRefreshGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserTaskRefreshFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserTaskRefreshAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserTaskRefreshCountArgs<ExtArgs>
            result: $Utils.Optional<UserTaskRefreshCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    version?: VersionOmit
    locations?: locationsOmit
    scheduledPost?: ScheduledPostOmit
    gmbIntegration?: GmbIntegrationOmit
    competitorAnalysis?: CompetitorAnalysisOmit
    keywords?: keywordsOmit
    keywordRank?: KeywordRankOmit
    keywordTracking?: KeywordTrackingOmit
    batchUpdate?: BatchUpdateOmit
    userSettings?: UserSettingsOmit
    rankAlert?: RankAlertOmit
    task?: TaskOmit
    completedTask?: CompletedTaskOmit
    taskExclusion?: TaskExclusionOmit
    userProgress?: UserProgressOmit
    locationProgress?: LocationProgressOmit
    milestone?: MilestoneOmit
    locationMilestone?: LocationMilestoneOmit
    locationAchievement?: LocationAchievementOmit
    userTaskRefresh?: UserTaskRefreshOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model Version
   */

  export type AggregateVersion = {
    _count: VersionCountAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  export type VersionMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionCountAggregateOutputType = {
    id: number
    name: number
    version: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VersionMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionCountAggregateInputType = {
    id?: true
    name?: true
    version?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Version to aggregate.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Versions
    **/
    _count?: true | VersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionMaxAggregateInputType
  }

  export type GetVersionAggregateType<T extends VersionAggregateArgs> = {
        [P in keyof T & keyof AggregateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersion[P]>
      : GetScalarType<T[P], AggregateVersion[P]>
  }




  export type VersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithAggregationInput | VersionOrderByWithAggregationInput[]
    by: VersionScalarFieldEnum[] | VersionScalarFieldEnum
    having?: VersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionCountAggregateInputType | true
    _min?: VersionMinAggregateInputType
    _max?: VersionMaxAggregateInputType
  }

  export type VersionGroupByOutputType = {
    id: string
    name: string
    version: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: VersionCountAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  type GetVersionGroupByPayload<T extends VersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupByOutputType[P]>
        }
      >
    >


  export type VersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["version"]>



  export type VersionSelectScalar = {
    id?: boolean
    name?: boolean
    version?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "version" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["version"]>

  export type $VersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Version"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      version: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["version"]>
    composites: {}
  }

  type VersionGetPayload<S extends boolean | null | undefined | VersionDefaultArgs> = $Result.GetResult<Prisma.$VersionPayload, S>

  type VersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionCountAggregateInputType | true
    }

  export interface VersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Version'], meta: { name: 'Version' } }
    /**
     * Find zero or one Version that matches the filter.
     * @param {VersionFindUniqueArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionFindUniqueArgs>(args: SelectSubset<T, VersionFindUniqueArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionFindUniqueOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionFindFirstArgs>(args?: SelectSubset<T, VersionFindFirstArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versions
     * const versions = await prisma.version.findMany()
     * 
     * // Get first 10 Versions
     * const versions = await prisma.version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionWithIdOnly = await prisma.version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionFindManyArgs>(args?: SelectSubset<T, VersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Version.
     * @param {VersionCreateArgs} args - Arguments to create a Version.
     * @example
     * // Create one Version
     * const Version = await prisma.version.create({
     *   data: {
     *     // ... data to create a Version
     *   }
     * })
     * 
     */
    create<T extends VersionCreateArgs>(args: SelectSubset<T, VersionCreateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Versions.
     * @param {VersionCreateManyArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionCreateManyArgs>(args?: SelectSubset<T, VersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Version.
     * @param {VersionDeleteArgs} args - Arguments to delete one Version.
     * @example
     * // Delete one Version
     * const Version = await prisma.version.delete({
     *   where: {
     *     // ... filter to delete one Version
     *   }
     * })
     * 
     */
    delete<T extends VersionDeleteArgs>(args: SelectSubset<T, VersionDeleteArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Version.
     * @param {VersionUpdateArgs} args - Arguments to update one Version.
     * @example
     * // Update one Version
     * const version = await prisma.version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionUpdateArgs>(args: SelectSubset<T, VersionUpdateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Versions.
     * @param {VersionDeleteManyArgs} args - Arguments to filter Versions to delete.
     * @example
     * // Delete a few Versions
     * const { count } = await prisma.version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionDeleteManyArgs>(args?: SelectSubset<T, VersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionUpdateManyArgs>(args: SelectSubset<T, VersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Version.
     * @param {VersionUpsertArgs} args - Arguments to update or create a Version.
     * @example
     * // Update or create a Version
     * const version = await prisma.version.upsert({
     *   create: {
     *     // ... data to create a Version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Version we want to update
     *   }
     * })
     */
    upsert<T extends VersionUpsertArgs>(args: SelectSubset<T, VersionUpsertArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * @param {VersionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const version = await prisma.version.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VersionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Version.
     * @param {VersionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const version = await prisma.version.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VersionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionCountArgs} args - Arguments to filter Versions to count.
     * @example
     * // Count the number of Versions
     * const count = await prisma.version.count({
     *   where: {
     *     // ... the filter for the Versions we want to count
     *   }
     * })
    **/
    count<T extends VersionCountArgs>(
      args?: Subset<T, VersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionAggregateArgs>(args: Subset<T, VersionAggregateArgs>): Prisma.PrismaPromise<GetVersionAggregateType<T>>

    /**
     * Group by Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Version model
   */
  readonly fields: VersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Version model
   */
  interface VersionFieldRefs {
    readonly id: FieldRef<"Version", 'String'>
    readonly name: FieldRef<"Version", 'String'>
    readonly version: FieldRef<"Version", 'String'>
    readonly description: FieldRef<"Version", 'String'>
    readonly isActive: FieldRef<"Version", 'Boolean'>
    readonly createdAt: FieldRef<"Version", 'DateTime'>
    readonly updatedAt: FieldRef<"Version", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Version findUnique
   */
  export type VersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findUniqueOrThrow
   */
  export type VersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findFirst
   */
  export type VersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findFirstOrThrow
   */
  export type VersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findMany
   */
  export type VersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Filter, which Versions to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version create
   */
  export type VersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data needed to create a Version.
     */
    data: XOR<VersionCreateInput, VersionUncheckedCreateInput>
  }

  /**
   * Version createMany
   */
  export type VersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
  }

  /**
   * Version update
   */
  export type VersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data needed to update a Version.
     */
    data: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
    /**
     * Choose, which Version to update.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version updateMany
   */
  export type VersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
  }

  /**
   * Version upsert
   */
  export type VersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The filter to search for the Version to update in case it exists.
     */
    where: VersionWhereUniqueInput
    /**
     * In case the Version found by the `where` argument doesn't exist, create a new Version with this data.
     */
    create: XOR<VersionCreateInput, VersionUncheckedCreateInput>
    /**
     * In case the Version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
  }

  /**
   * Version delete
   */
  export type VersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Filter which Version to delete.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version deleteMany
   */
  export type VersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Versions to delete
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to delete.
     */
    limit?: number
  }

  /**
   * Version findRaw
   */
  export type VersionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Version aggregateRaw
   */
  export type VersionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Version without action
   */
  export type VersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
  }


  /**
   * Model locations
   */

  export type AggregateLocations = {
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  export type LocationsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    location_id: string | null
    location_name: string | null
    website: string | null
    categories: string | null
    last_rank_updated: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    location_id: string | null
    location_name: string | null
    website: string | null
    categories: string | null
    last_rank_updated: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type LocationsCountAggregateOutputType = {
    id: number
    user_id: number
    location_id: number
    location_name: number
    website: number
    categories: number
    last_rank_updated: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type LocationsMinAggregateInputType = {
    id?: true
    user_id?: true
    location_id?: true
    location_name?: true
    website?: true
    categories?: true
    last_rank_updated?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    location_id?: true
    location_name?: true
    website?: true
    categories?: true
    last_rank_updated?: true
    created_at?: true
    updated_at?: true
  }

  export type LocationsCountAggregateInputType = {
    id?: true
    user_id?: true
    location_id?: true
    location_name?: true
    website?: true
    categories?: true
    last_rank_updated?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type LocationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to aggregate.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned locations
    **/
    _count?: true | LocationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationsMaxAggregateInputType
  }

  export type GetLocationsAggregateType<T extends LocationsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocations[P]>
      : GetScalarType<T[P], AggregateLocations[P]>
  }




  export type locationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: locationsWhereInput
    orderBy?: locationsOrderByWithAggregationInput | locationsOrderByWithAggregationInput[]
    by: LocationsScalarFieldEnum[] | LocationsScalarFieldEnum
    having?: locationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationsCountAggregateInputType | true
    _min?: LocationsMinAggregateInputType
    _max?: LocationsMaxAggregateInputType
  }

  export type LocationsGroupByOutputType = {
    id: string
    user_id: string
    location_id: string
    location_name: string
    website: string | null
    categories: string | null
    last_rank_updated: Date | null
    created_at: Date
    updated_at: Date
    _count: LocationsCountAggregateOutputType | null
    _min: LocationsMinAggregateOutputType | null
    _max: LocationsMaxAggregateOutputType | null
  }

  type GetLocationsGroupByPayload<T extends locationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationsGroupByOutputType[P]>
        }
      >
    >


  export type locationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    location_id?: boolean
    location_name?: boolean
    website?: boolean
    categories?: boolean
    last_rank_updated?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["locations"]>



  export type locationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    location_id?: boolean
    location_name?: boolean
    website?: boolean
    categories?: boolean
    last_rank_updated?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type locationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "location_id" | "location_name" | "website" | "categories" | "last_rank_updated" | "created_at" | "updated_at", ExtArgs["result"]["locations"]>

  export type $locationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "locations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      location_id: string
      location_name: string
      website: string | null
      categories: string | null
      last_rank_updated: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["locations"]>
    composites: {}
  }

  type locationsGetPayload<S extends boolean | null | undefined | locationsDefaultArgs> = $Result.GetResult<Prisma.$locationsPayload, S>

  type locationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<locationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationsCountAggregateInputType | true
    }

  export interface locationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['locations'], meta: { name: 'locations' } }
    /**
     * Find zero or one Locations that matches the filter.
     * @param {locationsFindUniqueArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends locationsFindUniqueArgs>(args: SelectSubset<T, locationsFindUniqueArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Locations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {locationsFindUniqueOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends locationsFindUniqueOrThrowArgs>(args: SelectSubset<T, locationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends locationsFindFirstArgs>(args?: SelectSubset<T, locationsFindFirstArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Locations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindFirstOrThrowArgs} args - Arguments to find a Locations
     * @example
     * // Get one Locations
     * const locations = await prisma.locations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends locationsFindFirstOrThrowArgs>(args?: SelectSubset<T, locationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.locations.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.locations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationsWithIdOnly = await prisma.locations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends locationsFindManyArgs>(args?: SelectSubset<T, locationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Locations.
     * @param {locationsCreateArgs} args - Arguments to create a Locations.
     * @example
     * // Create one Locations
     * const Locations = await prisma.locations.create({
     *   data: {
     *     // ... data to create a Locations
     *   }
     * })
     * 
     */
    create<T extends locationsCreateArgs>(args: SelectSubset<T, locationsCreateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {locationsCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const locations = await prisma.locations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends locationsCreateManyArgs>(args?: SelectSubset<T, locationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Locations.
     * @param {locationsDeleteArgs} args - Arguments to delete one Locations.
     * @example
     * // Delete one Locations
     * const Locations = await prisma.locations.delete({
     *   where: {
     *     // ... filter to delete one Locations
     *   }
     * })
     * 
     */
    delete<T extends locationsDeleteArgs>(args: SelectSubset<T, locationsDeleteArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Locations.
     * @param {locationsUpdateArgs} args - Arguments to update one Locations.
     * @example
     * // Update one Locations
     * const locations = await prisma.locations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends locationsUpdateArgs>(args: SelectSubset<T, locationsUpdateArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {locationsDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.locations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends locationsDeleteManyArgs>(args?: SelectSubset<T, locationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const locations = await prisma.locations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends locationsUpdateManyArgs>(args: SelectSubset<T, locationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Locations.
     * @param {locationsUpsertArgs} args - Arguments to update or create a Locations.
     * @example
     * // Update or create a Locations
     * const locations = await prisma.locations.upsert({
     *   create: {
     *     // ... data to create a Locations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Locations we want to update
     *   }
     * })
     */
    upsert<T extends locationsUpsertArgs>(args: SelectSubset<T, locationsUpsertArgs<ExtArgs>>): Prisma__locationsClient<$Result.GetResult<Prisma.$locationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * @param {locationsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const locations = await prisma.locations.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: locationsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Locations.
     * @param {locationsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const locations = await prisma.locations.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: locationsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.locations.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends locationsCountArgs>(
      args?: Subset<T, locationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationsAggregateArgs>(args: Subset<T, LocationsAggregateArgs>): Prisma.PrismaPromise<GetLocationsAggregateType<T>>

    /**
     * Group by Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {locationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends locationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: locationsGroupByArgs['orderBy'] }
        : { orderBy?: locationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, locationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the locations model
   */
  readonly fields: locationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for locations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__locationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the locations model
   */
  interface locationsFieldRefs {
    readonly id: FieldRef<"locations", 'String'>
    readonly user_id: FieldRef<"locations", 'String'>
    readonly location_id: FieldRef<"locations", 'String'>
    readonly location_name: FieldRef<"locations", 'String'>
    readonly website: FieldRef<"locations", 'String'>
    readonly categories: FieldRef<"locations", 'String'>
    readonly last_rank_updated: FieldRef<"locations", 'DateTime'>
    readonly created_at: FieldRef<"locations", 'DateTime'>
    readonly updated_at: FieldRef<"locations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * locations findUnique
   */
  export type locationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findUniqueOrThrow
   */
  export type locationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations findFirst
   */
  export type locationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findFirstOrThrow
   */
  export type locationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of locations.
     */
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations findMany
   */
  export type locationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter, which locations to fetch.
     */
    where?: locationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of locations to fetch.
     */
    orderBy?: locationsOrderByWithRelationInput | locationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing locations.
     */
    cursor?: locationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` locations.
     */
    skip?: number
    distinct?: LocationsScalarFieldEnum | LocationsScalarFieldEnum[]
  }

  /**
   * locations create
   */
  export type locationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data needed to create a locations.
     */
    data: XOR<locationsCreateInput, locationsUncheckedCreateInput>
  }

  /**
   * locations createMany
   */
  export type locationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many locations.
     */
    data: locationsCreateManyInput | locationsCreateManyInput[]
  }

  /**
   * locations update
   */
  export type locationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The data needed to update a locations.
     */
    data: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
    /**
     * Choose, which locations to update.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations updateMany
   */
  export type locationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update locations.
     */
    data: XOR<locationsUpdateManyMutationInput, locationsUncheckedUpdateManyInput>
    /**
     * Filter which locations to update
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to update.
     */
    limit?: number
  }

  /**
   * locations upsert
   */
  export type locationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * The filter to search for the locations to update in case it exists.
     */
    where: locationsWhereUniqueInput
    /**
     * In case the locations found by the `where` argument doesn't exist, create a new locations with this data.
     */
    create: XOR<locationsCreateInput, locationsUncheckedCreateInput>
    /**
     * In case the locations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<locationsUpdateInput, locationsUncheckedUpdateInput>
  }

  /**
   * locations delete
   */
  export type locationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
    /**
     * Filter which locations to delete.
     */
    where: locationsWhereUniqueInput
  }

  /**
   * locations deleteMany
   */
  export type locationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which locations to delete
     */
    where?: locationsWhereInput
    /**
     * Limit how many locations to delete.
     */
    limit?: number
  }

  /**
   * locations findRaw
   */
  export type locationsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * locations aggregateRaw
   */
  export type locationsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * locations without action
   */
  export type locationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the locations
     */
    select?: locationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the locations
     */
    omit?: locationsOmit<ExtArgs> | null
  }


  /**
   * Model ScheduledPost
   */

  export type AggregateScheduledPost = {
    _count: ScheduledPostCountAggregateOutputType | null
    _avg: ScheduledPostAvgAggregateOutputType | null
    _sum: ScheduledPostSumAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  export type ScheduledPostAvgAggregateOutputType = {
    retryCount: number | null
    maxRetries: number | null
  }

  export type ScheduledPostSumAggregateOutputType = {
    retryCount: number | null
    maxRetries: number | null
  }

  export type ScheduledPostMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    summary: string | null
    languageCode: string | null
    topicType: string | null
    mediaFormat: string | null
    imageUrl: string | null
    originalImageUrl: string | null
    actionType: string | null
    actionUrl: string | null
    accountId: string | null
    locationId: string | null
    accessToken: string | null
    scheduledAt: Date | null
    timezone: string | null
    status: $Enums.ScheduledPostStatus | null
    publishedAt: Date | null
    publishedPostId: string | null
    errorMessage: string | null
    retryCount: number | null
    maxRetries: number | null
    viewColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ScheduledPostMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    summary: string | null
    languageCode: string | null
    topicType: string | null
    mediaFormat: string | null
    imageUrl: string | null
    originalImageUrl: string | null
    actionType: string | null
    actionUrl: string | null
    accountId: string | null
    locationId: string | null
    accessToken: string | null
    scheduledAt: Date | null
    timezone: string | null
    status: $Enums.ScheduledPostStatus | null
    publishedAt: Date | null
    publishedPostId: string | null
    errorMessage: string | null
    retryCount: number | null
    maxRetries: number | null
    viewColor: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ScheduledPostCountAggregateOutputType = {
    id: number
    user_id: number
    summary: number
    languageCode: number
    topicType: number
    mediaFormat: number
    imageUrl: number
    originalImageUrl: number
    actionType: number
    actionUrl: number
    accountId: number
    locationId: number
    accessToken: number
    scheduledAt: number
    timezone: number
    status: number
    publishedAt: number
    publishedPostId: number
    errorMessage: number
    retryCount: number
    maxRetries: number
    viewColor: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type ScheduledPostAvgAggregateInputType = {
    retryCount?: true
    maxRetries?: true
  }

  export type ScheduledPostSumAggregateInputType = {
    retryCount?: true
    maxRetries?: true
  }

  export type ScheduledPostMinAggregateInputType = {
    id?: true
    user_id?: true
    summary?: true
    languageCode?: true
    topicType?: true
    mediaFormat?: true
    imageUrl?: true
    originalImageUrl?: true
    actionType?: true
    actionUrl?: true
    accountId?: true
    locationId?: true
    accessToken?: true
    scheduledAt?: true
    timezone?: true
    status?: true
    publishedAt?: true
    publishedPostId?: true
    errorMessage?: true
    retryCount?: true
    maxRetries?: true
    viewColor?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ScheduledPostMaxAggregateInputType = {
    id?: true
    user_id?: true
    summary?: true
    languageCode?: true
    topicType?: true
    mediaFormat?: true
    imageUrl?: true
    originalImageUrl?: true
    actionType?: true
    actionUrl?: true
    accountId?: true
    locationId?: true
    accessToken?: true
    scheduledAt?: true
    timezone?: true
    status?: true
    publishedAt?: true
    publishedPostId?: true
    errorMessage?: true
    retryCount?: true
    maxRetries?: true
    viewColor?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ScheduledPostCountAggregateInputType = {
    id?: true
    user_id?: true
    summary?: true
    languageCode?: true
    topicType?: true
    mediaFormat?: true
    imageUrl?: true
    originalImageUrl?: true
    actionType?: true
    actionUrl?: true
    accountId?: true
    locationId?: true
    accessToken?: true
    scheduledAt?: true
    timezone?: true
    status?: true
    publishedAt?: true
    publishedPostId?: true
    errorMessage?: true
    retryCount?: true
    maxRetries?: true
    viewColor?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type ScheduledPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPost to aggregate.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduledPosts
    **/
    _count?: true | ScheduledPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduledPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduledPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduledPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type GetScheduledPostAggregateType<T extends ScheduledPostAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduledPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduledPost[P]>
      : GetScalarType<T[P], AggregateScheduledPost[P]>
  }




  export type ScheduledPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduledPostWhereInput
    orderBy?: ScheduledPostOrderByWithAggregationInput | ScheduledPostOrderByWithAggregationInput[]
    by: ScheduledPostScalarFieldEnum[] | ScheduledPostScalarFieldEnum
    having?: ScheduledPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduledPostCountAggregateInputType | true
    _avg?: ScheduledPostAvgAggregateInputType
    _sum?: ScheduledPostSumAggregateInputType
    _min?: ScheduledPostMinAggregateInputType
    _max?: ScheduledPostMaxAggregateInputType
  }

  export type ScheduledPostGroupByOutputType = {
    id: string
    user_id: string
    summary: string
    languageCode: string
    topicType: string
    mediaFormat: string
    imageUrl: string
    originalImageUrl: string | null
    actionType: string | null
    actionUrl: string | null
    accountId: string
    locationId: string
    accessToken: string
    scheduledAt: Date
    timezone: string | null
    status: $Enums.ScheduledPostStatus
    publishedAt: Date | null
    publishedPostId: string | null
    errorMessage: string | null
    retryCount: number
    maxRetries: number
    viewColor: string
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: ScheduledPostCountAggregateOutputType | null
    _avg: ScheduledPostAvgAggregateOutputType | null
    _sum: ScheduledPostSumAggregateOutputType | null
    _min: ScheduledPostMinAggregateOutputType | null
    _max: ScheduledPostMaxAggregateOutputType | null
  }

  type GetScheduledPostGroupByPayload<T extends ScheduledPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduledPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduledPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduledPostGroupByOutputType[P]>
        }
      >
    >


  export type ScheduledPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    summary?: boolean
    languageCode?: boolean
    topicType?: boolean
    mediaFormat?: boolean
    imageUrl?: boolean
    originalImageUrl?: boolean
    actionType?: boolean
    actionUrl?: boolean
    accountId?: boolean
    locationId?: boolean
    accessToken?: boolean
    scheduledAt?: boolean
    timezone?: boolean
    status?: boolean
    publishedAt?: boolean
    publishedPostId?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    viewColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["scheduledPost"]>



  export type ScheduledPostSelectScalar = {
    id?: boolean
    user_id?: boolean
    summary?: boolean
    languageCode?: boolean
    topicType?: boolean
    mediaFormat?: boolean
    imageUrl?: boolean
    originalImageUrl?: boolean
    actionType?: boolean
    actionUrl?: boolean
    accountId?: boolean
    locationId?: boolean
    accessToken?: boolean
    scheduledAt?: boolean
    timezone?: boolean
    status?: boolean
    publishedAt?: boolean
    publishedPostId?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    maxRetries?: boolean
    viewColor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type ScheduledPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "summary" | "languageCode" | "topicType" | "mediaFormat" | "imageUrl" | "originalImageUrl" | "actionType" | "actionUrl" | "accountId" | "locationId" | "accessToken" | "scheduledAt" | "timezone" | "status" | "publishedAt" | "publishedPostId" | "errorMessage" | "retryCount" | "maxRetries" | "viewColor" | "createdAt" | "updatedAt" | "createdBy", ExtArgs["result"]["scheduledPost"]>

  export type $ScheduledPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduledPost"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      summary: string
      languageCode: string
      topicType: string
      mediaFormat: string
      imageUrl: string
      originalImageUrl: string | null
      actionType: string | null
      actionUrl: string | null
      accountId: string
      locationId: string
      accessToken: string
      scheduledAt: Date
      timezone: string | null
      status: $Enums.ScheduledPostStatus
      publishedAt: Date | null
      publishedPostId: string | null
      errorMessage: string | null
      retryCount: number
      maxRetries: number
      viewColor: string
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["scheduledPost"]>
    composites: {}
  }

  type ScheduledPostGetPayload<S extends boolean | null | undefined | ScheduledPostDefaultArgs> = $Result.GetResult<Prisma.$ScheduledPostPayload, S>

  type ScheduledPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduledPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduledPostCountAggregateInputType | true
    }

  export interface ScheduledPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduledPost'], meta: { name: 'ScheduledPost' } }
    /**
     * Find zero or one ScheduledPost that matches the filter.
     * @param {ScheduledPostFindUniqueArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduledPostFindUniqueArgs>(args: SelectSubset<T, ScheduledPostFindUniqueArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduledPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduledPostFindUniqueOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduledPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduledPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduledPostFindFirstArgs>(args?: SelectSubset<T, ScheduledPostFindFirstArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduledPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindFirstOrThrowArgs} args - Arguments to find a ScheduledPost
     * @example
     * // Get one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduledPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduledPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany()
     * 
     * // Get first 10 ScheduledPosts
     * const scheduledPosts = await prisma.scheduledPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduledPostWithIdOnly = await prisma.scheduledPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduledPostFindManyArgs>(args?: SelectSubset<T, ScheduledPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduledPost.
     * @param {ScheduledPostCreateArgs} args - Arguments to create a ScheduledPost.
     * @example
     * // Create one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.create({
     *   data: {
     *     // ... data to create a ScheduledPost
     *   }
     * })
     * 
     */
    create<T extends ScheduledPostCreateArgs>(args: SelectSubset<T, ScheduledPostCreateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduledPosts.
     * @param {ScheduledPostCreateManyArgs} args - Arguments to create many ScheduledPosts.
     * @example
     * // Create many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduledPostCreateManyArgs>(args?: SelectSubset<T, ScheduledPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScheduledPost.
     * @param {ScheduledPostDeleteArgs} args - Arguments to delete one ScheduledPost.
     * @example
     * // Delete one ScheduledPost
     * const ScheduledPost = await prisma.scheduledPost.delete({
     *   where: {
     *     // ... filter to delete one ScheduledPost
     *   }
     * })
     * 
     */
    delete<T extends ScheduledPostDeleteArgs>(args: SelectSubset<T, ScheduledPostDeleteArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduledPost.
     * @param {ScheduledPostUpdateArgs} args - Arguments to update one ScheduledPost.
     * @example
     * // Update one ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduledPostUpdateArgs>(args: SelectSubset<T, ScheduledPostUpdateArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduledPosts.
     * @param {ScheduledPostDeleteManyArgs} args - Arguments to filter ScheduledPosts to delete.
     * @example
     * // Delete a few ScheduledPosts
     * const { count } = await prisma.scheduledPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduledPostDeleteManyArgs>(args?: SelectSubset<T, ScheduledPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduledPosts
     * const scheduledPost = await prisma.scheduledPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduledPostUpdateManyArgs>(args: SelectSubset<T, ScheduledPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScheduledPost.
     * @param {ScheduledPostUpsertArgs} args - Arguments to update or create a ScheduledPost.
     * @example
     * // Update or create a ScheduledPost
     * const scheduledPost = await prisma.scheduledPost.upsert({
     *   create: {
     *     // ... data to create a ScheduledPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduledPost we want to update
     *   }
     * })
     */
    upsert<T extends ScheduledPostUpsertArgs>(args: SelectSubset<T, ScheduledPostUpsertArgs<ExtArgs>>): Prisma__ScheduledPostClient<$Result.GetResult<Prisma.$ScheduledPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduledPosts that matches the filter.
     * @param {ScheduledPostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const scheduledPost = await prisma.scheduledPost.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ScheduledPostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ScheduledPost.
     * @param {ScheduledPostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const scheduledPost = await prisma.scheduledPost.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ScheduledPostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ScheduledPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostCountArgs} args - Arguments to filter ScheduledPosts to count.
     * @example
     * // Count the number of ScheduledPosts
     * const count = await prisma.scheduledPost.count({
     *   where: {
     *     // ... the filter for the ScheduledPosts we want to count
     *   }
     * })
    **/
    count<T extends ScheduledPostCountArgs>(
      args?: Subset<T, ScheduledPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduledPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduledPostAggregateArgs>(args: Subset<T, ScheduledPostAggregateArgs>): Prisma.PrismaPromise<GetScheduledPostAggregateType<T>>

    /**
     * Group by ScheduledPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduledPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduledPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduledPostGroupByArgs['orderBy'] }
        : { orderBy?: ScheduledPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduledPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduledPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduledPost model
   */
  readonly fields: ScheduledPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduledPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduledPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduledPost model
   */
  interface ScheduledPostFieldRefs {
    readonly id: FieldRef<"ScheduledPost", 'String'>
    readonly user_id: FieldRef<"ScheduledPost", 'String'>
    readonly summary: FieldRef<"ScheduledPost", 'String'>
    readonly languageCode: FieldRef<"ScheduledPost", 'String'>
    readonly topicType: FieldRef<"ScheduledPost", 'String'>
    readonly mediaFormat: FieldRef<"ScheduledPost", 'String'>
    readonly imageUrl: FieldRef<"ScheduledPost", 'String'>
    readonly originalImageUrl: FieldRef<"ScheduledPost", 'String'>
    readonly actionType: FieldRef<"ScheduledPost", 'String'>
    readonly actionUrl: FieldRef<"ScheduledPost", 'String'>
    readonly accountId: FieldRef<"ScheduledPost", 'String'>
    readonly locationId: FieldRef<"ScheduledPost", 'String'>
    readonly accessToken: FieldRef<"ScheduledPost", 'String'>
    readonly scheduledAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly timezone: FieldRef<"ScheduledPost", 'String'>
    readonly status: FieldRef<"ScheduledPost", 'ScheduledPostStatus'>
    readonly publishedAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly publishedPostId: FieldRef<"ScheduledPost", 'String'>
    readonly errorMessage: FieldRef<"ScheduledPost", 'String'>
    readonly retryCount: FieldRef<"ScheduledPost", 'Int'>
    readonly maxRetries: FieldRef<"ScheduledPost", 'Int'>
    readonly viewColor: FieldRef<"ScheduledPost", 'String'>
    readonly createdAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduledPost", 'DateTime'>
    readonly createdBy: FieldRef<"ScheduledPost", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ScheduledPost findUnique
   */
  export type ScheduledPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findUniqueOrThrow
   */
  export type ScheduledPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost findFirst
   */
  export type ScheduledPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findFirstOrThrow
   */
  export type ScheduledPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledPost to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduledPosts.
     */
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost findMany
   */
  export type ScheduledPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Filter, which ScheduledPosts to fetch.
     */
    where?: ScheduledPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduledPosts to fetch.
     */
    orderBy?: ScheduledPostOrderByWithRelationInput | ScheduledPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduledPosts.
     */
    cursor?: ScheduledPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScheduledPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduledPosts.
     */
    skip?: number
    distinct?: ScheduledPostScalarFieldEnum | ScheduledPostScalarFieldEnum[]
  }

  /**
   * ScheduledPost create
   */
  export type ScheduledPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * The data needed to create a ScheduledPost.
     */
    data: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
  }

  /**
   * ScheduledPost createMany
   */
  export type ScheduledPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduledPosts.
     */
    data: ScheduledPostCreateManyInput | ScheduledPostCreateManyInput[]
  }

  /**
   * ScheduledPost update
   */
  export type ScheduledPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * The data needed to update a ScheduledPost.
     */
    data: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
    /**
     * Choose, which ScheduledPost to update.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost updateMany
   */
  export type ScheduledPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduledPosts.
     */
    data: XOR<ScheduledPostUpdateManyMutationInput, ScheduledPostUncheckedUpdateManyInput>
    /**
     * Filter which ScheduledPosts to update
     */
    where?: ScheduledPostWhereInput
    /**
     * Limit how many ScheduledPosts to update.
     */
    limit?: number
  }

  /**
   * ScheduledPost upsert
   */
  export type ScheduledPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * The filter to search for the ScheduledPost to update in case it exists.
     */
    where: ScheduledPostWhereUniqueInput
    /**
     * In case the ScheduledPost found by the `where` argument doesn't exist, create a new ScheduledPost with this data.
     */
    create: XOR<ScheduledPostCreateInput, ScheduledPostUncheckedCreateInput>
    /**
     * In case the ScheduledPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduledPostUpdateInput, ScheduledPostUncheckedUpdateInput>
  }

  /**
   * ScheduledPost delete
   */
  export type ScheduledPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
    /**
     * Filter which ScheduledPost to delete.
     */
    where: ScheduledPostWhereUniqueInput
  }

  /**
   * ScheduledPost deleteMany
   */
  export type ScheduledPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduledPosts to delete
     */
    where?: ScheduledPostWhereInput
    /**
     * Limit how many ScheduledPosts to delete.
     */
    limit?: number
  }

  /**
   * ScheduledPost findRaw
   */
  export type ScheduledPostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ScheduledPost aggregateRaw
   */
  export type ScheduledPostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ScheduledPost without action
   */
  export type ScheduledPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduledPost
     */
    select?: ScheduledPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduledPost
     */
    omit?: ScheduledPostOmit<ExtArgs> | null
  }


  /**
   * Model GmbIntegration
   */

  export type AggregateGmbIntegration = {
    _count: GmbIntegrationCountAggregateOutputType | null
    _min: GmbIntegrationMinAggregateOutputType | null
    _max: GmbIntegrationMaxAggregateOutputType | null
  }

  export type GmbIntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    user_id: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    accountName: string | null
    accountId: string | null
    clientId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmbIntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    user_id: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiry: Date | null
    accountName: string | null
    accountId: string | null
    clientId: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GmbIntegrationCountAggregateOutputType = {
    id: number
    userId: number
    user_id: number
    accessToken: number
    refreshToken: number
    tokenExpiry: number
    accountName: number
    accountId: number
    clientId: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GmbIntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    user_id?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    accountName?: true
    accountId?: true
    clientId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmbIntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    user_id?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    accountName?: true
    accountId?: true
    clientId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GmbIntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    user_id?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiry?: true
    accountName?: true
    accountId?: true
    clientId?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GmbIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmbIntegration to aggregate.
     */
    where?: GmbIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmbIntegrations to fetch.
     */
    orderBy?: GmbIntegrationOrderByWithRelationInput | GmbIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GmbIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmbIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmbIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GmbIntegrations
    **/
    _count?: true | GmbIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GmbIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GmbIntegrationMaxAggregateInputType
  }

  export type GetGmbIntegrationAggregateType<T extends GmbIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateGmbIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGmbIntegration[P]>
      : GetScalarType<T[P], AggregateGmbIntegration[P]>
  }




  export type GmbIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GmbIntegrationWhereInput
    orderBy?: GmbIntegrationOrderByWithAggregationInput | GmbIntegrationOrderByWithAggregationInput[]
    by: GmbIntegrationScalarFieldEnum[] | GmbIntegrationScalarFieldEnum
    having?: GmbIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GmbIntegrationCountAggregateInputType | true
    _min?: GmbIntegrationMinAggregateInputType
    _max?: GmbIntegrationMaxAggregateInputType
  }

  export type GmbIntegrationGroupByOutputType = {
    id: string
    userId: string
    user_id: string
    accessToken: string
    refreshToken: string | null
    tokenExpiry: Date
    accountName: string | null
    accountId: string | null
    clientId: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: GmbIntegrationCountAggregateOutputType | null
    _min: GmbIntegrationMinAggregateOutputType | null
    _max: GmbIntegrationMaxAggregateOutputType | null
  }

  type GetGmbIntegrationGroupByPayload<T extends GmbIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GmbIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GmbIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GmbIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], GmbIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type GmbIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    user_id?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    accountName?: boolean
    accountId?: boolean
    clientId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["gmbIntegration"]>



  export type GmbIntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    user_id?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiry?: boolean
    accountName?: boolean
    accountId?: boolean
    clientId?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GmbIntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "user_id" | "accessToken" | "refreshToken" | "tokenExpiry" | "accountName" | "accountId" | "clientId" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["gmbIntegration"]>

  export type $GmbIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GmbIntegration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      user_id: string
      accessToken: string
      refreshToken: string | null
      tokenExpiry: Date
      accountName: string | null
      accountId: string | null
      clientId: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gmbIntegration"]>
    composites: {}
  }

  type GmbIntegrationGetPayload<S extends boolean | null | undefined | GmbIntegrationDefaultArgs> = $Result.GetResult<Prisma.$GmbIntegrationPayload, S>

  type GmbIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GmbIntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GmbIntegrationCountAggregateInputType | true
    }

  export interface GmbIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GmbIntegration'], meta: { name: 'GmbIntegration' } }
    /**
     * Find zero or one GmbIntegration that matches the filter.
     * @param {GmbIntegrationFindUniqueArgs} args - Arguments to find a GmbIntegration
     * @example
     * // Get one GmbIntegration
     * const gmbIntegration = await prisma.gmbIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GmbIntegrationFindUniqueArgs>(args: SelectSubset<T, GmbIntegrationFindUniqueArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GmbIntegration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GmbIntegrationFindUniqueOrThrowArgs} args - Arguments to find a GmbIntegration
     * @example
     * // Get one GmbIntegration
     * const gmbIntegration = await prisma.gmbIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GmbIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, GmbIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GmbIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationFindFirstArgs} args - Arguments to find a GmbIntegration
     * @example
     * // Get one GmbIntegration
     * const gmbIntegration = await prisma.gmbIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GmbIntegrationFindFirstArgs>(args?: SelectSubset<T, GmbIntegrationFindFirstArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GmbIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationFindFirstOrThrowArgs} args - Arguments to find a GmbIntegration
     * @example
     * // Get one GmbIntegration
     * const gmbIntegration = await prisma.gmbIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GmbIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, GmbIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GmbIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GmbIntegrations
     * const gmbIntegrations = await prisma.gmbIntegration.findMany()
     * 
     * // Get first 10 GmbIntegrations
     * const gmbIntegrations = await prisma.gmbIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gmbIntegrationWithIdOnly = await prisma.gmbIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GmbIntegrationFindManyArgs>(args?: SelectSubset<T, GmbIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GmbIntegration.
     * @param {GmbIntegrationCreateArgs} args - Arguments to create a GmbIntegration.
     * @example
     * // Create one GmbIntegration
     * const GmbIntegration = await prisma.gmbIntegration.create({
     *   data: {
     *     // ... data to create a GmbIntegration
     *   }
     * })
     * 
     */
    create<T extends GmbIntegrationCreateArgs>(args: SelectSubset<T, GmbIntegrationCreateArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GmbIntegrations.
     * @param {GmbIntegrationCreateManyArgs} args - Arguments to create many GmbIntegrations.
     * @example
     * // Create many GmbIntegrations
     * const gmbIntegration = await prisma.gmbIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GmbIntegrationCreateManyArgs>(args?: SelectSubset<T, GmbIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GmbIntegration.
     * @param {GmbIntegrationDeleteArgs} args - Arguments to delete one GmbIntegration.
     * @example
     * // Delete one GmbIntegration
     * const GmbIntegration = await prisma.gmbIntegration.delete({
     *   where: {
     *     // ... filter to delete one GmbIntegration
     *   }
     * })
     * 
     */
    delete<T extends GmbIntegrationDeleteArgs>(args: SelectSubset<T, GmbIntegrationDeleteArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GmbIntegration.
     * @param {GmbIntegrationUpdateArgs} args - Arguments to update one GmbIntegration.
     * @example
     * // Update one GmbIntegration
     * const gmbIntegration = await prisma.gmbIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GmbIntegrationUpdateArgs>(args: SelectSubset<T, GmbIntegrationUpdateArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GmbIntegrations.
     * @param {GmbIntegrationDeleteManyArgs} args - Arguments to filter GmbIntegrations to delete.
     * @example
     * // Delete a few GmbIntegrations
     * const { count } = await prisma.gmbIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GmbIntegrationDeleteManyArgs>(args?: SelectSubset<T, GmbIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GmbIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GmbIntegrations
     * const gmbIntegration = await prisma.gmbIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GmbIntegrationUpdateManyArgs>(args: SelectSubset<T, GmbIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GmbIntegration.
     * @param {GmbIntegrationUpsertArgs} args - Arguments to update or create a GmbIntegration.
     * @example
     * // Update or create a GmbIntegration
     * const gmbIntegration = await prisma.gmbIntegration.upsert({
     *   create: {
     *     // ... data to create a GmbIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GmbIntegration we want to update
     *   }
     * })
     */
    upsert<T extends GmbIntegrationUpsertArgs>(args: SelectSubset<T, GmbIntegrationUpsertArgs<ExtArgs>>): Prisma__GmbIntegrationClient<$Result.GetResult<Prisma.$GmbIntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GmbIntegrations that matches the filter.
     * @param {GmbIntegrationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const gmbIntegration = await prisma.gmbIntegration.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: GmbIntegrationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GmbIntegration.
     * @param {GmbIntegrationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const gmbIntegration = await prisma.gmbIntegration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: GmbIntegrationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of GmbIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationCountArgs} args - Arguments to filter GmbIntegrations to count.
     * @example
     * // Count the number of GmbIntegrations
     * const count = await prisma.gmbIntegration.count({
     *   where: {
     *     // ... the filter for the GmbIntegrations we want to count
     *   }
     * })
    **/
    count<T extends GmbIntegrationCountArgs>(
      args?: Subset<T, GmbIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GmbIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GmbIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GmbIntegrationAggregateArgs>(args: Subset<T, GmbIntegrationAggregateArgs>): Prisma.PrismaPromise<GetGmbIntegrationAggregateType<T>>

    /**
     * Group by GmbIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GmbIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GmbIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GmbIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: GmbIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GmbIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGmbIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GmbIntegration model
   */
  readonly fields: GmbIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GmbIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GmbIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GmbIntegration model
   */
  interface GmbIntegrationFieldRefs {
    readonly id: FieldRef<"GmbIntegration", 'String'>
    readonly userId: FieldRef<"GmbIntegration", 'String'>
    readonly user_id: FieldRef<"GmbIntegration", 'String'>
    readonly accessToken: FieldRef<"GmbIntegration", 'String'>
    readonly refreshToken: FieldRef<"GmbIntegration", 'String'>
    readonly tokenExpiry: FieldRef<"GmbIntegration", 'DateTime'>
    readonly accountName: FieldRef<"GmbIntegration", 'String'>
    readonly accountId: FieldRef<"GmbIntegration", 'String'>
    readonly clientId: FieldRef<"GmbIntegration", 'String'>
    readonly isActive: FieldRef<"GmbIntegration", 'Boolean'>
    readonly createdAt: FieldRef<"GmbIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"GmbIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GmbIntegration findUnique
   */
  export type GmbIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which GmbIntegration to fetch.
     */
    where: GmbIntegrationWhereUniqueInput
  }

  /**
   * GmbIntegration findUniqueOrThrow
   */
  export type GmbIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which GmbIntegration to fetch.
     */
    where: GmbIntegrationWhereUniqueInput
  }

  /**
   * GmbIntegration findFirst
   */
  export type GmbIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which GmbIntegration to fetch.
     */
    where?: GmbIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmbIntegrations to fetch.
     */
    orderBy?: GmbIntegrationOrderByWithRelationInput | GmbIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmbIntegrations.
     */
    cursor?: GmbIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmbIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmbIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmbIntegrations.
     */
    distinct?: GmbIntegrationScalarFieldEnum | GmbIntegrationScalarFieldEnum[]
  }

  /**
   * GmbIntegration findFirstOrThrow
   */
  export type GmbIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which GmbIntegration to fetch.
     */
    where?: GmbIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmbIntegrations to fetch.
     */
    orderBy?: GmbIntegrationOrderByWithRelationInput | GmbIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GmbIntegrations.
     */
    cursor?: GmbIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmbIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmbIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GmbIntegrations.
     */
    distinct?: GmbIntegrationScalarFieldEnum | GmbIntegrationScalarFieldEnum[]
  }

  /**
   * GmbIntegration findMany
   */
  export type GmbIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * Filter, which GmbIntegrations to fetch.
     */
    where?: GmbIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GmbIntegrations to fetch.
     */
    orderBy?: GmbIntegrationOrderByWithRelationInput | GmbIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GmbIntegrations.
     */
    cursor?: GmbIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GmbIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GmbIntegrations.
     */
    skip?: number
    distinct?: GmbIntegrationScalarFieldEnum | GmbIntegrationScalarFieldEnum[]
  }

  /**
   * GmbIntegration create
   */
  export type GmbIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to create a GmbIntegration.
     */
    data: XOR<GmbIntegrationCreateInput, GmbIntegrationUncheckedCreateInput>
  }

  /**
   * GmbIntegration createMany
   */
  export type GmbIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GmbIntegrations.
     */
    data: GmbIntegrationCreateManyInput | GmbIntegrationCreateManyInput[]
  }

  /**
   * GmbIntegration update
   */
  export type GmbIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * The data needed to update a GmbIntegration.
     */
    data: XOR<GmbIntegrationUpdateInput, GmbIntegrationUncheckedUpdateInput>
    /**
     * Choose, which GmbIntegration to update.
     */
    where: GmbIntegrationWhereUniqueInput
  }

  /**
   * GmbIntegration updateMany
   */
  export type GmbIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GmbIntegrations.
     */
    data: XOR<GmbIntegrationUpdateManyMutationInput, GmbIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which GmbIntegrations to update
     */
    where?: GmbIntegrationWhereInput
    /**
     * Limit how many GmbIntegrations to update.
     */
    limit?: number
  }

  /**
   * GmbIntegration upsert
   */
  export type GmbIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * The filter to search for the GmbIntegration to update in case it exists.
     */
    where: GmbIntegrationWhereUniqueInput
    /**
     * In case the GmbIntegration found by the `where` argument doesn't exist, create a new GmbIntegration with this data.
     */
    create: XOR<GmbIntegrationCreateInput, GmbIntegrationUncheckedCreateInput>
    /**
     * In case the GmbIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GmbIntegrationUpdateInput, GmbIntegrationUncheckedUpdateInput>
  }

  /**
   * GmbIntegration delete
   */
  export type GmbIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
    /**
     * Filter which GmbIntegration to delete.
     */
    where: GmbIntegrationWhereUniqueInput
  }

  /**
   * GmbIntegration deleteMany
   */
  export type GmbIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GmbIntegrations to delete
     */
    where?: GmbIntegrationWhereInput
    /**
     * Limit how many GmbIntegrations to delete.
     */
    limit?: number
  }

  /**
   * GmbIntegration findRaw
   */
  export type GmbIntegrationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GmbIntegration aggregateRaw
   */
  export type GmbIntegrationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * GmbIntegration without action
   */
  export type GmbIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GmbIntegration
     */
    select?: GmbIntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GmbIntegration
     */
    omit?: GmbIntegrationOmit<ExtArgs> | null
  }


  /**
   * Model CompetitorAnalysis
   */

  export type AggregateCompetitorAnalysis = {
    _count: CompetitorAnalysisCountAggregateOutputType | null
    _min: CompetitorAnalysisMinAggregateOutputType | null
    _max: CompetitorAnalysisMaxAggregateOutputType | null
  }

  export type CompetitorAnalysisMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    businessType: string | null
    lastUpdated: Date | null
    nextUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetitorAnalysisMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    businessType: string | null
    lastUpdated: Date | null
    nextUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompetitorAnalysisCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    businessType: number
    lastUpdated: number
    nextUpdate: number
    competitors: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompetitorAnalysisMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    businessType?: true
    lastUpdated?: true
    nextUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetitorAnalysisMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    businessType?: true
    lastUpdated?: true
    nextUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompetitorAnalysisCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    businessType?: true
    lastUpdated?: true
    nextUpdate?: true
    competitors?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompetitorAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorAnalysis to aggregate.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompetitorAnalyses
    **/
    _count?: true | CompetitorAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompetitorAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompetitorAnalysisMaxAggregateInputType
  }

  export type GetCompetitorAnalysisAggregateType<T extends CompetitorAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateCompetitorAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompetitorAnalysis[P]>
      : GetScalarType<T[P], AggregateCompetitorAnalysis[P]>
  }




  export type CompetitorAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompetitorAnalysisWhereInput
    orderBy?: CompetitorAnalysisOrderByWithAggregationInput | CompetitorAnalysisOrderByWithAggregationInput[]
    by: CompetitorAnalysisScalarFieldEnum[] | CompetitorAnalysisScalarFieldEnum
    having?: CompetitorAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompetitorAnalysisCountAggregateInputType | true
    _min?: CompetitorAnalysisMinAggregateInputType
    _max?: CompetitorAnalysisMaxAggregateInputType
  }

  export type CompetitorAnalysisGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    businessType: string
    lastUpdated: Date
    nextUpdate: Date
    competitors: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CompetitorAnalysisCountAggregateOutputType | null
    _min: CompetitorAnalysisMinAggregateOutputType | null
    _max: CompetitorAnalysisMaxAggregateOutputType | null
  }

  type GetCompetitorAnalysisGroupByPayload<T extends CompetitorAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompetitorAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompetitorAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompetitorAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], CompetitorAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type CompetitorAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    businessType?: boolean
    lastUpdated?: boolean
    nextUpdate?: boolean
    competitors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["competitorAnalysis"]>



  export type CompetitorAnalysisSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    businessType?: boolean
    lastUpdated?: boolean
    nextUpdate?: boolean
    competitors?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompetitorAnalysisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "businessType" | "lastUpdated" | "nextUpdate" | "competitors" | "createdAt" | "updatedAt", ExtArgs["result"]["competitorAnalysis"]>

  export type $CompetitorAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompetitorAnalysis"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      businessType: string
      lastUpdated: Date
      nextUpdate: Date
      competitors: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["competitorAnalysis"]>
    composites: {}
  }

  type CompetitorAnalysisGetPayload<S extends boolean | null | undefined | CompetitorAnalysisDefaultArgs> = $Result.GetResult<Prisma.$CompetitorAnalysisPayload, S>

  type CompetitorAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompetitorAnalysisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompetitorAnalysisCountAggregateInputType | true
    }

  export interface CompetitorAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompetitorAnalysis'], meta: { name: 'CompetitorAnalysis' } }
    /**
     * Find zero or one CompetitorAnalysis that matches the filter.
     * @param {CompetitorAnalysisFindUniqueArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompetitorAnalysisFindUniqueArgs>(args: SelectSubset<T, CompetitorAnalysisFindUniqueArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompetitorAnalysis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompetitorAnalysisFindUniqueOrThrowArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompetitorAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, CompetitorAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompetitorAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisFindFirstArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompetitorAnalysisFindFirstArgs>(args?: SelectSubset<T, CompetitorAnalysisFindFirstArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompetitorAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisFindFirstOrThrowArgs} args - Arguments to find a CompetitorAnalysis
     * @example
     * // Get one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompetitorAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, CompetitorAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompetitorAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompetitorAnalyses
     * const competitorAnalyses = await prisma.competitorAnalysis.findMany()
     * 
     * // Get first 10 CompetitorAnalyses
     * const competitorAnalyses = await prisma.competitorAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const competitorAnalysisWithIdOnly = await prisma.competitorAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompetitorAnalysisFindManyArgs>(args?: SelectSubset<T, CompetitorAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompetitorAnalysis.
     * @param {CompetitorAnalysisCreateArgs} args - Arguments to create a CompetitorAnalysis.
     * @example
     * // Create one CompetitorAnalysis
     * const CompetitorAnalysis = await prisma.competitorAnalysis.create({
     *   data: {
     *     // ... data to create a CompetitorAnalysis
     *   }
     * })
     * 
     */
    create<T extends CompetitorAnalysisCreateArgs>(args: SelectSubset<T, CompetitorAnalysisCreateArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompetitorAnalyses.
     * @param {CompetitorAnalysisCreateManyArgs} args - Arguments to create many CompetitorAnalyses.
     * @example
     * // Create many CompetitorAnalyses
     * const competitorAnalysis = await prisma.competitorAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompetitorAnalysisCreateManyArgs>(args?: SelectSubset<T, CompetitorAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompetitorAnalysis.
     * @param {CompetitorAnalysisDeleteArgs} args - Arguments to delete one CompetitorAnalysis.
     * @example
     * // Delete one CompetitorAnalysis
     * const CompetitorAnalysis = await prisma.competitorAnalysis.delete({
     *   where: {
     *     // ... filter to delete one CompetitorAnalysis
     *   }
     * })
     * 
     */
    delete<T extends CompetitorAnalysisDeleteArgs>(args: SelectSubset<T, CompetitorAnalysisDeleteArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompetitorAnalysis.
     * @param {CompetitorAnalysisUpdateArgs} args - Arguments to update one CompetitorAnalysis.
     * @example
     * // Update one CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompetitorAnalysisUpdateArgs>(args: SelectSubset<T, CompetitorAnalysisUpdateArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompetitorAnalyses.
     * @param {CompetitorAnalysisDeleteManyArgs} args - Arguments to filter CompetitorAnalyses to delete.
     * @example
     * // Delete a few CompetitorAnalyses
     * const { count } = await prisma.competitorAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompetitorAnalysisDeleteManyArgs>(args?: SelectSubset<T, CompetitorAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompetitorAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompetitorAnalyses
     * const competitorAnalysis = await prisma.competitorAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompetitorAnalysisUpdateManyArgs>(args: SelectSubset<T, CompetitorAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompetitorAnalysis.
     * @param {CompetitorAnalysisUpsertArgs} args - Arguments to update or create a CompetitorAnalysis.
     * @example
     * // Update or create a CompetitorAnalysis
     * const competitorAnalysis = await prisma.competitorAnalysis.upsert({
     *   create: {
     *     // ... data to create a CompetitorAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompetitorAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends CompetitorAnalysisUpsertArgs>(args: SelectSubset<T, CompetitorAnalysisUpsertArgs<ExtArgs>>): Prisma__CompetitorAnalysisClient<$Result.GetResult<Prisma.$CompetitorAnalysisPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompetitorAnalyses that matches the filter.
     * @param {CompetitorAnalysisFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const competitorAnalysis = await prisma.competitorAnalysis.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CompetitorAnalysisFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CompetitorAnalysis.
     * @param {CompetitorAnalysisAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const competitorAnalysis = await prisma.competitorAnalysis.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CompetitorAnalysisAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CompetitorAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisCountArgs} args - Arguments to filter CompetitorAnalyses to count.
     * @example
     * // Count the number of CompetitorAnalyses
     * const count = await prisma.competitorAnalysis.count({
     *   where: {
     *     // ... the filter for the CompetitorAnalyses we want to count
     *   }
     * })
    **/
    count<T extends CompetitorAnalysisCountArgs>(
      args?: Subset<T, CompetitorAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompetitorAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompetitorAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompetitorAnalysisAggregateArgs>(args: Subset<T, CompetitorAnalysisAggregateArgs>): Prisma.PrismaPromise<GetCompetitorAnalysisAggregateType<T>>

    /**
     * Group by CompetitorAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompetitorAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompetitorAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompetitorAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: CompetitorAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompetitorAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompetitorAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompetitorAnalysis model
   */
  readonly fields: CompetitorAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompetitorAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompetitorAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompetitorAnalysis model
   */
  interface CompetitorAnalysisFieldRefs {
    readonly id: FieldRef<"CompetitorAnalysis", 'String'>
    readonly userId: FieldRef<"CompetitorAnalysis", 'String'>
    readonly locationId: FieldRef<"CompetitorAnalysis", 'String'>
    readonly businessType: FieldRef<"CompetitorAnalysis", 'String'>
    readonly lastUpdated: FieldRef<"CompetitorAnalysis", 'DateTime'>
    readonly nextUpdate: FieldRef<"CompetitorAnalysis", 'DateTime'>
    readonly competitors: FieldRef<"CompetitorAnalysis", 'Json'>
    readonly createdAt: FieldRef<"CompetitorAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"CompetitorAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompetitorAnalysis findUnique
   */
  export type CompetitorAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis findUniqueOrThrow
   */
  export type CompetitorAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis findFirst
   */
  export type CompetitorAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorAnalyses.
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorAnalyses.
     */
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * CompetitorAnalysis findFirstOrThrow
   */
  export type CompetitorAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalysis to fetch.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompetitorAnalyses.
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompetitorAnalyses.
     */
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * CompetitorAnalysis findMany
   */
  export type CompetitorAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Filter, which CompetitorAnalyses to fetch.
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompetitorAnalyses to fetch.
     */
    orderBy?: CompetitorAnalysisOrderByWithRelationInput | CompetitorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompetitorAnalyses.
     */
    cursor?: CompetitorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompetitorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompetitorAnalyses.
     */
    skip?: number
    distinct?: CompetitorAnalysisScalarFieldEnum | CompetitorAnalysisScalarFieldEnum[]
  }

  /**
   * CompetitorAnalysis create
   */
  export type CompetitorAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * The data needed to create a CompetitorAnalysis.
     */
    data: XOR<CompetitorAnalysisCreateInput, CompetitorAnalysisUncheckedCreateInput>
  }

  /**
   * CompetitorAnalysis createMany
   */
  export type CompetitorAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompetitorAnalyses.
     */
    data: CompetitorAnalysisCreateManyInput | CompetitorAnalysisCreateManyInput[]
  }

  /**
   * CompetitorAnalysis update
   */
  export type CompetitorAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * The data needed to update a CompetitorAnalysis.
     */
    data: XOR<CompetitorAnalysisUpdateInput, CompetitorAnalysisUncheckedUpdateInput>
    /**
     * Choose, which CompetitorAnalysis to update.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis updateMany
   */
  export type CompetitorAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompetitorAnalyses.
     */
    data: XOR<CompetitorAnalysisUpdateManyMutationInput, CompetitorAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which CompetitorAnalyses to update
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * Limit how many CompetitorAnalyses to update.
     */
    limit?: number
  }

  /**
   * CompetitorAnalysis upsert
   */
  export type CompetitorAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * The filter to search for the CompetitorAnalysis to update in case it exists.
     */
    where: CompetitorAnalysisWhereUniqueInput
    /**
     * In case the CompetitorAnalysis found by the `where` argument doesn't exist, create a new CompetitorAnalysis with this data.
     */
    create: XOR<CompetitorAnalysisCreateInput, CompetitorAnalysisUncheckedCreateInput>
    /**
     * In case the CompetitorAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompetitorAnalysisUpdateInput, CompetitorAnalysisUncheckedUpdateInput>
  }

  /**
   * CompetitorAnalysis delete
   */
  export type CompetitorAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
    /**
     * Filter which CompetitorAnalysis to delete.
     */
    where: CompetitorAnalysisWhereUniqueInput
  }

  /**
   * CompetitorAnalysis deleteMany
   */
  export type CompetitorAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompetitorAnalyses to delete
     */
    where?: CompetitorAnalysisWhereInput
    /**
     * Limit how many CompetitorAnalyses to delete.
     */
    limit?: number
  }

  /**
   * CompetitorAnalysis findRaw
   */
  export type CompetitorAnalysisFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CompetitorAnalysis aggregateRaw
   */
  export type CompetitorAnalysisAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CompetitorAnalysis without action
   */
  export type CompetitorAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompetitorAnalysis
     */
    select?: CompetitorAnalysisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompetitorAnalysis
     */
    omit?: CompetitorAnalysisOmit<ExtArgs> | null
  }


  /**
   * Model keywords
   */

  export type AggregateKeywords = {
    _count: KeywordsCountAggregateOutputType | null
    _min: KeywordsMinAggregateOutputType | null
    _max: KeywordsMaxAggregateOutputType | null
  }

  export type KeywordsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    location_id: string | null
    keyword: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type KeywordsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    location_id: string | null
    keyword: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type KeywordsCountAggregateOutputType = {
    id: number
    user_id: number
    location_id: number
    keyword: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type KeywordsMinAggregateInputType = {
    id?: true
    user_id?: true
    location_id?: true
    keyword?: true
    created_at?: true
    updated_at?: true
  }

  export type KeywordsMaxAggregateInputType = {
    id?: true
    user_id?: true
    location_id?: true
    keyword?: true
    created_at?: true
    updated_at?: true
  }

  export type KeywordsCountAggregateInputType = {
    id?: true
    user_id?: true
    location_id?: true
    keyword?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type KeywordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keywords to aggregate.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned keywords
    **/
    _count?: true | KeywordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordsMaxAggregateInputType
  }

  export type GetKeywordsAggregateType<T extends KeywordsAggregateArgs> = {
        [P in keyof T & keyof AggregateKeywords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeywords[P]>
      : GetScalarType<T[P], AggregateKeywords[P]>
  }




  export type keywordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: keywordsWhereInput
    orderBy?: keywordsOrderByWithAggregationInput | keywordsOrderByWithAggregationInput[]
    by: KeywordsScalarFieldEnum[] | KeywordsScalarFieldEnum
    having?: keywordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordsCountAggregateInputType | true
    _min?: KeywordsMinAggregateInputType
    _max?: KeywordsMaxAggregateInputType
  }

  export type KeywordsGroupByOutputType = {
    id: string
    user_id: string
    location_id: string
    keyword: string | null
    created_at: Date
    updated_at: Date | null
    _count: KeywordsCountAggregateOutputType | null
    _min: KeywordsMinAggregateOutputType | null
    _max: KeywordsMaxAggregateOutputType | null
  }

  type GetKeywordsGroupByPayload<T extends keywordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordsGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordsGroupByOutputType[P]>
        }
      >
    >


  export type keywordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    location_id?: boolean
    keyword?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["keywords"]>



  export type keywordsSelectScalar = {
    id?: boolean
    user_id?: boolean
    location_id?: boolean
    keyword?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type keywordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "location_id" | "keyword" | "created_at" | "updated_at", ExtArgs["result"]["keywords"]>

  export type $keywordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "keywords"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      location_id: string
      keyword: string | null
      created_at: Date
      updated_at: Date | null
    }, ExtArgs["result"]["keywords"]>
    composites: {}
  }

  type keywordsGetPayload<S extends boolean | null | undefined | keywordsDefaultArgs> = $Result.GetResult<Prisma.$keywordsPayload, S>

  type keywordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<keywordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordsCountAggregateInputType | true
    }

  export interface keywordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['keywords'], meta: { name: 'keywords' } }
    /**
     * Find zero or one Keywords that matches the filter.
     * @param {keywordsFindUniqueArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends keywordsFindUniqueArgs>(args: SelectSubset<T, keywordsFindUniqueArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Keywords that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {keywordsFindUniqueOrThrowArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends keywordsFindUniqueOrThrowArgs>(args: SelectSubset<T, keywordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsFindFirstArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends keywordsFindFirstArgs>(args?: SelectSubset<T, keywordsFindFirstArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keywords that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsFindFirstOrThrowArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends keywordsFindFirstOrThrowArgs>(args?: SelectSubset<T, keywordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keywords
     * const keywords = await prisma.keywords.findMany()
     * 
     * // Get first 10 Keywords
     * const keywords = await prisma.keywords.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordsWithIdOnly = await prisma.keywords.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends keywordsFindManyArgs>(args?: SelectSubset<T, keywordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Keywords.
     * @param {keywordsCreateArgs} args - Arguments to create a Keywords.
     * @example
     * // Create one Keywords
     * const Keywords = await prisma.keywords.create({
     *   data: {
     *     // ... data to create a Keywords
     *   }
     * })
     * 
     */
    create<T extends keywordsCreateArgs>(args: SelectSubset<T, keywordsCreateArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Keywords.
     * @param {keywordsCreateManyArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keywords = await prisma.keywords.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends keywordsCreateManyArgs>(args?: SelectSubset<T, keywordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Keywords.
     * @param {keywordsDeleteArgs} args - Arguments to delete one Keywords.
     * @example
     * // Delete one Keywords
     * const Keywords = await prisma.keywords.delete({
     *   where: {
     *     // ... filter to delete one Keywords
     *   }
     * })
     * 
     */
    delete<T extends keywordsDeleteArgs>(args: SelectSubset<T, keywordsDeleteArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Keywords.
     * @param {keywordsUpdateArgs} args - Arguments to update one Keywords.
     * @example
     * // Update one Keywords
     * const keywords = await prisma.keywords.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends keywordsUpdateArgs>(args: SelectSubset<T, keywordsUpdateArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Keywords.
     * @param {keywordsDeleteManyArgs} args - Arguments to filter Keywords to delete.
     * @example
     * // Delete a few Keywords
     * const { count } = await prisma.keywords.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends keywordsDeleteManyArgs>(args?: SelectSubset<T, keywordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keywords
     * const keywords = await prisma.keywords.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends keywordsUpdateManyArgs>(args: SelectSubset<T, keywordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Keywords.
     * @param {keywordsUpsertArgs} args - Arguments to update or create a Keywords.
     * @example
     * // Update or create a Keywords
     * const keywords = await prisma.keywords.upsert({
     *   create: {
     *     // ... data to create a Keywords
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keywords we want to update
     *   }
     * })
     */
    upsert<T extends keywordsUpsertArgs>(args: SelectSubset<T, keywordsUpsertArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * @param {keywordsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const keywords = await prisma.keywords.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: keywordsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Keywords.
     * @param {keywordsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const keywords = await prisma.keywords.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: keywordsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsCountArgs} args - Arguments to filter Keywords to count.
     * @example
     * // Count the number of Keywords
     * const count = await prisma.keywords.count({
     *   where: {
     *     // ... the filter for the Keywords we want to count
     *   }
     * })
    **/
    count<T extends keywordsCountArgs>(
      args?: Subset<T, keywordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordsAggregateArgs>(args: Subset<T, KeywordsAggregateArgs>): Prisma.PrismaPromise<GetKeywordsAggregateType<T>>

    /**
     * Group by Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends keywordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: keywordsGroupByArgs['orderBy'] }
        : { orderBy?: keywordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, keywordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the keywords model
   */
  readonly fields: keywordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for keywords.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__keywordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the keywords model
   */
  interface keywordsFieldRefs {
    readonly id: FieldRef<"keywords", 'String'>
    readonly user_id: FieldRef<"keywords", 'String'>
    readonly location_id: FieldRef<"keywords", 'String'>
    readonly keyword: FieldRef<"keywords", 'String'>
    readonly created_at: FieldRef<"keywords", 'DateTime'>
    readonly updated_at: FieldRef<"keywords", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * keywords findUnique
   */
  export type keywordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords findUniqueOrThrow
   */
  export type keywordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords findFirst
   */
  export type keywordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keywords.
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keywords.
     */
    distinct?: KeywordsScalarFieldEnum | KeywordsScalarFieldEnum[]
  }

  /**
   * keywords findFirstOrThrow
   */
  export type keywordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keywords.
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keywords.
     */
    distinct?: KeywordsScalarFieldEnum | KeywordsScalarFieldEnum[]
  }

  /**
   * keywords findMany
   */
  export type keywordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing keywords.
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    distinct?: KeywordsScalarFieldEnum | KeywordsScalarFieldEnum[]
  }

  /**
   * keywords create
   */
  export type keywordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * The data needed to create a keywords.
     */
    data: XOR<keywordsCreateInput, keywordsUncheckedCreateInput>
  }

  /**
   * keywords createMany
   */
  export type keywordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many keywords.
     */
    data: keywordsCreateManyInput | keywordsCreateManyInput[]
  }

  /**
   * keywords update
   */
  export type keywordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * The data needed to update a keywords.
     */
    data: XOR<keywordsUpdateInput, keywordsUncheckedUpdateInput>
    /**
     * Choose, which keywords to update.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords updateMany
   */
  export type keywordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update keywords.
     */
    data: XOR<keywordsUpdateManyMutationInput, keywordsUncheckedUpdateManyInput>
    /**
     * Filter which keywords to update
     */
    where?: keywordsWhereInput
    /**
     * Limit how many keywords to update.
     */
    limit?: number
  }

  /**
   * keywords upsert
   */
  export type keywordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * The filter to search for the keywords to update in case it exists.
     */
    where: keywordsWhereUniqueInput
    /**
     * In case the keywords found by the `where` argument doesn't exist, create a new keywords with this data.
     */
    create: XOR<keywordsCreateInput, keywordsUncheckedCreateInput>
    /**
     * In case the keywords was found with the provided `where` argument, update it with this data.
     */
    update: XOR<keywordsUpdateInput, keywordsUncheckedUpdateInput>
  }

  /**
   * keywords delete
   */
  export type keywordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Filter which keywords to delete.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords deleteMany
   */
  export type keywordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keywords to delete
     */
    where?: keywordsWhereInput
    /**
     * Limit how many keywords to delete.
     */
    limit?: number
  }

  /**
   * keywords findRaw
   */
  export type keywordsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * keywords aggregateRaw
   */
  export type keywordsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * keywords without action
   */
  export type keywordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
  }


  /**
   * Model KeywordRank
   */

  export type AggregateKeywordRank = {
    _count: KeywordRankCountAggregateOutputType | null
    _avg: KeywordRankAvgAggregateOutputType | null
    _sum: KeywordRankSumAggregateOutputType | null
    _min: KeywordRankMinAggregateOutputType | null
    _max: KeywordRankMaxAggregateOutputType | null
  }

  export type KeywordRankAvgAggregateOutputType = {
    rank: number | null
    previousRank: number | null
    rankChangeValue: number | null
    totalResults: number | null
    searchTime: number | null
  }

  export type KeywordRankSumAggregateOutputType = {
    rank: number | null
    previousRank: number | null
    rankChangeValue: number | null
    totalResults: bigint | null
    searchTime: number | null
  }

  export type KeywordRankMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    location: string | null
    locationId: string | null
    userId: string | null
    targetDomain: string | null
    rank: number | null
    previousRank: number | null
    rankChange: $Enums.RankChangeType | null
    rankChangeValue: number | null
    url: string | null
    title: string | null
    snippet: string | null
    searchResults: string | null
    totalResults: bigint | null
    searchTime: number | null
    batchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordRankMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    location: string | null
    locationId: string | null
    userId: string | null
    targetDomain: string | null
    rank: number | null
    previousRank: number | null
    rankChange: $Enums.RankChangeType | null
    rankChangeValue: number | null
    url: string | null
    title: string | null
    snippet: string | null
    searchResults: string | null
    totalResults: bigint | null
    searchTime: number | null
    batchId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordRankCountAggregateOutputType = {
    id: number
    keyword: number
    location: number
    locationId: number
    userId: number
    targetDomain: number
    rank: number
    previousRank: number
    rankChange: number
    rankChangeValue: number
    url: number
    title: number
    snippet: number
    searchResults: number
    totalResults: number
    searchTime: number
    batchId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeywordRankAvgAggregateInputType = {
    rank?: true
    previousRank?: true
    rankChangeValue?: true
    totalResults?: true
    searchTime?: true
  }

  export type KeywordRankSumAggregateInputType = {
    rank?: true
    previousRank?: true
    rankChangeValue?: true
    totalResults?: true
    searchTime?: true
  }

  export type KeywordRankMinAggregateInputType = {
    id?: true
    keyword?: true
    location?: true
    locationId?: true
    userId?: true
    targetDomain?: true
    rank?: true
    previousRank?: true
    rankChange?: true
    rankChangeValue?: true
    url?: true
    title?: true
    snippet?: true
    searchResults?: true
    totalResults?: true
    searchTime?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordRankMaxAggregateInputType = {
    id?: true
    keyword?: true
    location?: true
    locationId?: true
    userId?: true
    targetDomain?: true
    rank?: true
    previousRank?: true
    rankChange?: true
    rankChangeValue?: true
    url?: true
    title?: true
    snippet?: true
    searchResults?: true
    totalResults?: true
    searchTime?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordRankCountAggregateInputType = {
    id?: true
    keyword?: true
    location?: true
    locationId?: true
    userId?: true
    targetDomain?: true
    rank?: true
    previousRank?: true
    rankChange?: true
    rankChangeValue?: true
    url?: true
    title?: true
    snippet?: true
    searchResults?: true
    totalResults?: true
    searchTime?: true
    batchId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeywordRankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeywordRank to aggregate.
     */
    where?: KeywordRankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordRanks to fetch.
     */
    orderBy?: KeywordRankOrderByWithRelationInput | KeywordRankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordRankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeywordRanks
    **/
    _count?: true | KeywordRankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KeywordRankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KeywordRankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordRankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordRankMaxAggregateInputType
  }

  export type GetKeywordRankAggregateType<T extends KeywordRankAggregateArgs> = {
        [P in keyof T & keyof AggregateKeywordRank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeywordRank[P]>
      : GetScalarType<T[P], AggregateKeywordRank[P]>
  }




  export type KeywordRankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordRankWhereInput
    orderBy?: KeywordRankOrderByWithAggregationInput | KeywordRankOrderByWithAggregationInput[]
    by: KeywordRankScalarFieldEnum[] | KeywordRankScalarFieldEnum
    having?: KeywordRankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordRankCountAggregateInputType | true
    _avg?: KeywordRankAvgAggregateInputType
    _sum?: KeywordRankSumAggregateInputType
    _min?: KeywordRankMinAggregateInputType
    _max?: KeywordRankMaxAggregateInputType
  }

  export type KeywordRankGroupByOutputType = {
    id: string
    keyword: string
    location: string
    locationId: string
    userId: string
    targetDomain: string | null
    rank: number | null
    previousRank: number | null
    rankChange: $Enums.RankChangeType
    rankChangeValue: number
    url: string | null
    title: string | null
    snippet: string | null
    searchResults: string | null
    totalResults: bigint
    searchTime: number
    batchId: string | null
    createdAt: Date
    updatedAt: Date
    _count: KeywordRankCountAggregateOutputType | null
    _avg: KeywordRankAvgAggregateOutputType | null
    _sum: KeywordRankSumAggregateOutputType | null
    _min: KeywordRankMinAggregateOutputType | null
    _max: KeywordRankMaxAggregateOutputType | null
  }

  type GetKeywordRankGroupByPayload<T extends KeywordRankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordRankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordRankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordRankGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordRankGroupByOutputType[P]>
        }
      >
    >


  export type KeywordRankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    location?: boolean
    locationId?: boolean
    userId?: boolean
    targetDomain?: boolean
    rank?: boolean
    previousRank?: boolean
    rankChange?: boolean
    rankChangeValue?: boolean
    url?: boolean
    title?: boolean
    snippet?: boolean
    searchResults?: boolean
    totalResults?: boolean
    searchTime?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["keywordRank"]>



  export type KeywordRankSelectScalar = {
    id?: boolean
    keyword?: boolean
    location?: boolean
    locationId?: boolean
    userId?: boolean
    targetDomain?: boolean
    rank?: boolean
    previousRank?: boolean
    rankChange?: boolean
    rankChangeValue?: boolean
    url?: boolean
    title?: boolean
    snippet?: boolean
    searchResults?: boolean
    totalResults?: boolean
    searchTime?: boolean
    batchId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeywordRankOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "location" | "locationId" | "userId" | "targetDomain" | "rank" | "previousRank" | "rankChange" | "rankChangeValue" | "url" | "title" | "snippet" | "searchResults" | "totalResults" | "searchTime" | "batchId" | "createdAt" | "updatedAt", ExtArgs["result"]["keywordRank"]>

  export type $KeywordRankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeywordRank"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      location: string
      locationId: string
      userId: string
      targetDomain: string | null
      rank: number | null
      previousRank: number | null
      rankChange: $Enums.RankChangeType
      rankChangeValue: number
      url: string | null
      title: string | null
      snippet: string | null
      searchResults: string | null
      totalResults: bigint
      searchTime: number
      batchId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keywordRank"]>
    composites: {}
  }

  type KeywordRankGetPayload<S extends boolean | null | undefined | KeywordRankDefaultArgs> = $Result.GetResult<Prisma.$KeywordRankPayload, S>

  type KeywordRankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordRankFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordRankCountAggregateInputType | true
    }

  export interface KeywordRankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeywordRank'], meta: { name: 'KeywordRank' } }
    /**
     * Find zero or one KeywordRank that matches the filter.
     * @param {KeywordRankFindUniqueArgs} args - Arguments to find a KeywordRank
     * @example
     * // Get one KeywordRank
     * const keywordRank = await prisma.keywordRank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordRankFindUniqueArgs>(args: SelectSubset<T, KeywordRankFindUniqueArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeywordRank that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordRankFindUniqueOrThrowArgs} args - Arguments to find a KeywordRank
     * @example
     * // Get one KeywordRank
     * const keywordRank = await prisma.keywordRank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordRankFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordRankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeywordRank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankFindFirstArgs} args - Arguments to find a KeywordRank
     * @example
     * // Get one KeywordRank
     * const keywordRank = await prisma.keywordRank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordRankFindFirstArgs>(args?: SelectSubset<T, KeywordRankFindFirstArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeywordRank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankFindFirstOrThrowArgs} args - Arguments to find a KeywordRank
     * @example
     * // Get one KeywordRank
     * const keywordRank = await prisma.keywordRank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordRankFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordRankFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeywordRanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeywordRanks
     * const keywordRanks = await prisma.keywordRank.findMany()
     * 
     * // Get first 10 KeywordRanks
     * const keywordRanks = await prisma.keywordRank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordRankWithIdOnly = await prisma.keywordRank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordRankFindManyArgs>(args?: SelectSubset<T, KeywordRankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeywordRank.
     * @param {KeywordRankCreateArgs} args - Arguments to create a KeywordRank.
     * @example
     * // Create one KeywordRank
     * const KeywordRank = await prisma.keywordRank.create({
     *   data: {
     *     // ... data to create a KeywordRank
     *   }
     * })
     * 
     */
    create<T extends KeywordRankCreateArgs>(args: SelectSubset<T, KeywordRankCreateArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeywordRanks.
     * @param {KeywordRankCreateManyArgs} args - Arguments to create many KeywordRanks.
     * @example
     * // Create many KeywordRanks
     * const keywordRank = await prisma.keywordRank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordRankCreateManyArgs>(args?: SelectSubset<T, KeywordRankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KeywordRank.
     * @param {KeywordRankDeleteArgs} args - Arguments to delete one KeywordRank.
     * @example
     * // Delete one KeywordRank
     * const KeywordRank = await prisma.keywordRank.delete({
     *   where: {
     *     // ... filter to delete one KeywordRank
     *   }
     * })
     * 
     */
    delete<T extends KeywordRankDeleteArgs>(args: SelectSubset<T, KeywordRankDeleteArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeywordRank.
     * @param {KeywordRankUpdateArgs} args - Arguments to update one KeywordRank.
     * @example
     * // Update one KeywordRank
     * const keywordRank = await prisma.keywordRank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordRankUpdateArgs>(args: SelectSubset<T, KeywordRankUpdateArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeywordRanks.
     * @param {KeywordRankDeleteManyArgs} args - Arguments to filter KeywordRanks to delete.
     * @example
     * // Delete a few KeywordRanks
     * const { count } = await prisma.keywordRank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordRankDeleteManyArgs>(args?: SelectSubset<T, KeywordRankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeywordRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeywordRanks
     * const keywordRank = await prisma.keywordRank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordRankUpdateManyArgs>(args: SelectSubset<T, KeywordRankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KeywordRank.
     * @param {KeywordRankUpsertArgs} args - Arguments to update or create a KeywordRank.
     * @example
     * // Update or create a KeywordRank
     * const keywordRank = await prisma.keywordRank.upsert({
     *   create: {
     *     // ... data to create a KeywordRank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeywordRank we want to update
     *   }
     * })
     */
    upsert<T extends KeywordRankUpsertArgs>(args: SelectSubset<T, KeywordRankUpsertArgs<ExtArgs>>): Prisma__KeywordRankClient<$Result.GetResult<Prisma.$KeywordRankPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeywordRanks that matches the filter.
     * @param {KeywordRankFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const keywordRank = await prisma.keywordRank.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: KeywordRankFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a KeywordRank.
     * @param {KeywordRankAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const keywordRank = await prisma.keywordRank.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: KeywordRankAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of KeywordRanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankCountArgs} args - Arguments to filter KeywordRanks to count.
     * @example
     * // Count the number of KeywordRanks
     * const count = await prisma.keywordRank.count({
     *   where: {
     *     // ... the filter for the KeywordRanks we want to count
     *   }
     * })
    **/
    count<T extends KeywordRankCountArgs>(
      args?: Subset<T, KeywordRankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordRankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeywordRank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordRankAggregateArgs>(args: Subset<T, KeywordRankAggregateArgs>): Prisma.PrismaPromise<GetKeywordRankAggregateType<T>>

    /**
     * Group by KeywordRank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordRankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordRankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordRankGroupByArgs['orderBy'] }
        : { orderBy?: KeywordRankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordRankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordRankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeywordRank model
   */
  readonly fields: KeywordRankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeywordRank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordRankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeywordRank model
   */
  interface KeywordRankFieldRefs {
    readonly id: FieldRef<"KeywordRank", 'String'>
    readonly keyword: FieldRef<"KeywordRank", 'String'>
    readonly location: FieldRef<"KeywordRank", 'String'>
    readonly locationId: FieldRef<"KeywordRank", 'String'>
    readonly userId: FieldRef<"KeywordRank", 'String'>
    readonly targetDomain: FieldRef<"KeywordRank", 'String'>
    readonly rank: FieldRef<"KeywordRank", 'Int'>
    readonly previousRank: FieldRef<"KeywordRank", 'Int'>
    readonly rankChange: FieldRef<"KeywordRank", 'RankChangeType'>
    readonly rankChangeValue: FieldRef<"KeywordRank", 'Int'>
    readonly url: FieldRef<"KeywordRank", 'String'>
    readonly title: FieldRef<"KeywordRank", 'String'>
    readonly snippet: FieldRef<"KeywordRank", 'String'>
    readonly searchResults: FieldRef<"KeywordRank", 'String'>
    readonly totalResults: FieldRef<"KeywordRank", 'BigInt'>
    readonly searchTime: FieldRef<"KeywordRank", 'Float'>
    readonly batchId: FieldRef<"KeywordRank", 'String'>
    readonly createdAt: FieldRef<"KeywordRank", 'DateTime'>
    readonly updatedAt: FieldRef<"KeywordRank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeywordRank findUnique
   */
  export type KeywordRankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * Filter, which KeywordRank to fetch.
     */
    where: KeywordRankWhereUniqueInput
  }

  /**
   * KeywordRank findUniqueOrThrow
   */
  export type KeywordRankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * Filter, which KeywordRank to fetch.
     */
    where: KeywordRankWhereUniqueInput
  }

  /**
   * KeywordRank findFirst
   */
  export type KeywordRankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * Filter, which KeywordRank to fetch.
     */
    where?: KeywordRankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordRanks to fetch.
     */
    orderBy?: KeywordRankOrderByWithRelationInput | KeywordRankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeywordRanks.
     */
    cursor?: KeywordRankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeywordRanks.
     */
    distinct?: KeywordRankScalarFieldEnum | KeywordRankScalarFieldEnum[]
  }

  /**
   * KeywordRank findFirstOrThrow
   */
  export type KeywordRankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * Filter, which KeywordRank to fetch.
     */
    where?: KeywordRankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordRanks to fetch.
     */
    orderBy?: KeywordRankOrderByWithRelationInput | KeywordRankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeywordRanks.
     */
    cursor?: KeywordRankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordRanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeywordRanks.
     */
    distinct?: KeywordRankScalarFieldEnum | KeywordRankScalarFieldEnum[]
  }

  /**
   * KeywordRank findMany
   */
  export type KeywordRankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * Filter, which KeywordRanks to fetch.
     */
    where?: KeywordRankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordRanks to fetch.
     */
    orderBy?: KeywordRankOrderByWithRelationInput | KeywordRankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeywordRanks.
     */
    cursor?: KeywordRankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordRanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordRanks.
     */
    skip?: number
    distinct?: KeywordRankScalarFieldEnum | KeywordRankScalarFieldEnum[]
  }

  /**
   * KeywordRank create
   */
  export type KeywordRankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * The data needed to create a KeywordRank.
     */
    data: XOR<KeywordRankCreateInput, KeywordRankUncheckedCreateInput>
  }

  /**
   * KeywordRank createMany
   */
  export type KeywordRankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeywordRanks.
     */
    data: KeywordRankCreateManyInput | KeywordRankCreateManyInput[]
  }

  /**
   * KeywordRank update
   */
  export type KeywordRankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * The data needed to update a KeywordRank.
     */
    data: XOR<KeywordRankUpdateInput, KeywordRankUncheckedUpdateInput>
    /**
     * Choose, which KeywordRank to update.
     */
    where: KeywordRankWhereUniqueInput
  }

  /**
   * KeywordRank updateMany
   */
  export type KeywordRankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeywordRanks.
     */
    data: XOR<KeywordRankUpdateManyMutationInput, KeywordRankUncheckedUpdateManyInput>
    /**
     * Filter which KeywordRanks to update
     */
    where?: KeywordRankWhereInput
    /**
     * Limit how many KeywordRanks to update.
     */
    limit?: number
  }

  /**
   * KeywordRank upsert
   */
  export type KeywordRankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * The filter to search for the KeywordRank to update in case it exists.
     */
    where: KeywordRankWhereUniqueInput
    /**
     * In case the KeywordRank found by the `where` argument doesn't exist, create a new KeywordRank with this data.
     */
    create: XOR<KeywordRankCreateInput, KeywordRankUncheckedCreateInput>
    /**
     * In case the KeywordRank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordRankUpdateInput, KeywordRankUncheckedUpdateInput>
  }

  /**
   * KeywordRank delete
   */
  export type KeywordRankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
    /**
     * Filter which KeywordRank to delete.
     */
    where: KeywordRankWhereUniqueInput
  }

  /**
   * KeywordRank deleteMany
   */
  export type KeywordRankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeywordRanks to delete
     */
    where?: KeywordRankWhereInput
    /**
     * Limit how many KeywordRanks to delete.
     */
    limit?: number
  }

  /**
   * KeywordRank findRaw
   */
  export type KeywordRankFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * KeywordRank aggregateRaw
   */
  export type KeywordRankAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * KeywordRank without action
   */
  export type KeywordRankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordRank
     */
    select?: KeywordRankSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordRank
     */
    omit?: KeywordRankOmit<ExtArgs> | null
  }


  /**
   * Model KeywordTracking
   */

  export type AggregateKeywordTracking = {
    _count: KeywordTrackingCountAggregateOutputType | null
    _avg: KeywordTrackingAvgAggregateOutputType | null
    _sum: KeywordTrackingSumAggregateOutputType | null
    _min: KeywordTrackingMinAggregateOutputType | null
    _max: KeywordTrackingMaxAggregateOutputType | null
  }

  export type KeywordTrackingAvgAggregateOutputType = {
    refreshRate: number | null
  }

  export type KeywordTrackingSumAggregateOutputType = {
    refreshRate: number | null
  }

  export type KeywordTrackingMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    locationId: string | null
    location: string | null
    userId: string | null
    targetDomain: string | null
    isActive: boolean | null
    refreshRate: number | null
    lastChecked: Date | null
    nextBatchUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordTrackingMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    locationId: string | null
    location: string | null
    userId: string | null
    targetDomain: string | null
    isActive: boolean | null
    refreshRate: number | null
    lastChecked: Date | null
    nextBatchUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordTrackingCountAggregateOutputType = {
    id: number
    keyword: number
    locationId: number
    location: number
    userId: number
    targetDomain: number
    isActive: number
    refreshRate: number
    lastChecked: number
    nextBatchUpdate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeywordTrackingAvgAggregateInputType = {
    refreshRate?: true
  }

  export type KeywordTrackingSumAggregateInputType = {
    refreshRate?: true
  }

  export type KeywordTrackingMinAggregateInputType = {
    id?: true
    keyword?: true
    locationId?: true
    location?: true
    userId?: true
    targetDomain?: true
    isActive?: true
    refreshRate?: true
    lastChecked?: true
    nextBatchUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordTrackingMaxAggregateInputType = {
    id?: true
    keyword?: true
    locationId?: true
    location?: true
    userId?: true
    targetDomain?: true
    isActive?: true
    refreshRate?: true
    lastChecked?: true
    nextBatchUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordTrackingCountAggregateInputType = {
    id?: true
    keyword?: true
    locationId?: true
    location?: true
    userId?: true
    targetDomain?: true
    isActive?: true
    refreshRate?: true
    lastChecked?: true
    nextBatchUpdate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeywordTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeywordTracking to aggregate.
     */
    where?: KeywordTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordTrackings to fetch.
     */
    orderBy?: KeywordTrackingOrderByWithRelationInput | KeywordTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeywordTrackings
    **/
    _count?: true | KeywordTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KeywordTrackingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KeywordTrackingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordTrackingMaxAggregateInputType
  }

  export type GetKeywordTrackingAggregateType<T extends KeywordTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateKeywordTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeywordTracking[P]>
      : GetScalarType<T[P], AggregateKeywordTracking[P]>
  }




  export type KeywordTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordTrackingWhereInput
    orderBy?: KeywordTrackingOrderByWithAggregationInput | KeywordTrackingOrderByWithAggregationInput[]
    by: KeywordTrackingScalarFieldEnum[] | KeywordTrackingScalarFieldEnum
    having?: KeywordTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordTrackingCountAggregateInputType | true
    _avg?: KeywordTrackingAvgAggregateInputType
    _sum?: KeywordTrackingSumAggregateInputType
    _min?: KeywordTrackingMinAggregateInputType
    _max?: KeywordTrackingMaxAggregateInputType
  }

  export type KeywordTrackingGroupByOutputType = {
    id: string
    keyword: string
    locationId: string
    location: string
    userId: string
    targetDomain: string | null
    isActive: boolean
    refreshRate: number
    lastChecked: Date | null
    nextBatchUpdate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: KeywordTrackingCountAggregateOutputType | null
    _avg: KeywordTrackingAvgAggregateOutputType | null
    _sum: KeywordTrackingSumAggregateOutputType | null
    _min: KeywordTrackingMinAggregateOutputType | null
    _max: KeywordTrackingMaxAggregateOutputType | null
  }

  type GetKeywordTrackingGroupByPayload<T extends KeywordTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordTrackingGroupByOutputType[P]>
        }
      >
    >


  export type KeywordTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    locationId?: boolean
    location?: boolean
    userId?: boolean
    targetDomain?: boolean
    isActive?: boolean
    refreshRate?: boolean
    lastChecked?: boolean
    nextBatchUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["keywordTracking"]>



  export type KeywordTrackingSelectScalar = {
    id?: boolean
    keyword?: boolean
    locationId?: boolean
    location?: boolean
    userId?: boolean
    targetDomain?: boolean
    isActive?: boolean
    refreshRate?: boolean
    lastChecked?: boolean
    nextBatchUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeywordTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "locationId" | "location" | "userId" | "targetDomain" | "isActive" | "refreshRate" | "lastChecked" | "nextBatchUpdate" | "createdAt" | "updatedAt", ExtArgs["result"]["keywordTracking"]>

  export type $KeywordTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KeywordTracking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      locationId: string
      location: string
      userId: string
      targetDomain: string | null
      isActive: boolean
      refreshRate: number
      lastChecked: Date | null
      nextBatchUpdate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keywordTracking"]>
    composites: {}
  }

  type KeywordTrackingGetPayload<S extends boolean | null | undefined | KeywordTrackingDefaultArgs> = $Result.GetResult<Prisma.$KeywordTrackingPayload, S>

  type KeywordTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordTrackingCountAggregateInputType | true
    }

  export interface KeywordTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeywordTracking'], meta: { name: 'KeywordTracking' } }
    /**
     * Find zero or one KeywordTracking that matches the filter.
     * @param {KeywordTrackingFindUniqueArgs} args - Arguments to find a KeywordTracking
     * @example
     * // Get one KeywordTracking
     * const keywordTracking = await prisma.keywordTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordTrackingFindUniqueArgs>(args: SelectSubset<T, KeywordTrackingFindUniqueArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KeywordTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordTrackingFindUniqueOrThrowArgs} args - Arguments to find a KeywordTracking
     * @example
     * // Get one KeywordTracking
     * const keywordTracking = await prisma.keywordTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeywordTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingFindFirstArgs} args - Arguments to find a KeywordTracking
     * @example
     * // Get one KeywordTracking
     * const keywordTracking = await prisma.keywordTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordTrackingFindFirstArgs>(args?: SelectSubset<T, KeywordTrackingFindFirstArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KeywordTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingFindFirstOrThrowArgs} args - Arguments to find a KeywordTracking
     * @example
     * // Get one KeywordTracking
     * const keywordTracking = await prisma.keywordTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeywordTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeywordTrackings
     * const keywordTrackings = await prisma.keywordTracking.findMany()
     * 
     * // Get first 10 KeywordTrackings
     * const keywordTrackings = await prisma.keywordTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordTrackingWithIdOnly = await prisma.keywordTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordTrackingFindManyArgs>(args?: SelectSubset<T, KeywordTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KeywordTracking.
     * @param {KeywordTrackingCreateArgs} args - Arguments to create a KeywordTracking.
     * @example
     * // Create one KeywordTracking
     * const KeywordTracking = await prisma.keywordTracking.create({
     *   data: {
     *     // ... data to create a KeywordTracking
     *   }
     * })
     * 
     */
    create<T extends KeywordTrackingCreateArgs>(args: SelectSubset<T, KeywordTrackingCreateArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KeywordTrackings.
     * @param {KeywordTrackingCreateManyArgs} args - Arguments to create many KeywordTrackings.
     * @example
     * // Create many KeywordTrackings
     * const keywordTracking = await prisma.keywordTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordTrackingCreateManyArgs>(args?: SelectSubset<T, KeywordTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KeywordTracking.
     * @param {KeywordTrackingDeleteArgs} args - Arguments to delete one KeywordTracking.
     * @example
     * // Delete one KeywordTracking
     * const KeywordTracking = await prisma.keywordTracking.delete({
     *   where: {
     *     // ... filter to delete one KeywordTracking
     *   }
     * })
     * 
     */
    delete<T extends KeywordTrackingDeleteArgs>(args: SelectSubset<T, KeywordTrackingDeleteArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KeywordTracking.
     * @param {KeywordTrackingUpdateArgs} args - Arguments to update one KeywordTracking.
     * @example
     * // Update one KeywordTracking
     * const keywordTracking = await prisma.keywordTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordTrackingUpdateArgs>(args: SelectSubset<T, KeywordTrackingUpdateArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KeywordTrackings.
     * @param {KeywordTrackingDeleteManyArgs} args - Arguments to filter KeywordTrackings to delete.
     * @example
     * // Delete a few KeywordTrackings
     * const { count } = await prisma.keywordTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordTrackingDeleteManyArgs>(args?: SelectSubset<T, KeywordTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeywordTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeywordTrackings
     * const keywordTracking = await prisma.keywordTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordTrackingUpdateManyArgs>(args: SelectSubset<T, KeywordTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KeywordTracking.
     * @param {KeywordTrackingUpsertArgs} args - Arguments to update or create a KeywordTracking.
     * @example
     * // Update or create a KeywordTracking
     * const keywordTracking = await prisma.keywordTracking.upsert({
     *   create: {
     *     // ... data to create a KeywordTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeywordTracking we want to update
     *   }
     * })
     */
    upsert<T extends KeywordTrackingUpsertArgs>(args: SelectSubset<T, KeywordTrackingUpsertArgs<ExtArgs>>): Prisma__KeywordTrackingClient<$Result.GetResult<Prisma.$KeywordTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KeywordTrackings that matches the filter.
     * @param {KeywordTrackingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const keywordTracking = await prisma.keywordTracking.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: KeywordTrackingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a KeywordTracking.
     * @param {KeywordTrackingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const keywordTracking = await prisma.keywordTracking.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: KeywordTrackingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of KeywordTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingCountArgs} args - Arguments to filter KeywordTrackings to count.
     * @example
     * // Count the number of KeywordTrackings
     * const count = await prisma.keywordTracking.count({
     *   where: {
     *     // ... the filter for the KeywordTrackings we want to count
     *   }
     * })
    **/
    count<T extends KeywordTrackingCountArgs>(
      args?: Subset<T, KeywordTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeywordTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordTrackingAggregateArgs>(args: Subset<T, KeywordTrackingAggregateArgs>): Prisma.PrismaPromise<GetKeywordTrackingAggregateType<T>>

    /**
     * Group by KeywordTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordTrackingGroupByArgs['orderBy'] }
        : { orderBy?: KeywordTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeywordTracking model
   */
  readonly fields: KeywordTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeywordTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KeywordTracking model
   */
  interface KeywordTrackingFieldRefs {
    readonly id: FieldRef<"KeywordTracking", 'String'>
    readonly keyword: FieldRef<"KeywordTracking", 'String'>
    readonly locationId: FieldRef<"KeywordTracking", 'String'>
    readonly location: FieldRef<"KeywordTracking", 'String'>
    readonly userId: FieldRef<"KeywordTracking", 'String'>
    readonly targetDomain: FieldRef<"KeywordTracking", 'String'>
    readonly isActive: FieldRef<"KeywordTracking", 'Boolean'>
    readonly refreshRate: FieldRef<"KeywordTracking", 'Int'>
    readonly lastChecked: FieldRef<"KeywordTracking", 'DateTime'>
    readonly nextBatchUpdate: FieldRef<"KeywordTracking", 'DateTime'>
    readonly createdAt: FieldRef<"KeywordTracking", 'DateTime'>
    readonly updatedAt: FieldRef<"KeywordTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KeywordTracking findUnique
   */
  export type KeywordTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * Filter, which KeywordTracking to fetch.
     */
    where: KeywordTrackingWhereUniqueInput
  }

  /**
   * KeywordTracking findUniqueOrThrow
   */
  export type KeywordTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * Filter, which KeywordTracking to fetch.
     */
    where: KeywordTrackingWhereUniqueInput
  }

  /**
   * KeywordTracking findFirst
   */
  export type KeywordTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * Filter, which KeywordTracking to fetch.
     */
    where?: KeywordTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordTrackings to fetch.
     */
    orderBy?: KeywordTrackingOrderByWithRelationInput | KeywordTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeywordTrackings.
     */
    cursor?: KeywordTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeywordTrackings.
     */
    distinct?: KeywordTrackingScalarFieldEnum | KeywordTrackingScalarFieldEnum[]
  }

  /**
   * KeywordTracking findFirstOrThrow
   */
  export type KeywordTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * Filter, which KeywordTracking to fetch.
     */
    where?: KeywordTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordTrackings to fetch.
     */
    orderBy?: KeywordTrackingOrderByWithRelationInput | KeywordTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeywordTrackings.
     */
    cursor?: KeywordTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeywordTrackings.
     */
    distinct?: KeywordTrackingScalarFieldEnum | KeywordTrackingScalarFieldEnum[]
  }

  /**
   * KeywordTracking findMany
   */
  export type KeywordTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * Filter, which KeywordTrackings to fetch.
     */
    where?: KeywordTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeywordTrackings to fetch.
     */
    orderBy?: KeywordTrackingOrderByWithRelationInput | KeywordTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeywordTrackings.
     */
    cursor?: KeywordTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeywordTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeywordTrackings.
     */
    skip?: number
    distinct?: KeywordTrackingScalarFieldEnum | KeywordTrackingScalarFieldEnum[]
  }

  /**
   * KeywordTracking create
   */
  export type KeywordTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * The data needed to create a KeywordTracking.
     */
    data: XOR<KeywordTrackingCreateInput, KeywordTrackingUncheckedCreateInput>
  }

  /**
   * KeywordTracking createMany
   */
  export type KeywordTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeywordTrackings.
     */
    data: KeywordTrackingCreateManyInput | KeywordTrackingCreateManyInput[]
  }

  /**
   * KeywordTracking update
   */
  export type KeywordTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * The data needed to update a KeywordTracking.
     */
    data: XOR<KeywordTrackingUpdateInput, KeywordTrackingUncheckedUpdateInput>
    /**
     * Choose, which KeywordTracking to update.
     */
    where: KeywordTrackingWhereUniqueInput
  }

  /**
   * KeywordTracking updateMany
   */
  export type KeywordTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeywordTrackings.
     */
    data: XOR<KeywordTrackingUpdateManyMutationInput, KeywordTrackingUncheckedUpdateManyInput>
    /**
     * Filter which KeywordTrackings to update
     */
    where?: KeywordTrackingWhereInput
    /**
     * Limit how many KeywordTrackings to update.
     */
    limit?: number
  }

  /**
   * KeywordTracking upsert
   */
  export type KeywordTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * The filter to search for the KeywordTracking to update in case it exists.
     */
    where: KeywordTrackingWhereUniqueInput
    /**
     * In case the KeywordTracking found by the `where` argument doesn't exist, create a new KeywordTracking with this data.
     */
    create: XOR<KeywordTrackingCreateInput, KeywordTrackingUncheckedCreateInput>
    /**
     * In case the KeywordTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordTrackingUpdateInput, KeywordTrackingUncheckedUpdateInput>
  }

  /**
   * KeywordTracking delete
   */
  export type KeywordTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
    /**
     * Filter which KeywordTracking to delete.
     */
    where: KeywordTrackingWhereUniqueInput
  }

  /**
   * KeywordTracking deleteMany
   */
  export type KeywordTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeywordTrackings to delete
     */
    where?: KeywordTrackingWhereInput
    /**
     * Limit how many KeywordTrackings to delete.
     */
    limit?: number
  }

  /**
   * KeywordTracking findRaw
   */
  export type KeywordTrackingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * KeywordTracking aggregateRaw
   */
  export type KeywordTrackingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * KeywordTracking without action
   */
  export type KeywordTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordTracking
     */
    select?: KeywordTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KeywordTracking
     */
    omit?: KeywordTrackingOmit<ExtArgs> | null
  }


  /**
   * Model BatchUpdate
   */

  export type AggregateBatchUpdate = {
    _count: BatchUpdateCountAggregateOutputType | null
    _avg: BatchUpdateAvgAggregateOutputType | null
    _sum: BatchUpdateSumAggregateOutputType | null
    _min: BatchUpdateMinAggregateOutputType | null
    _max: BatchUpdateMaxAggregateOutputType | null
  }

  export type BatchUpdateAvgAggregateOutputType = {
    totalKeywords: number | null
    processedKeywords: number | null
    failedKeywords: number | null
  }

  export type BatchUpdateSumAggregateOutputType = {
    totalKeywords: number | null
    processedKeywords: number | null
    failedKeywords: number | null
  }

  export type BatchUpdateMinAggregateOutputType = {
    id: string | null
    status: $Enums.BatchUpdateStatus | null
    totalKeywords: number | null
    processedKeywords: number | null
    failedKeywords: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchUpdateMaxAggregateOutputType = {
    id: string | null
    status: $Enums.BatchUpdateStatus | null
    totalKeywords: number | null
    processedKeywords: number | null
    failedKeywords: number | null
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchUpdateCountAggregateOutputType = {
    id: number
    status: number
    totalKeywords: number
    processedKeywords: number
    failedKeywords: number
    startedAt: number
    completedAt: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchUpdateAvgAggregateInputType = {
    totalKeywords?: true
    processedKeywords?: true
    failedKeywords?: true
  }

  export type BatchUpdateSumAggregateInputType = {
    totalKeywords?: true
    processedKeywords?: true
    failedKeywords?: true
  }

  export type BatchUpdateMinAggregateInputType = {
    id?: true
    status?: true
    totalKeywords?: true
    processedKeywords?: true
    failedKeywords?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchUpdateMaxAggregateInputType = {
    id?: true
    status?: true
    totalKeywords?: true
    processedKeywords?: true
    failedKeywords?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchUpdateCountAggregateInputType = {
    id?: true
    status?: true
    totalKeywords?: true
    processedKeywords?: true
    failedKeywords?: true
    startedAt?: true
    completedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchUpdate to aggregate.
     */
    where?: BatchUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchUpdates to fetch.
     */
    orderBy?: BatchUpdateOrderByWithRelationInput | BatchUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BatchUpdates
    **/
    _count?: true | BatchUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchUpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchUpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchUpdateMaxAggregateInputType
  }

  export type GetBatchUpdateAggregateType<T extends BatchUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchUpdate[P]>
      : GetScalarType<T[P], AggregateBatchUpdate[P]>
  }




  export type BatchUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchUpdateWhereInput
    orderBy?: BatchUpdateOrderByWithAggregationInput | BatchUpdateOrderByWithAggregationInput[]
    by: BatchUpdateScalarFieldEnum[] | BatchUpdateScalarFieldEnum
    having?: BatchUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchUpdateCountAggregateInputType | true
    _avg?: BatchUpdateAvgAggregateInputType
    _sum?: BatchUpdateSumAggregateInputType
    _min?: BatchUpdateMinAggregateInputType
    _max?: BatchUpdateMaxAggregateInputType
  }

  export type BatchUpdateGroupByOutputType = {
    id: string
    status: $Enums.BatchUpdateStatus
    totalKeywords: number
    processedKeywords: number
    failedKeywords: number
    startedAt: Date | null
    completedAt: Date | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: BatchUpdateCountAggregateOutputType | null
    _avg: BatchUpdateAvgAggregateOutputType | null
    _sum: BatchUpdateSumAggregateOutputType | null
    _min: BatchUpdateMinAggregateOutputType | null
    _max: BatchUpdateMaxAggregateOutputType | null
  }

  type GetBatchUpdateGroupByPayload<T extends BatchUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], BatchUpdateGroupByOutputType[P]>
        }
      >
    >


  export type BatchUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    totalKeywords?: boolean
    processedKeywords?: boolean
    failedKeywords?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchUpdate"]>



  export type BatchUpdateSelectScalar = {
    id?: boolean
    status?: boolean
    totalKeywords?: boolean
    processedKeywords?: boolean
    failedKeywords?: boolean
    startedAt?: boolean
    completedAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "totalKeywords" | "processedKeywords" | "failedKeywords" | "startedAt" | "completedAt" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["batchUpdate"]>

  export type $BatchUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BatchUpdate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.BatchUpdateStatus
      totalKeywords: number
      processedKeywords: number
      failedKeywords: number
      startedAt: Date | null
      completedAt: Date | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchUpdate"]>
    composites: {}
  }

  type BatchUpdateGetPayload<S extends boolean | null | undefined | BatchUpdateDefaultArgs> = $Result.GetResult<Prisma.$BatchUpdatePayload, S>

  type BatchUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchUpdateCountAggregateInputType | true
    }

  export interface BatchUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BatchUpdate'], meta: { name: 'BatchUpdate' } }
    /**
     * Find zero or one BatchUpdate that matches the filter.
     * @param {BatchUpdateFindUniqueArgs} args - Arguments to find a BatchUpdate
     * @example
     * // Get one BatchUpdate
     * const batchUpdate = await prisma.batchUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchUpdateFindUniqueArgs>(args: SelectSubset<T, BatchUpdateFindUniqueArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BatchUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchUpdateFindUniqueOrThrowArgs} args - Arguments to find a BatchUpdate
     * @example
     * // Get one BatchUpdate
     * const batchUpdate = await prisma.batchUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateFindFirstArgs} args - Arguments to find a BatchUpdate
     * @example
     * // Get one BatchUpdate
     * const batchUpdate = await prisma.batchUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchUpdateFindFirstArgs>(args?: SelectSubset<T, BatchUpdateFindFirstArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BatchUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateFindFirstOrThrowArgs} args - Arguments to find a BatchUpdate
     * @example
     * // Get one BatchUpdate
     * const batchUpdate = await prisma.batchUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BatchUpdates
     * const batchUpdates = await prisma.batchUpdate.findMany()
     * 
     * // Get first 10 BatchUpdates
     * const batchUpdates = await prisma.batchUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const batchUpdateWithIdOnly = await prisma.batchUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BatchUpdateFindManyArgs>(args?: SelectSubset<T, BatchUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BatchUpdate.
     * @param {BatchUpdateCreateArgs} args - Arguments to create a BatchUpdate.
     * @example
     * // Create one BatchUpdate
     * const BatchUpdate = await prisma.batchUpdate.create({
     *   data: {
     *     // ... data to create a BatchUpdate
     *   }
     * })
     * 
     */
    create<T extends BatchUpdateCreateArgs>(args: SelectSubset<T, BatchUpdateCreateArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BatchUpdates.
     * @param {BatchUpdateCreateManyArgs} args - Arguments to create many BatchUpdates.
     * @example
     * // Create many BatchUpdates
     * const batchUpdate = await prisma.batchUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchUpdateCreateManyArgs>(args?: SelectSubset<T, BatchUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BatchUpdate.
     * @param {BatchUpdateDeleteArgs} args - Arguments to delete one BatchUpdate.
     * @example
     * // Delete one BatchUpdate
     * const BatchUpdate = await prisma.batchUpdate.delete({
     *   where: {
     *     // ... filter to delete one BatchUpdate
     *   }
     * })
     * 
     */
    delete<T extends BatchUpdateDeleteArgs>(args: SelectSubset<T, BatchUpdateDeleteArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BatchUpdate.
     * @param {BatchUpdateUpdateArgs} args - Arguments to update one BatchUpdate.
     * @example
     * // Update one BatchUpdate
     * const batchUpdate = await prisma.batchUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchUpdateUpdateArgs>(args: SelectSubset<T, BatchUpdateUpdateArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BatchUpdates.
     * @param {BatchUpdateDeleteManyArgs} args - Arguments to filter BatchUpdates to delete.
     * @example
     * // Delete a few BatchUpdates
     * const { count } = await prisma.batchUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchUpdateDeleteManyArgs>(args?: SelectSubset<T, BatchUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BatchUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BatchUpdates
     * const batchUpdate = await prisma.batchUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchUpdateUpdateManyArgs>(args: SelectSubset<T, BatchUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BatchUpdate.
     * @param {BatchUpdateUpsertArgs} args - Arguments to update or create a BatchUpdate.
     * @example
     * // Update or create a BatchUpdate
     * const batchUpdate = await prisma.batchUpdate.upsert({
     *   create: {
     *     // ... data to create a BatchUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BatchUpdate we want to update
     *   }
     * })
     */
    upsert<T extends BatchUpdateUpsertArgs>(args: SelectSubset<T, BatchUpdateUpsertArgs<ExtArgs>>): Prisma__BatchUpdateClient<$Result.GetResult<Prisma.$BatchUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BatchUpdates that matches the filter.
     * @param {BatchUpdateFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const batchUpdate = await prisma.batchUpdate.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: BatchUpdateFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a BatchUpdate.
     * @param {BatchUpdateAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const batchUpdate = await prisma.batchUpdate.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: BatchUpdateAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of BatchUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateCountArgs} args - Arguments to filter BatchUpdates to count.
     * @example
     * // Count the number of BatchUpdates
     * const count = await prisma.batchUpdate.count({
     *   where: {
     *     // ... the filter for the BatchUpdates we want to count
     *   }
     * })
    **/
    count<T extends BatchUpdateCountArgs>(
      args?: Subset<T, BatchUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BatchUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchUpdateAggregateArgs>(args: Subset<T, BatchUpdateAggregateArgs>): Prisma.PrismaPromise<GetBatchUpdateAggregateType<T>>

    /**
     * Group by BatchUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchUpdateGroupByArgs['orderBy'] }
        : { orderBy?: BatchUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BatchUpdate model
   */
  readonly fields: BatchUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BatchUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BatchUpdate model
   */
  interface BatchUpdateFieldRefs {
    readonly id: FieldRef<"BatchUpdate", 'String'>
    readonly status: FieldRef<"BatchUpdate", 'BatchUpdateStatus'>
    readonly totalKeywords: FieldRef<"BatchUpdate", 'Int'>
    readonly processedKeywords: FieldRef<"BatchUpdate", 'Int'>
    readonly failedKeywords: FieldRef<"BatchUpdate", 'Int'>
    readonly startedAt: FieldRef<"BatchUpdate", 'DateTime'>
    readonly completedAt: FieldRef<"BatchUpdate", 'DateTime'>
    readonly errorMessage: FieldRef<"BatchUpdate", 'String'>
    readonly createdAt: FieldRef<"BatchUpdate", 'DateTime'>
    readonly updatedAt: FieldRef<"BatchUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BatchUpdate findUnique
   */
  export type BatchUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * Filter, which BatchUpdate to fetch.
     */
    where: BatchUpdateWhereUniqueInput
  }

  /**
   * BatchUpdate findUniqueOrThrow
   */
  export type BatchUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * Filter, which BatchUpdate to fetch.
     */
    where: BatchUpdateWhereUniqueInput
  }

  /**
   * BatchUpdate findFirst
   */
  export type BatchUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * Filter, which BatchUpdate to fetch.
     */
    where?: BatchUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchUpdates to fetch.
     */
    orderBy?: BatchUpdateOrderByWithRelationInput | BatchUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchUpdates.
     */
    cursor?: BatchUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchUpdates.
     */
    distinct?: BatchUpdateScalarFieldEnum | BatchUpdateScalarFieldEnum[]
  }

  /**
   * BatchUpdate findFirstOrThrow
   */
  export type BatchUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * Filter, which BatchUpdate to fetch.
     */
    where?: BatchUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchUpdates to fetch.
     */
    orderBy?: BatchUpdateOrderByWithRelationInput | BatchUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BatchUpdates.
     */
    cursor?: BatchUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BatchUpdates.
     */
    distinct?: BatchUpdateScalarFieldEnum | BatchUpdateScalarFieldEnum[]
  }

  /**
   * BatchUpdate findMany
   */
  export type BatchUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * Filter, which BatchUpdates to fetch.
     */
    where?: BatchUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BatchUpdates to fetch.
     */
    orderBy?: BatchUpdateOrderByWithRelationInput | BatchUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BatchUpdates.
     */
    cursor?: BatchUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BatchUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BatchUpdates.
     */
    skip?: number
    distinct?: BatchUpdateScalarFieldEnum | BatchUpdateScalarFieldEnum[]
  }

  /**
   * BatchUpdate create
   */
  export type BatchUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * The data needed to create a BatchUpdate.
     */
    data: XOR<BatchUpdateCreateInput, BatchUpdateUncheckedCreateInput>
  }

  /**
   * BatchUpdate createMany
   */
  export type BatchUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BatchUpdates.
     */
    data: BatchUpdateCreateManyInput | BatchUpdateCreateManyInput[]
  }

  /**
   * BatchUpdate update
   */
  export type BatchUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * The data needed to update a BatchUpdate.
     */
    data: XOR<BatchUpdateUpdateInput, BatchUpdateUncheckedUpdateInput>
    /**
     * Choose, which BatchUpdate to update.
     */
    where: BatchUpdateWhereUniqueInput
  }

  /**
   * BatchUpdate updateMany
   */
  export type BatchUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BatchUpdates.
     */
    data: XOR<BatchUpdateUpdateManyMutationInput, BatchUpdateUncheckedUpdateManyInput>
    /**
     * Filter which BatchUpdates to update
     */
    where?: BatchUpdateWhereInput
    /**
     * Limit how many BatchUpdates to update.
     */
    limit?: number
  }

  /**
   * BatchUpdate upsert
   */
  export type BatchUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * The filter to search for the BatchUpdate to update in case it exists.
     */
    where: BatchUpdateWhereUniqueInput
    /**
     * In case the BatchUpdate found by the `where` argument doesn't exist, create a new BatchUpdate with this data.
     */
    create: XOR<BatchUpdateCreateInput, BatchUpdateUncheckedCreateInput>
    /**
     * In case the BatchUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchUpdateUpdateInput, BatchUpdateUncheckedUpdateInput>
  }

  /**
   * BatchUpdate delete
   */
  export type BatchUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
    /**
     * Filter which BatchUpdate to delete.
     */
    where: BatchUpdateWhereUniqueInput
  }

  /**
   * BatchUpdate deleteMany
   */
  export type BatchUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BatchUpdates to delete
     */
    where?: BatchUpdateWhereInput
    /**
     * Limit how many BatchUpdates to delete.
     */
    limit?: number
  }

  /**
   * BatchUpdate findRaw
   */
  export type BatchUpdateFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BatchUpdate aggregateRaw
   */
  export type BatchUpdateAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * BatchUpdate without action
   */
  export type BatchUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BatchUpdate
     */
    select?: BatchUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BatchUpdate
     */
    omit?: BatchUpdateOmit<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsAvgAggregateOutputType = {
    autoRefreshHours: number | null
    alertThreshold: number | null
  }

  export type UserSettingsSumAggregateOutputType = {
    autoRefreshHours: number | null
    alertThreshold: number | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    defaultLocation: string | null
    defaultDomain: string | null
    autoRefreshHours: number | null
    emailAlerts: boolean | null
    alertThreshold: number | null
    batchUpdateTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    defaultLocation: string | null
    defaultDomain: string | null
    autoRefreshHours: number | null
    emailAlerts: boolean | null
    alertThreshold: number | null
    batchUpdateTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    defaultLocation: number
    defaultDomain: number
    autoRefreshHours: number
    emailAlerts: number
    alertThreshold: number
    batchUpdateTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsAvgAggregateInputType = {
    autoRefreshHours?: true
    alertThreshold?: true
  }

  export type UserSettingsSumAggregateInputType = {
    autoRefreshHours?: true
    alertThreshold?: true
  }

  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    defaultLocation?: true
    defaultDomain?: true
    autoRefreshHours?: true
    emailAlerts?: true
    alertThreshold?: true
    batchUpdateTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    defaultLocation?: true
    defaultDomain?: true
    autoRefreshHours?: true
    emailAlerts?: true
    alertThreshold?: true
    batchUpdateTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    defaultLocation?: true
    defaultDomain?: true
    autoRefreshHours?: true
    emailAlerts?: true
    alertThreshold?: true
    batchUpdateTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _avg?: UserSettingsAvgAggregateInputType
    _sum?: UserSettingsSumAggregateInputType
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    defaultLocation: string
    defaultDomain: string | null
    autoRefreshHours: number
    emailAlerts: boolean
    alertThreshold: number
    batchUpdateTime: string
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _avg: UserSettingsAvgAggregateOutputType | null
    _sum: UserSettingsSumAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    defaultLocation?: boolean
    defaultDomain?: boolean
    autoRefreshHours?: boolean
    emailAlerts?: boolean
    alertThreshold?: boolean
    batchUpdateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userSettings"]>



  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    defaultLocation?: boolean
    defaultDomain?: boolean
    autoRefreshHours?: boolean
    emailAlerts?: boolean
    alertThreshold?: boolean
    batchUpdateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "defaultLocation" | "defaultDomain" | "autoRefreshHours" | "emailAlerts" | "alertThreshold" | "batchUpdateTime" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      defaultLocation: string
      defaultDomain: string | null
      autoRefreshHours: number
      emailAlerts: boolean
      alertThreshold: number
      batchUpdateTime: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * @param {UserSettingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userSettings = await prisma.userSettings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserSettingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserSettings.
     * @param {UserSettingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userSettings = await prisma.userSettings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserSettingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly defaultLocation: FieldRef<"UserSettings", 'String'>
    readonly defaultDomain: FieldRef<"UserSettings", 'String'>
    readonly autoRefreshHours: FieldRef<"UserSettings", 'Int'>
    readonly emailAlerts: FieldRef<"UserSettings", 'Boolean'>
    readonly alertThreshold: FieldRef<"UserSettings", 'Int'>
    readonly batchUpdateTime: FieldRef<"UserSettings", 'String'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings findRaw
   */
  export type UserSettingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserSettings aggregateRaw
   */
  export type UserSettingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
  }


  /**
   * Model RankAlert
   */

  export type AggregateRankAlert = {
    _count: RankAlertCountAggregateOutputType | null
    _avg: RankAlertAvgAggregateOutputType | null
    _sum: RankAlertSumAggregateOutputType | null
    _min: RankAlertMinAggregateOutputType | null
    _max: RankAlertMaxAggregateOutputType | null
  }

  export type RankAlertAvgAggregateOutputType = {
    threshold: number | null
    currentRank: number | null
    previousRank: number | null
  }

  export type RankAlertSumAggregateOutputType = {
    threshold: number | null
    currentRank: number | null
    previousRank: number | null
  }

  export type RankAlertMinAggregateOutputType = {
    id: string | null
    userId: string | null
    keyword: string | null
    location: string | null
    alertType: $Enums.RankAlertType | null
    threshold: number | null
    currentRank: number | null
    previousRank: number | null
    isRead: boolean | null
    batchId: string | null
    createdAt: Date | null
  }

  export type RankAlertMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    keyword: string | null
    location: string | null
    alertType: $Enums.RankAlertType | null
    threshold: number | null
    currentRank: number | null
    previousRank: number | null
    isRead: boolean | null
    batchId: string | null
    createdAt: Date | null
  }

  export type RankAlertCountAggregateOutputType = {
    id: number
    userId: number
    keyword: number
    location: number
    alertType: number
    threshold: number
    currentRank: number
    previousRank: number
    isRead: number
    batchId: number
    createdAt: number
    _all: number
  }


  export type RankAlertAvgAggregateInputType = {
    threshold?: true
    currentRank?: true
    previousRank?: true
  }

  export type RankAlertSumAggregateInputType = {
    threshold?: true
    currentRank?: true
    previousRank?: true
  }

  export type RankAlertMinAggregateInputType = {
    id?: true
    userId?: true
    keyword?: true
    location?: true
    alertType?: true
    threshold?: true
    currentRank?: true
    previousRank?: true
    isRead?: true
    batchId?: true
    createdAt?: true
  }

  export type RankAlertMaxAggregateInputType = {
    id?: true
    userId?: true
    keyword?: true
    location?: true
    alertType?: true
    threshold?: true
    currentRank?: true
    previousRank?: true
    isRead?: true
    batchId?: true
    createdAt?: true
  }

  export type RankAlertCountAggregateInputType = {
    id?: true
    userId?: true
    keyword?: true
    location?: true
    alertType?: true
    threshold?: true
    currentRank?: true
    previousRank?: true
    isRead?: true
    batchId?: true
    createdAt?: true
    _all?: true
  }

  export type RankAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankAlert to aggregate.
     */
    where?: RankAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankAlerts to fetch.
     */
    orderBy?: RankAlertOrderByWithRelationInput | RankAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RankAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RankAlerts
    **/
    _count?: true | RankAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RankAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RankAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RankAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RankAlertMaxAggregateInputType
  }

  export type GetRankAlertAggregateType<T extends RankAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateRankAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRankAlert[P]>
      : GetScalarType<T[P], AggregateRankAlert[P]>
  }




  export type RankAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RankAlertWhereInput
    orderBy?: RankAlertOrderByWithAggregationInput | RankAlertOrderByWithAggregationInput[]
    by: RankAlertScalarFieldEnum[] | RankAlertScalarFieldEnum
    having?: RankAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RankAlertCountAggregateInputType | true
    _avg?: RankAlertAvgAggregateInputType
    _sum?: RankAlertSumAggregateInputType
    _min?: RankAlertMinAggregateInputType
    _max?: RankAlertMaxAggregateInputType
  }

  export type RankAlertGroupByOutputType = {
    id: string
    userId: string
    keyword: string
    location: string
    alertType: $Enums.RankAlertType
    threshold: number
    currentRank: number | null
    previousRank: number | null
    isRead: boolean
    batchId: string | null
    createdAt: Date
    _count: RankAlertCountAggregateOutputType | null
    _avg: RankAlertAvgAggregateOutputType | null
    _sum: RankAlertSumAggregateOutputType | null
    _min: RankAlertMinAggregateOutputType | null
    _max: RankAlertMaxAggregateOutputType | null
  }

  type GetRankAlertGroupByPayload<T extends RankAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RankAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RankAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RankAlertGroupByOutputType[P]>
            : GetScalarType<T[P], RankAlertGroupByOutputType[P]>
        }
      >
    >


  export type RankAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    keyword?: boolean
    location?: boolean
    alertType?: boolean
    threshold?: boolean
    currentRank?: boolean
    previousRank?: boolean
    isRead?: boolean
    batchId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["rankAlert"]>



  export type RankAlertSelectScalar = {
    id?: boolean
    userId?: boolean
    keyword?: boolean
    location?: boolean
    alertType?: boolean
    threshold?: boolean
    currentRank?: boolean
    previousRank?: boolean
    isRead?: boolean
    batchId?: boolean
    createdAt?: boolean
  }

  export type RankAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "keyword" | "location" | "alertType" | "threshold" | "currentRank" | "previousRank" | "isRead" | "batchId" | "createdAt", ExtArgs["result"]["rankAlert"]>

  export type $RankAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RankAlert"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      keyword: string
      location: string
      alertType: $Enums.RankAlertType
      threshold: number
      currentRank: number | null
      previousRank: number | null
      isRead: boolean
      batchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["rankAlert"]>
    composites: {}
  }

  type RankAlertGetPayload<S extends boolean | null | undefined | RankAlertDefaultArgs> = $Result.GetResult<Prisma.$RankAlertPayload, S>

  type RankAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RankAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RankAlertCountAggregateInputType | true
    }

  export interface RankAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RankAlert'], meta: { name: 'RankAlert' } }
    /**
     * Find zero or one RankAlert that matches the filter.
     * @param {RankAlertFindUniqueArgs} args - Arguments to find a RankAlert
     * @example
     * // Get one RankAlert
     * const rankAlert = await prisma.rankAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RankAlertFindUniqueArgs>(args: SelectSubset<T, RankAlertFindUniqueArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RankAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RankAlertFindUniqueOrThrowArgs} args - Arguments to find a RankAlert
     * @example
     * // Get one RankAlert
     * const rankAlert = await prisma.rankAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RankAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, RankAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RankAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertFindFirstArgs} args - Arguments to find a RankAlert
     * @example
     * // Get one RankAlert
     * const rankAlert = await prisma.rankAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RankAlertFindFirstArgs>(args?: SelectSubset<T, RankAlertFindFirstArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RankAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertFindFirstOrThrowArgs} args - Arguments to find a RankAlert
     * @example
     * // Get one RankAlert
     * const rankAlert = await prisma.rankAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RankAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, RankAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RankAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RankAlerts
     * const rankAlerts = await prisma.rankAlert.findMany()
     * 
     * // Get first 10 RankAlerts
     * const rankAlerts = await prisma.rankAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rankAlertWithIdOnly = await prisma.rankAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RankAlertFindManyArgs>(args?: SelectSubset<T, RankAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RankAlert.
     * @param {RankAlertCreateArgs} args - Arguments to create a RankAlert.
     * @example
     * // Create one RankAlert
     * const RankAlert = await prisma.rankAlert.create({
     *   data: {
     *     // ... data to create a RankAlert
     *   }
     * })
     * 
     */
    create<T extends RankAlertCreateArgs>(args: SelectSubset<T, RankAlertCreateArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RankAlerts.
     * @param {RankAlertCreateManyArgs} args - Arguments to create many RankAlerts.
     * @example
     * // Create many RankAlerts
     * const rankAlert = await prisma.rankAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RankAlertCreateManyArgs>(args?: SelectSubset<T, RankAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RankAlert.
     * @param {RankAlertDeleteArgs} args - Arguments to delete one RankAlert.
     * @example
     * // Delete one RankAlert
     * const RankAlert = await prisma.rankAlert.delete({
     *   where: {
     *     // ... filter to delete one RankAlert
     *   }
     * })
     * 
     */
    delete<T extends RankAlertDeleteArgs>(args: SelectSubset<T, RankAlertDeleteArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RankAlert.
     * @param {RankAlertUpdateArgs} args - Arguments to update one RankAlert.
     * @example
     * // Update one RankAlert
     * const rankAlert = await prisma.rankAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RankAlertUpdateArgs>(args: SelectSubset<T, RankAlertUpdateArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RankAlerts.
     * @param {RankAlertDeleteManyArgs} args - Arguments to filter RankAlerts to delete.
     * @example
     * // Delete a few RankAlerts
     * const { count } = await prisma.rankAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RankAlertDeleteManyArgs>(args?: SelectSubset<T, RankAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RankAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RankAlerts
     * const rankAlert = await prisma.rankAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RankAlertUpdateManyArgs>(args: SelectSubset<T, RankAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RankAlert.
     * @param {RankAlertUpsertArgs} args - Arguments to update or create a RankAlert.
     * @example
     * // Update or create a RankAlert
     * const rankAlert = await prisma.rankAlert.upsert({
     *   create: {
     *     // ... data to create a RankAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RankAlert we want to update
     *   }
     * })
     */
    upsert<T extends RankAlertUpsertArgs>(args: SelectSubset<T, RankAlertUpsertArgs<ExtArgs>>): Prisma__RankAlertClient<$Result.GetResult<Prisma.$RankAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RankAlerts that matches the filter.
     * @param {RankAlertFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rankAlert = await prisma.rankAlert.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RankAlertFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a RankAlert.
     * @param {RankAlertAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rankAlert = await prisma.rankAlert.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: RankAlertAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of RankAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertCountArgs} args - Arguments to filter RankAlerts to count.
     * @example
     * // Count the number of RankAlerts
     * const count = await prisma.rankAlert.count({
     *   where: {
     *     // ... the filter for the RankAlerts we want to count
     *   }
     * })
    **/
    count<T extends RankAlertCountArgs>(
      args?: Subset<T, RankAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RankAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RankAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RankAlertAggregateArgs>(args: Subset<T, RankAlertAggregateArgs>): Prisma.PrismaPromise<GetRankAlertAggregateType<T>>

    /**
     * Group by RankAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RankAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RankAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RankAlertGroupByArgs['orderBy'] }
        : { orderBy?: RankAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RankAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRankAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RankAlert model
   */
  readonly fields: RankAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RankAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RankAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RankAlert model
   */
  interface RankAlertFieldRefs {
    readonly id: FieldRef<"RankAlert", 'String'>
    readonly userId: FieldRef<"RankAlert", 'String'>
    readonly keyword: FieldRef<"RankAlert", 'String'>
    readonly location: FieldRef<"RankAlert", 'String'>
    readonly alertType: FieldRef<"RankAlert", 'RankAlertType'>
    readonly threshold: FieldRef<"RankAlert", 'Int'>
    readonly currentRank: FieldRef<"RankAlert", 'Int'>
    readonly previousRank: FieldRef<"RankAlert", 'Int'>
    readonly isRead: FieldRef<"RankAlert", 'Boolean'>
    readonly batchId: FieldRef<"RankAlert", 'String'>
    readonly createdAt: FieldRef<"RankAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RankAlert findUnique
   */
  export type RankAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * Filter, which RankAlert to fetch.
     */
    where: RankAlertWhereUniqueInput
  }

  /**
   * RankAlert findUniqueOrThrow
   */
  export type RankAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * Filter, which RankAlert to fetch.
     */
    where: RankAlertWhereUniqueInput
  }

  /**
   * RankAlert findFirst
   */
  export type RankAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * Filter, which RankAlert to fetch.
     */
    where?: RankAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankAlerts to fetch.
     */
    orderBy?: RankAlertOrderByWithRelationInput | RankAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankAlerts.
     */
    cursor?: RankAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankAlerts.
     */
    distinct?: RankAlertScalarFieldEnum | RankAlertScalarFieldEnum[]
  }

  /**
   * RankAlert findFirstOrThrow
   */
  export type RankAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * Filter, which RankAlert to fetch.
     */
    where?: RankAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankAlerts to fetch.
     */
    orderBy?: RankAlertOrderByWithRelationInput | RankAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RankAlerts.
     */
    cursor?: RankAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RankAlerts.
     */
    distinct?: RankAlertScalarFieldEnum | RankAlertScalarFieldEnum[]
  }

  /**
   * RankAlert findMany
   */
  export type RankAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * Filter, which RankAlerts to fetch.
     */
    where?: RankAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RankAlerts to fetch.
     */
    orderBy?: RankAlertOrderByWithRelationInput | RankAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RankAlerts.
     */
    cursor?: RankAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RankAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RankAlerts.
     */
    skip?: number
    distinct?: RankAlertScalarFieldEnum | RankAlertScalarFieldEnum[]
  }

  /**
   * RankAlert create
   */
  export type RankAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * The data needed to create a RankAlert.
     */
    data: XOR<RankAlertCreateInput, RankAlertUncheckedCreateInput>
  }

  /**
   * RankAlert createMany
   */
  export type RankAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RankAlerts.
     */
    data: RankAlertCreateManyInput | RankAlertCreateManyInput[]
  }

  /**
   * RankAlert update
   */
  export type RankAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * The data needed to update a RankAlert.
     */
    data: XOR<RankAlertUpdateInput, RankAlertUncheckedUpdateInput>
    /**
     * Choose, which RankAlert to update.
     */
    where: RankAlertWhereUniqueInput
  }

  /**
   * RankAlert updateMany
   */
  export type RankAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RankAlerts.
     */
    data: XOR<RankAlertUpdateManyMutationInput, RankAlertUncheckedUpdateManyInput>
    /**
     * Filter which RankAlerts to update
     */
    where?: RankAlertWhereInput
    /**
     * Limit how many RankAlerts to update.
     */
    limit?: number
  }

  /**
   * RankAlert upsert
   */
  export type RankAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * The filter to search for the RankAlert to update in case it exists.
     */
    where: RankAlertWhereUniqueInput
    /**
     * In case the RankAlert found by the `where` argument doesn't exist, create a new RankAlert with this data.
     */
    create: XOR<RankAlertCreateInput, RankAlertUncheckedCreateInput>
    /**
     * In case the RankAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RankAlertUpdateInput, RankAlertUncheckedUpdateInput>
  }

  /**
   * RankAlert delete
   */
  export type RankAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
    /**
     * Filter which RankAlert to delete.
     */
    where: RankAlertWhereUniqueInput
  }

  /**
   * RankAlert deleteMany
   */
  export type RankAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RankAlerts to delete
     */
    where?: RankAlertWhereInput
    /**
     * Limit how many RankAlerts to delete.
     */
    limit?: number
  }

  /**
   * RankAlert findRaw
   */
  export type RankAlertFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RankAlert aggregateRaw
   */
  export type RankAlertAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * RankAlert without action
   */
  export type RankAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RankAlert
     */
    select?: RankAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RankAlert
     */
    omit?: RankAlertOmit<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    points: number | null
  }

  export type TaskSumAggregateOutputType = {
    points: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    placeId: string | null
    title: string | null
    description: string | null
    category: string | null
    type: string | null
    priority: string | null
    impact: string | null
    points: number | null
    week: string | null
    status: string | null
    repeatable: boolean | null
    estimatedTime: string | null
    repeatFrequency: string | null
    businessType: string | null
    actionType: string | null
    editableViaAPI: boolean | null
    verificationType: string | null
    caution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    placeId: string | null
    title: string | null
    description: string | null
    category: string | null
    type: string | null
    priority: string | null
    impact: string | null
    points: number | null
    week: string | null
    status: string | null
    repeatable: boolean | null
    estimatedTime: string | null
    repeatFrequency: string | null
    businessType: string | null
    actionType: string | null
    editableViaAPI: boolean | null
    verificationType: string | null
    caution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    placeId: number
    title: number
    description: number
    category: number
    type: number
    priority: number
    impact: number
    points: number
    week: number
    status: number
    repeatable: number
    estimatedTime: number
    repeatFrequency: number
    businessType: number
    actionType: number
    editableViaAPI: number
    verificationType: number
    caution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    points?: true
  }

  export type TaskSumAggregateInputType = {
    points?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    title?: true
    description?: true
    category?: true
    type?: true
    priority?: true
    impact?: true
    points?: true
    week?: true
    status?: true
    repeatable?: true
    estimatedTime?: true
    repeatFrequency?: true
    businessType?: true
    actionType?: true
    editableViaAPI?: true
    verificationType?: true
    caution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    title?: true
    description?: true
    category?: true
    type?: true
    priority?: true
    impact?: true
    points?: true
    week?: true
    status?: true
    repeatable?: true
    estimatedTime?: true
    repeatFrequency?: true
    businessType?: true
    actionType?: true
    editableViaAPI?: true
    verificationType?: true
    caution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    title?: true
    description?: true
    category?: true
    type?: true
    priority?: true
    impact?: true
    points?: true
    week?: true
    status?: true
    repeatable?: true
    estimatedTime?: true
    repeatFrequency?: true
    businessType?: true
    actionType?: true
    editableViaAPI?: true
    verificationType?: true
    caution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    placeId: string | null
    title: string
    description: string
    category: string
    type: string
    priority: string
    impact: string
    points: number
    week: string
    status: string
    repeatable: boolean
    estimatedTime: string
    repeatFrequency: string | null
    businessType: string
    actionType: string
    editableViaAPI: boolean
    verificationType: string
    caution: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    placeId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    priority?: boolean
    impact?: boolean
    points?: boolean
    week?: boolean
    status?: boolean
    repeatable?: boolean
    estimatedTime?: boolean
    repeatFrequency?: boolean
    businessType?: boolean
    actionType?: boolean
    editableViaAPI?: boolean
    verificationType?: boolean
    caution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["task"]>



  export type TaskSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    placeId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    priority?: boolean
    impact?: boolean
    points?: boolean
    week?: boolean
    status?: boolean
    repeatable?: boolean
    estimatedTime?: boolean
    repeatFrequency?: boolean
    businessType?: boolean
    actionType?: boolean
    editableViaAPI?: boolean
    verificationType?: boolean
    caution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "placeId" | "title" | "description" | "category" | "type" | "priority" | "impact" | "points" | "week" | "status" | "repeatable" | "estimatedTime" | "repeatFrequency" | "businessType" | "actionType" | "editableViaAPI" | "verificationType" | "caution" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      placeId: string | null
      title: string
      description: string
      category: string
      type: string
      priority: string
      impact: string
      points: number
      week: string
      status: string
      repeatable: boolean
      estimatedTime: string
      repeatFrequency: string | null
      businessType: string
      actionType: string
      editableViaAPI: boolean
      verificationType: string
      caution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * @param {TaskFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const task = await prisma.task.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TaskFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Task.
     * @param {TaskAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const task = await prisma.task.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TaskAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly userId: FieldRef<"Task", 'String'>
    readonly locationId: FieldRef<"Task", 'String'>
    readonly placeId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly category: FieldRef<"Task", 'String'>
    readonly type: FieldRef<"Task", 'String'>
    readonly priority: FieldRef<"Task", 'String'>
    readonly impact: FieldRef<"Task", 'String'>
    readonly points: FieldRef<"Task", 'Int'>
    readonly week: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly repeatable: FieldRef<"Task", 'Boolean'>
    readonly estimatedTime: FieldRef<"Task", 'String'>
    readonly repeatFrequency: FieldRef<"Task", 'String'>
    readonly businessType: FieldRef<"Task", 'String'>
    readonly actionType: FieldRef<"Task", 'String'>
    readonly editableViaAPI: FieldRef<"Task", 'Boolean'>
    readonly verificationType: FieldRef<"Task", 'String'>
    readonly caution: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task findRaw
   */
  export type TaskFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Task aggregateRaw
   */
  export type TaskAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
  }


  /**
   * Model CompletedTask
   */

  export type AggregateCompletedTask = {
    _count: CompletedTaskCountAggregateOutputType | null
    _avg: CompletedTaskAvgAggregateOutputType | null
    _sum: CompletedTaskSumAggregateOutputType | null
    _min: CompletedTaskMinAggregateOutputType | null
    _max: CompletedTaskMaxAggregateOutputType | null
  }

  export type CompletedTaskAvgAggregateOutputType = {
    points: number | null
    pointsAwarded: number | null
    pointsPenalty: number | null
  }

  export type CompletedTaskSumAggregateOutputType = {
    points: number | null
    pointsAwarded: number | null
    pointsPenalty: number | null
  }

  export type CompletedTaskMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    placeId: string | null
    title: string | null
    description: string | null
    category: string | null
    type: string | null
    priority: string | null
    impact: string | null
    points: number | null
    repeatable: boolean | null
    estimatedTime: string | null
    week: string | null
    month: string | null
    repeatFrequency: string | null
    businessType: string | null
    actionType: string | null
    editableViaAPI: boolean | null
    verificationType: string | null
    caution: string | null
    completedAt: Date | null
    verificationConfidence: string | null
    verificationReason: string | null
    pointsAwarded: number | null
    pointsPenalty: number | null
    verifiedAt: Date | null
  }

  export type CompletedTaskMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    placeId: string | null
    title: string | null
    description: string | null
    category: string | null
    type: string | null
    priority: string | null
    impact: string | null
    points: number | null
    repeatable: boolean | null
    estimatedTime: string | null
    week: string | null
    month: string | null
    repeatFrequency: string | null
    businessType: string | null
    actionType: string | null
    editableViaAPI: boolean | null
    verificationType: string | null
    caution: string | null
    completedAt: Date | null
    verificationConfidence: string | null
    verificationReason: string | null
    pointsAwarded: number | null
    pointsPenalty: number | null
    verifiedAt: Date | null
  }

  export type CompletedTaskCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    placeId: number
    title: number
    description: number
    category: number
    type: number
    priority: number
    impact: number
    points: number
    repeatable: number
    estimatedTime: number
    week: number
    month: number
    repeatFrequency: number
    businessType: number
    actionType: number
    editableViaAPI: number
    verificationType: number
    caution: number
    completedAt: number
    verificationConfidence: number
    verificationReason: number
    pointsAwarded: number
    pointsPenalty: number
    verifiedAt: number
    _all: number
  }


  export type CompletedTaskAvgAggregateInputType = {
    points?: true
    pointsAwarded?: true
    pointsPenalty?: true
  }

  export type CompletedTaskSumAggregateInputType = {
    points?: true
    pointsAwarded?: true
    pointsPenalty?: true
  }

  export type CompletedTaskMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    title?: true
    description?: true
    category?: true
    type?: true
    priority?: true
    impact?: true
    points?: true
    repeatable?: true
    estimatedTime?: true
    week?: true
    month?: true
    repeatFrequency?: true
    businessType?: true
    actionType?: true
    editableViaAPI?: true
    verificationType?: true
    caution?: true
    completedAt?: true
    verificationConfidence?: true
    verificationReason?: true
    pointsAwarded?: true
    pointsPenalty?: true
    verifiedAt?: true
  }

  export type CompletedTaskMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    title?: true
    description?: true
    category?: true
    type?: true
    priority?: true
    impact?: true
    points?: true
    repeatable?: true
    estimatedTime?: true
    week?: true
    month?: true
    repeatFrequency?: true
    businessType?: true
    actionType?: true
    editableViaAPI?: true
    verificationType?: true
    caution?: true
    completedAt?: true
    verificationConfidence?: true
    verificationReason?: true
    pointsAwarded?: true
    pointsPenalty?: true
    verifiedAt?: true
  }

  export type CompletedTaskCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    title?: true
    description?: true
    category?: true
    type?: true
    priority?: true
    impact?: true
    points?: true
    repeatable?: true
    estimatedTime?: true
    week?: true
    month?: true
    repeatFrequency?: true
    businessType?: true
    actionType?: true
    editableViaAPI?: true
    verificationType?: true
    caution?: true
    completedAt?: true
    verificationConfidence?: true
    verificationReason?: true
    pointsAwarded?: true
    pointsPenalty?: true
    verifiedAt?: true
    _all?: true
  }

  export type CompletedTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletedTask to aggregate.
     */
    where?: CompletedTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedTasks to fetch.
     */
    orderBy?: CompletedTaskOrderByWithRelationInput | CompletedTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompletedTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompletedTasks
    **/
    _count?: true | CompletedTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompletedTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompletedTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompletedTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompletedTaskMaxAggregateInputType
  }

  export type GetCompletedTaskAggregateType<T extends CompletedTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateCompletedTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompletedTask[P]>
      : GetScalarType<T[P], AggregateCompletedTask[P]>
  }




  export type CompletedTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompletedTaskWhereInput
    orderBy?: CompletedTaskOrderByWithAggregationInput | CompletedTaskOrderByWithAggregationInput[]
    by: CompletedTaskScalarFieldEnum[] | CompletedTaskScalarFieldEnum
    having?: CompletedTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompletedTaskCountAggregateInputType | true
    _avg?: CompletedTaskAvgAggregateInputType
    _sum?: CompletedTaskSumAggregateInputType
    _min?: CompletedTaskMinAggregateInputType
    _max?: CompletedTaskMaxAggregateInputType
  }

  export type CompletedTaskGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    placeId: string | null
    title: string
    description: string | null
    category: string
    type: string
    priority: string
    impact: string
    points: number
    repeatable: boolean
    estimatedTime: string
    week: string
    month: string
    repeatFrequency: string | null
    businessType: string
    actionType: string
    editableViaAPI: boolean
    verificationType: string
    caution: string | null
    completedAt: Date
    verificationConfidence: string | null
    verificationReason: string | null
    pointsAwarded: number | null
    pointsPenalty: number | null
    verifiedAt: Date | null
    _count: CompletedTaskCountAggregateOutputType | null
    _avg: CompletedTaskAvgAggregateOutputType | null
    _sum: CompletedTaskSumAggregateOutputType | null
    _min: CompletedTaskMinAggregateOutputType | null
    _max: CompletedTaskMaxAggregateOutputType | null
  }

  type GetCompletedTaskGroupByPayload<T extends CompletedTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompletedTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompletedTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompletedTaskGroupByOutputType[P]>
            : GetScalarType<T[P], CompletedTaskGroupByOutputType[P]>
        }
      >
    >


  export type CompletedTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    placeId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    priority?: boolean
    impact?: boolean
    points?: boolean
    repeatable?: boolean
    estimatedTime?: boolean
    week?: boolean
    month?: boolean
    repeatFrequency?: boolean
    businessType?: boolean
    actionType?: boolean
    editableViaAPI?: boolean
    verificationType?: boolean
    caution?: boolean
    completedAt?: boolean
    verificationConfidence?: boolean
    verificationReason?: boolean
    pointsAwarded?: boolean
    pointsPenalty?: boolean
    verifiedAt?: boolean
  }, ExtArgs["result"]["completedTask"]>



  export type CompletedTaskSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    placeId?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    priority?: boolean
    impact?: boolean
    points?: boolean
    repeatable?: boolean
    estimatedTime?: boolean
    week?: boolean
    month?: boolean
    repeatFrequency?: boolean
    businessType?: boolean
    actionType?: boolean
    editableViaAPI?: boolean
    verificationType?: boolean
    caution?: boolean
    completedAt?: boolean
    verificationConfidence?: boolean
    verificationReason?: boolean
    pointsAwarded?: boolean
    pointsPenalty?: boolean
    verifiedAt?: boolean
  }

  export type CompletedTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "placeId" | "title" | "description" | "category" | "type" | "priority" | "impact" | "points" | "repeatable" | "estimatedTime" | "week" | "month" | "repeatFrequency" | "businessType" | "actionType" | "editableViaAPI" | "verificationType" | "caution" | "completedAt" | "verificationConfidence" | "verificationReason" | "pointsAwarded" | "pointsPenalty" | "verifiedAt", ExtArgs["result"]["completedTask"]>

  export type $CompletedTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompletedTask"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      placeId: string | null
      title: string
      description: string | null
      category: string
      type: string
      priority: string
      impact: string
      points: number
      repeatable: boolean
      estimatedTime: string
      week: string
      month: string
      repeatFrequency: string | null
      businessType: string
      actionType: string
      editableViaAPI: boolean
      verificationType: string
      caution: string | null
      completedAt: Date
      verificationConfidence: string | null
      verificationReason: string | null
      pointsAwarded: number | null
      pointsPenalty: number | null
      verifiedAt: Date | null
    }, ExtArgs["result"]["completedTask"]>
    composites: {}
  }

  type CompletedTaskGetPayload<S extends boolean | null | undefined | CompletedTaskDefaultArgs> = $Result.GetResult<Prisma.$CompletedTaskPayload, S>

  type CompletedTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompletedTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompletedTaskCountAggregateInputType | true
    }

  export interface CompletedTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompletedTask'], meta: { name: 'CompletedTask' } }
    /**
     * Find zero or one CompletedTask that matches the filter.
     * @param {CompletedTaskFindUniqueArgs} args - Arguments to find a CompletedTask
     * @example
     * // Get one CompletedTask
     * const completedTask = await prisma.completedTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompletedTaskFindUniqueArgs>(args: SelectSubset<T, CompletedTaskFindUniqueArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompletedTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompletedTaskFindUniqueOrThrowArgs} args - Arguments to find a CompletedTask
     * @example
     * // Get one CompletedTask
     * const completedTask = await prisma.completedTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompletedTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, CompletedTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompletedTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskFindFirstArgs} args - Arguments to find a CompletedTask
     * @example
     * // Get one CompletedTask
     * const completedTask = await prisma.completedTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompletedTaskFindFirstArgs>(args?: SelectSubset<T, CompletedTaskFindFirstArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompletedTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskFindFirstOrThrowArgs} args - Arguments to find a CompletedTask
     * @example
     * // Get one CompletedTask
     * const completedTask = await prisma.completedTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompletedTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, CompletedTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompletedTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompletedTasks
     * const completedTasks = await prisma.completedTask.findMany()
     * 
     * // Get first 10 CompletedTasks
     * const completedTasks = await prisma.completedTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const completedTaskWithIdOnly = await prisma.completedTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompletedTaskFindManyArgs>(args?: SelectSubset<T, CompletedTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompletedTask.
     * @param {CompletedTaskCreateArgs} args - Arguments to create a CompletedTask.
     * @example
     * // Create one CompletedTask
     * const CompletedTask = await prisma.completedTask.create({
     *   data: {
     *     // ... data to create a CompletedTask
     *   }
     * })
     * 
     */
    create<T extends CompletedTaskCreateArgs>(args: SelectSubset<T, CompletedTaskCreateArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompletedTasks.
     * @param {CompletedTaskCreateManyArgs} args - Arguments to create many CompletedTasks.
     * @example
     * // Create many CompletedTasks
     * const completedTask = await prisma.completedTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompletedTaskCreateManyArgs>(args?: SelectSubset<T, CompletedTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CompletedTask.
     * @param {CompletedTaskDeleteArgs} args - Arguments to delete one CompletedTask.
     * @example
     * // Delete one CompletedTask
     * const CompletedTask = await prisma.completedTask.delete({
     *   where: {
     *     // ... filter to delete one CompletedTask
     *   }
     * })
     * 
     */
    delete<T extends CompletedTaskDeleteArgs>(args: SelectSubset<T, CompletedTaskDeleteArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompletedTask.
     * @param {CompletedTaskUpdateArgs} args - Arguments to update one CompletedTask.
     * @example
     * // Update one CompletedTask
     * const completedTask = await prisma.completedTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompletedTaskUpdateArgs>(args: SelectSubset<T, CompletedTaskUpdateArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompletedTasks.
     * @param {CompletedTaskDeleteManyArgs} args - Arguments to filter CompletedTasks to delete.
     * @example
     * // Delete a few CompletedTasks
     * const { count } = await prisma.completedTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompletedTaskDeleteManyArgs>(args?: SelectSubset<T, CompletedTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompletedTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompletedTasks
     * const completedTask = await prisma.completedTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompletedTaskUpdateManyArgs>(args: SelectSubset<T, CompletedTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CompletedTask.
     * @param {CompletedTaskUpsertArgs} args - Arguments to update or create a CompletedTask.
     * @example
     * // Update or create a CompletedTask
     * const completedTask = await prisma.completedTask.upsert({
     *   create: {
     *     // ... data to create a CompletedTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompletedTask we want to update
     *   }
     * })
     */
    upsert<T extends CompletedTaskUpsertArgs>(args: SelectSubset<T, CompletedTaskUpsertArgs<ExtArgs>>): Prisma__CompletedTaskClient<$Result.GetResult<Prisma.$CompletedTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompletedTasks that matches the filter.
     * @param {CompletedTaskFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const completedTask = await prisma.completedTask.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: CompletedTaskFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CompletedTask.
     * @param {CompletedTaskAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const completedTask = await prisma.completedTask.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: CompletedTaskAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of CompletedTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskCountArgs} args - Arguments to filter CompletedTasks to count.
     * @example
     * // Count the number of CompletedTasks
     * const count = await prisma.completedTask.count({
     *   where: {
     *     // ... the filter for the CompletedTasks we want to count
     *   }
     * })
    **/
    count<T extends CompletedTaskCountArgs>(
      args?: Subset<T, CompletedTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompletedTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompletedTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompletedTaskAggregateArgs>(args: Subset<T, CompletedTaskAggregateArgs>): Prisma.PrismaPromise<GetCompletedTaskAggregateType<T>>

    /**
     * Group by CompletedTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompletedTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompletedTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompletedTaskGroupByArgs['orderBy'] }
        : { orderBy?: CompletedTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompletedTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompletedTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompletedTask model
   */
  readonly fields: CompletedTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompletedTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompletedTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompletedTask model
   */
  interface CompletedTaskFieldRefs {
    readonly id: FieldRef<"CompletedTask", 'String'>
    readonly userId: FieldRef<"CompletedTask", 'String'>
    readonly locationId: FieldRef<"CompletedTask", 'String'>
    readonly placeId: FieldRef<"CompletedTask", 'String'>
    readonly title: FieldRef<"CompletedTask", 'String'>
    readonly description: FieldRef<"CompletedTask", 'String'>
    readonly category: FieldRef<"CompletedTask", 'String'>
    readonly type: FieldRef<"CompletedTask", 'String'>
    readonly priority: FieldRef<"CompletedTask", 'String'>
    readonly impact: FieldRef<"CompletedTask", 'String'>
    readonly points: FieldRef<"CompletedTask", 'Int'>
    readonly repeatable: FieldRef<"CompletedTask", 'Boolean'>
    readonly estimatedTime: FieldRef<"CompletedTask", 'String'>
    readonly week: FieldRef<"CompletedTask", 'String'>
    readonly month: FieldRef<"CompletedTask", 'String'>
    readonly repeatFrequency: FieldRef<"CompletedTask", 'String'>
    readonly businessType: FieldRef<"CompletedTask", 'String'>
    readonly actionType: FieldRef<"CompletedTask", 'String'>
    readonly editableViaAPI: FieldRef<"CompletedTask", 'Boolean'>
    readonly verificationType: FieldRef<"CompletedTask", 'String'>
    readonly caution: FieldRef<"CompletedTask", 'String'>
    readonly completedAt: FieldRef<"CompletedTask", 'DateTime'>
    readonly verificationConfidence: FieldRef<"CompletedTask", 'String'>
    readonly verificationReason: FieldRef<"CompletedTask", 'String'>
    readonly pointsAwarded: FieldRef<"CompletedTask", 'Int'>
    readonly pointsPenalty: FieldRef<"CompletedTask", 'Int'>
    readonly verifiedAt: FieldRef<"CompletedTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompletedTask findUnique
   */
  export type CompletedTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * Filter, which CompletedTask to fetch.
     */
    where: CompletedTaskWhereUniqueInput
  }

  /**
   * CompletedTask findUniqueOrThrow
   */
  export type CompletedTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * Filter, which CompletedTask to fetch.
     */
    where: CompletedTaskWhereUniqueInput
  }

  /**
   * CompletedTask findFirst
   */
  export type CompletedTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * Filter, which CompletedTask to fetch.
     */
    where?: CompletedTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedTasks to fetch.
     */
    orderBy?: CompletedTaskOrderByWithRelationInput | CompletedTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletedTasks.
     */
    cursor?: CompletedTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletedTasks.
     */
    distinct?: CompletedTaskScalarFieldEnum | CompletedTaskScalarFieldEnum[]
  }

  /**
   * CompletedTask findFirstOrThrow
   */
  export type CompletedTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * Filter, which CompletedTask to fetch.
     */
    where?: CompletedTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedTasks to fetch.
     */
    orderBy?: CompletedTaskOrderByWithRelationInput | CompletedTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompletedTasks.
     */
    cursor?: CompletedTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompletedTasks.
     */
    distinct?: CompletedTaskScalarFieldEnum | CompletedTaskScalarFieldEnum[]
  }

  /**
   * CompletedTask findMany
   */
  export type CompletedTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * Filter, which CompletedTasks to fetch.
     */
    where?: CompletedTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompletedTasks to fetch.
     */
    orderBy?: CompletedTaskOrderByWithRelationInput | CompletedTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompletedTasks.
     */
    cursor?: CompletedTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompletedTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompletedTasks.
     */
    skip?: number
    distinct?: CompletedTaskScalarFieldEnum | CompletedTaskScalarFieldEnum[]
  }

  /**
   * CompletedTask create
   */
  export type CompletedTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * The data needed to create a CompletedTask.
     */
    data: XOR<CompletedTaskCreateInput, CompletedTaskUncheckedCreateInput>
  }

  /**
   * CompletedTask createMany
   */
  export type CompletedTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompletedTasks.
     */
    data: CompletedTaskCreateManyInput | CompletedTaskCreateManyInput[]
  }

  /**
   * CompletedTask update
   */
  export type CompletedTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * The data needed to update a CompletedTask.
     */
    data: XOR<CompletedTaskUpdateInput, CompletedTaskUncheckedUpdateInput>
    /**
     * Choose, which CompletedTask to update.
     */
    where: CompletedTaskWhereUniqueInput
  }

  /**
   * CompletedTask updateMany
   */
  export type CompletedTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompletedTasks.
     */
    data: XOR<CompletedTaskUpdateManyMutationInput, CompletedTaskUncheckedUpdateManyInput>
    /**
     * Filter which CompletedTasks to update
     */
    where?: CompletedTaskWhereInput
    /**
     * Limit how many CompletedTasks to update.
     */
    limit?: number
  }

  /**
   * CompletedTask upsert
   */
  export type CompletedTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * The filter to search for the CompletedTask to update in case it exists.
     */
    where: CompletedTaskWhereUniqueInput
    /**
     * In case the CompletedTask found by the `where` argument doesn't exist, create a new CompletedTask with this data.
     */
    create: XOR<CompletedTaskCreateInput, CompletedTaskUncheckedCreateInput>
    /**
     * In case the CompletedTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompletedTaskUpdateInput, CompletedTaskUncheckedUpdateInput>
  }

  /**
   * CompletedTask delete
   */
  export type CompletedTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
    /**
     * Filter which CompletedTask to delete.
     */
    where: CompletedTaskWhereUniqueInput
  }

  /**
   * CompletedTask deleteMany
   */
  export type CompletedTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompletedTasks to delete
     */
    where?: CompletedTaskWhereInput
    /**
     * Limit how many CompletedTasks to delete.
     */
    limit?: number
  }

  /**
   * CompletedTask findRaw
   */
  export type CompletedTaskFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CompletedTask aggregateRaw
   */
  export type CompletedTaskAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * CompletedTask without action
   */
  export type CompletedTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompletedTask
     */
    select?: CompletedTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompletedTask
     */
    omit?: CompletedTaskOmit<ExtArgs> | null
  }


  /**
   * Model TaskExclusion
   */

  export type AggregateTaskExclusion = {
    _count: TaskExclusionCountAggregateOutputType | null
    _min: TaskExclusionMinAggregateOutputType | null
    _max: TaskExclusionMaxAggregateOutputType | null
  }

  export type TaskExclusionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    month: string | null
    taskTitle: string | null
    taskType: string | null
    category: string | null
    reason: string | null
    taskId: string | null
    completedTaskId: string | null
    excludedAt: Date | null
    expiresAt: Date | null
  }

  export type TaskExclusionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    month: string | null
    taskTitle: string | null
    taskType: string | null
    category: string | null
    reason: string | null
    taskId: string | null
    completedTaskId: string | null
    excludedAt: Date | null
    expiresAt: Date | null
  }

  export type TaskExclusionCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    month: number
    taskTitle: number
    taskType: number
    category: number
    reason: number
    taskId: number
    completedTaskId: number
    excludedAt: number
    expiresAt: number
    _all: number
  }


  export type TaskExclusionMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    month?: true
    taskTitle?: true
    taskType?: true
    category?: true
    reason?: true
    taskId?: true
    completedTaskId?: true
    excludedAt?: true
    expiresAt?: true
  }

  export type TaskExclusionMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    month?: true
    taskTitle?: true
    taskType?: true
    category?: true
    reason?: true
    taskId?: true
    completedTaskId?: true
    excludedAt?: true
    expiresAt?: true
  }

  export type TaskExclusionCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    month?: true
    taskTitle?: true
    taskType?: true
    category?: true
    reason?: true
    taskId?: true
    completedTaskId?: true
    excludedAt?: true
    expiresAt?: true
    _all?: true
  }

  export type TaskExclusionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskExclusion to aggregate.
     */
    where?: TaskExclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExclusions to fetch.
     */
    orderBy?: TaskExclusionOrderByWithRelationInput | TaskExclusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskExclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExclusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskExclusions
    **/
    _count?: true | TaskExclusionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskExclusionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskExclusionMaxAggregateInputType
  }

  export type GetTaskExclusionAggregateType<T extends TaskExclusionAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskExclusion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskExclusion[P]>
      : GetScalarType<T[P], AggregateTaskExclusion[P]>
  }




  export type TaskExclusionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskExclusionWhereInput
    orderBy?: TaskExclusionOrderByWithAggregationInput | TaskExclusionOrderByWithAggregationInput[]
    by: TaskExclusionScalarFieldEnum[] | TaskExclusionScalarFieldEnum
    having?: TaskExclusionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskExclusionCountAggregateInputType | true
    _min?: TaskExclusionMinAggregateInputType
    _max?: TaskExclusionMaxAggregateInputType
  }

  export type TaskExclusionGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    month: string
    taskTitle: string
    taskType: string
    category: string
    reason: string
    taskId: string | null
    completedTaskId: string | null
    excludedAt: Date
    expiresAt: Date
    _count: TaskExclusionCountAggregateOutputType | null
    _min: TaskExclusionMinAggregateOutputType | null
    _max: TaskExclusionMaxAggregateOutputType | null
  }

  type GetTaskExclusionGroupByPayload<T extends TaskExclusionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskExclusionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskExclusionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskExclusionGroupByOutputType[P]>
            : GetScalarType<T[P], TaskExclusionGroupByOutputType[P]>
        }
      >
    >


  export type TaskExclusionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    month?: boolean
    taskTitle?: boolean
    taskType?: boolean
    category?: boolean
    reason?: boolean
    taskId?: boolean
    completedTaskId?: boolean
    excludedAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["taskExclusion"]>



  export type TaskExclusionSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    month?: boolean
    taskTitle?: boolean
    taskType?: boolean
    category?: boolean
    reason?: boolean
    taskId?: boolean
    completedTaskId?: boolean
    excludedAt?: boolean
    expiresAt?: boolean
  }

  export type TaskExclusionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "month" | "taskTitle" | "taskType" | "category" | "reason" | "taskId" | "completedTaskId" | "excludedAt" | "expiresAt", ExtArgs["result"]["taskExclusion"]>

  export type $TaskExclusionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskExclusion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      month: string
      taskTitle: string
      taskType: string
      category: string
      reason: string
      taskId: string | null
      completedTaskId: string | null
      excludedAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["taskExclusion"]>
    composites: {}
  }

  type TaskExclusionGetPayload<S extends boolean | null | undefined | TaskExclusionDefaultArgs> = $Result.GetResult<Prisma.$TaskExclusionPayload, S>

  type TaskExclusionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskExclusionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskExclusionCountAggregateInputType | true
    }

  export interface TaskExclusionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskExclusion'], meta: { name: 'TaskExclusion' } }
    /**
     * Find zero or one TaskExclusion that matches the filter.
     * @param {TaskExclusionFindUniqueArgs} args - Arguments to find a TaskExclusion
     * @example
     * // Get one TaskExclusion
     * const taskExclusion = await prisma.taskExclusion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskExclusionFindUniqueArgs>(args: SelectSubset<T, TaskExclusionFindUniqueArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskExclusion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskExclusionFindUniqueOrThrowArgs} args - Arguments to find a TaskExclusion
     * @example
     * // Get one TaskExclusion
     * const taskExclusion = await prisma.taskExclusion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskExclusionFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskExclusionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskExclusion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionFindFirstArgs} args - Arguments to find a TaskExclusion
     * @example
     * // Get one TaskExclusion
     * const taskExclusion = await prisma.taskExclusion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskExclusionFindFirstArgs>(args?: SelectSubset<T, TaskExclusionFindFirstArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskExclusion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionFindFirstOrThrowArgs} args - Arguments to find a TaskExclusion
     * @example
     * // Get one TaskExclusion
     * const taskExclusion = await prisma.taskExclusion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskExclusionFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskExclusionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskExclusions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskExclusions
     * const taskExclusions = await prisma.taskExclusion.findMany()
     * 
     * // Get first 10 TaskExclusions
     * const taskExclusions = await prisma.taskExclusion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskExclusionWithIdOnly = await prisma.taskExclusion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskExclusionFindManyArgs>(args?: SelectSubset<T, TaskExclusionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskExclusion.
     * @param {TaskExclusionCreateArgs} args - Arguments to create a TaskExclusion.
     * @example
     * // Create one TaskExclusion
     * const TaskExclusion = await prisma.taskExclusion.create({
     *   data: {
     *     // ... data to create a TaskExclusion
     *   }
     * })
     * 
     */
    create<T extends TaskExclusionCreateArgs>(args: SelectSubset<T, TaskExclusionCreateArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskExclusions.
     * @param {TaskExclusionCreateManyArgs} args - Arguments to create many TaskExclusions.
     * @example
     * // Create many TaskExclusions
     * const taskExclusion = await prisma.taskExclusion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskExclusionCreateManyArgs>(args?: SelectSubset<T, TaskExclusionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TaskExclusion.
     * @param {TaskExclusionDeleteArgs} args - Arguments to delete one TaskExclusion.
     * @example
     * // Delete one TaskExclusion
     * const TaskExclusion = await prisma.taskExclusion.delete({
     *   where: {
     *     // ... filter to delete one TaskExclusion
     *   }
     * })
     * 
     */
    delete<T extends TaskExclusionDeleteArgs>(args: SelectSubset<T, TaskExclusionDeleteArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskExclusion.
     * @param {TaskExclusionUpdateArgs} args - Arguments to update one TaskExclusion.
     * @example
     * // Update one TaskExclusion
     * const taskExclusion = await prisma.taskExclusion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskExclusionUpdateArgs>(args: SelectSubset<T, TaskExclusionUpdateArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskExclusions.
     * @param {TaskExclusionDeleteManyArgs} args - Arguments to filter TaskExclusions to delete.
     * @example
     * // Delete a few TaskExclusions
     * const { count } = await prisma.taskExclusion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskExclusionDeleteManyArgs>(args?: SelectSubset<T, TaskExclusionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskExclusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskExclusions
     * const taskExclusion = await prisma.taskExclusion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskExclusionUpdateManyArgs>(args: SelectSubset<T, TaskExclusionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TaskExclusion.
     * @param {TaskExclusionUpsertArgs} args - Arguments to update or create a TaskExclusion.
     * @example
     * // Update or create a TaskExclusion
     * const taskExclusion = await prisma.taskExclusion.upsert({
     *   create: {
     *     // ... data to create a TaskExclusion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskExclusion we want to update
     *   }
     * })
     */
    upsert<T extends TaskExclusionUpsertArgs>(args: SelectSubset<T, TaskExclusionUpsertArgs<ExtArgs>>): Prisma__TaskExclusionClient<$Result.GetResult<Prisma.$TaskExclusionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskExclusions that matches the filter.
     * @param {TaskExclusionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const taskExclusion = await prisma.taskExclusion.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TaskExclusionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TaskExclusion.
     * @param {TaskExclusionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const taskExclusion = await prisma.taskExclusion.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TaskExclusionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TaskExclusions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionCountArgs} args - Arguments to filter TaskExclusions to count.
     * @example
     * // Count the number of TaskExclusions
     * const count = await prisma.taskExclusion.count({
     *   where: {
     *     // ... the filter for the TaskExclusions we want to count
     *   }
     * })
    **/
    count<T extends TaskExclusionCountArgs>(
      args?: Subset<T, TaskExclusionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskExclusionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskExclusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskExclusionAggregateArgs>(args: Subset<T, TaskExclusionAggregateArgs>): Prisma.PrismaPromise<GetTaskExclusionAggregateType<T>>

    /**
     * Group by TaskExclusion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskExclusionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskExclusionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskExclusionGroupByArgs['orderBy'] }
        : { orderBy?: TaskExclusionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskExclusionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskExclusionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskExclusion model
   */
  readonly fields: TaskExclusionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskExclusion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskExclusionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskExclusion model
   */
  interface TaskExclusionFieldRefs {
    readonly id: FieldRef<"TaskExclusion", 'String'>
    readonly userId: FieldRef<"TaskExclusion", 'String'>
    readonly locationId: FieldRef<"TaskExclusion", 'String'>
    readonly month: FieldRef<"TaskExclusion", 'String'>
    readonly taskTitle: FieldRef<"TaskExclusion", 'String'>
    readonly taskType: FieldRef<"TaskExclusion", 'String'>
    readonly category: FieldRef<"TaskExclusion", 'String'>
    readonly reason: FieldRef<"TaskExclusion", 'String'>
    readonly taskId: FieldRef<"TaskExclusion", 'String'>
    readonly completedTaskId: FieldRef<"TaskExclusion", 'String'>
    readonly excludedAt: FieldRef<"TaskExclusion", 'DateTime'>
    readonly expiresAt: FieldRef<"TaskExclusion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskExclusion findUnique
   */
  export type TaskExclusionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * Filter, which TaskExclusion to fetch.
     */
    where: TaskExclusionWhereUniqueInput
  }

  /**
   * TaskExclusion findUniqueOrThrow
   */
  export type TaskExclusionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * Filter, which TaskExclusion to fetch.
     */
    where: TaskExclusionWhereUniqueInput
  }

  /**
   * TaskExclusion findFirst
   */
  export type TaskExclusionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * Filter, which TaskExclusion to fetch.
     */
    where?: TaskExclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExclusions to fetch.
     */
    orderBy?: TaskExclusionOrderByWithRelationInput | TaskExclusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskExclusions.
     */
    cursor?: TaskExclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExclusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskExclusions.
     */
    distinct?: TaskExclusionScalarFieldEnum | TaskExclusionScalarFieldEnum[]
  }

  /**
   * TaskExclusion findFirstOrThrow
   */
  export type TaskExclusionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * Filter, which TaskExclusion to fetch.
     */
    where?: TaskExclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExclusions to fetch.
     */
    orderBy?: TaskExclusionOrderByWithRelationInput | TaskExclusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskExclusions.
     */
    cursor?: TaskExclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExclusions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskExclusions.
     */
    distinct?: TaskExclusionScalarFieldEnum | TaskExclusionScalarFieldEnum[]
  }

  /**
   * TaskExclusion findMany
   */
  export type TaskExclusionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * Filter, which TaskExclusions to fetch.
     */
    where?: TaskExclusionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskExclusions to fetch.
     */
    orderBy?: TaskExclusionOrderByWithRelationInput | TaskExclusionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskExclusions.
     */
    cursor?: TaskExclusionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskExclusions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskExclusions.
     */
    skip?: number
    distinct?: TaskExclusionScalarFieldEnum | TaskExclusionScalarFieldEnum[]
  }

  /**
   * TaskExclusion create
   */
  export type TaskExclusionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * The data needed to create a TaskExclusion.
     */
    data: XOR<TaskExclusionCreateInput, TaskExclusionUncheckedCreateInput>
  }

  /**
   * TaskExclusion createMany
   */
  export type TaskExclusionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskExclusions.
     */
    data: TaskExclusionCreateManyInput | TaskExclusionCreateManyInput[]
  }

  /**
   * TaskExclusion update
   */
  export type TaskExclusionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * The data needed to update a TaskExclusion.
     */
    data: XOR<TaskExclusionUpdateInput, TaskExclusionUncheckedUpdateInput>
    /**
     * Choose, which TaskExclusion to update.
     */
    where: TaskExclusionWhereUniqueInput
  }

  /**
   * TaskExclusion updateMany
   */
  export type TaskExclusionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskExclusions.
     */
    data: XOR<TaskExclusionUpdateManyMutationInput, TaskExclusionUncheckedUpdateManyInput>
    /**
     * Filter which TaskExclusions to update
     */
    where?: TaskExclusionWhereInput
    /**
     * Limit how many TaskExclusions to update.
     */
    limit?: number
  }

  /**
   * TaskExclusion upsert
   */
  export type TaskExclusionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * The filter to search for the TaskExclusion to update in case it exists.
     */
    where: TaskExclusionWhereUniqueInput
    /**
     * In case the TaskExclusion found by the `where` argument doesn't exist, create a new TaskExclusion with this data.
     */
    create: XOR<TaskExclusionCreateInput, TaskExclusionUncheckedCreateInput>
    /**
     * In case the TaskExclusion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskExclusionUpdateInput, TaskExclusionUncheckedUpdateInput>
  }

  /**
   * TaskExclusion delete
   */
  export type TaskExclusionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
    /**
     * Filter which TaskExclusion to delete.
     */
    where: TaskExclusionWhereUniqueInput
  }

  /**
   * TaskExclusion deleteMany
   */
  export type TaskExclusionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskExclusions to delete
     */
    where?: TaskExclusionWhereInput
    /**
     * Limit how many TaskExclusions to delete.
     */
    limit?: number
  }

  /**
   * TaskExclusion findRaw
   */
  export type TaskExclusionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TaskExclusion aggregateRaw
   */
  export type TaskExclusionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TaskExclusion without action
   */
  export type TaskExclusionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskExclusion
     */
    select?: TaskExclusionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskExclusion
     */
    omit?: TaskExclusionOmit<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    totalPoints: number | null
    currentLevel: number | null
    tasksCompleted: number | null
    locationsCount: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    totalPoints: number | null
    currentLevel: number | null
    tasksCompleted: number | null
    locationsCount: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPoints: number | null
    currentLevel: number | null
    tasksCompleted: number | null
    locationsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalPoints: number | null
    currentLevel: number | null
    tasksCompleted: number | null
    locationsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    totalPoints: number
    currentLevel: number
    tasksCompleted: number
    locationsCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    totalPoints?: true
    currentLevel?: true
    tasksCompleted?: true
    locationsCount?: true
  }

  export type UserProgressSumAggregateInputType = {
    totalPoints?: true
    currentLevel?: true
    tasksCompleted?: true
    locationsCount?: true
  }

  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    totalPoints?: true
    currentLevel?: true
    tasksCompleted?: true
    locationsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    totalPoints?: true
    currentLevel?: true
    tasksCompleted?: true
    locationsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    totalPoints?: true
    currentLevel?: true
    tasksCompleted?: true
    locationsCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    totalPoints: number
    currentLevel: number
    tasksCompleted: number
    locationsCount: number
    createdAt: Date
    updatedAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalPoints?: boolean
    currentLevel?: boolean
    tasksCompleted?: boolean
    locationsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProgress"]>



  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    totalPoints?: boolean
    currentLevel?: boolean
    tasksCompleted?: boolean
    locationsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "totalPoints" | "currentLevel" | "tasksCompleted" | "locationsCount" | "createdAt" | "updatedAt", ExtArgs["result"]["userProgress"]>

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalPoints: number
      currentLevel: number
      tasksCompleted: number
      locationsCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * @param {UserProgressFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userProgress = await prisma.userProgress.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserProgressFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserProgress.
     * @param {UserProgressAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userProgress = await prisma.userProgress.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserProgressAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly totalPoints: FieldRef<"UserProgress", 'Int'>
    readonly currentLevel: FieldRef<"UserProgress", 'Int'>
    readonly tasksCompleted: FieldRef<"UserProgress", 'Int'>
    readonly locationsCount: FieldRef<"UserProgress", 'Int'>
    readonly createdAt: FieldRef<"UserProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserProgress findRaw
   */
  export type UserProgressFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserProgress aggregateRaw
   */
  export type UserProgressAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
  }


  /**
   * Model LocationProgress
   */

  export type AggregateLocationProgress = {
    _count: LocationProgressCountAggregateOutputType | null
    _avg: LocationProgressAvgAggregateOutputType | null
    _sum: LocationProgressSumAggregateOutputType | null
    _min: LocationProgressMinAggregateOutputType | null
    _max: LocationProgressMaxAggregateOutputType | null
  }

  export type LocationProgressAvgAggregateOutputType = {
    totalPoints: number | null
    weeklyPoints: number | null
    monthlyPoints: number | null
    tasksCompleted: number | null
    profileScore: number | null
    engagementScore: number | null
    contentScore: number | null
    currentStreak: number | null
    longestStreak: number | null
    level: number | null
  }

  export type LocationProgressSumAggregateOutputType = {
    totalPoints: number | null
    weeklyPoints: number | null
    monthlyPoints: number | null
    tasksCompleted: number | null
    profileScore: number | null
    engagementScore: number | null
    contentScore: number | null
    currentStreak: number | null
    longestStreak: number | null
    level: number | null
  }

  export type LocationProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    placeId: string | null
    totalPoints: number | null
    weeklyPoints: number | null
    monthlyPoints: number | null
    tasksCompleted: number | null
    profileScore: number | null
    engagementScore: number | null
    contentScore: number | null
    currentStreak: number | null
    longestStreak: number | null
    lastActiveDate: Date | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    placeId: string | null
    totalPoints: number | null
    weeklyPoints: number | null
    monthlyPoints: number | null
    tasksCompleted: number | null
    profileScore: number | null
    engagementScore: number | null
    contentScore: number | null
    currentStreak: number | null
    longestStreak: number | null
    lastActiveDate: Date | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationProgressCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    placeId: number
    totalPoints: number
    weeklyPoints: number
    monthlyPoints: number
    tasksCompleted: number
    profileScore: number
    engagementScore: number
    contentScore: number
    currentStreak: number
    longestStreak: number
    lastActiveDate: number
    level: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationProgressAvgAggregateInputType = {
    totalPoints?: true
    weeklyPoints?: true
    monthlyPoints?: true
    tasksCompleted?: true
    profileScore?: true
    engagementScore?: true
    contentScore?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
  }

  export type LocationProgressSumAggregateInputType = {
    totalPoints?: true
    weeklyPoints?: true
    monthlyPoints?: true
    tasksCompleted?: true
    profileScore?: true
    engagementScore?: true
    contentScore?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
  }

  export type LocationProgressMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    totalPoints?: true
    weeklyPoints?: true
    monthlyPoints?: true
    tasksCompleted?: true
    profileScore?: true
    engagementScore?: true
    contentScore?: true
    currentStreak?: true
    longestStreak?: true
    lastActiveDate?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    totalPoints?: true
    weeklyPoints?: true
    monthlyPoints?: true
    tasksCompleted?: true
    profileScore?: true
    engagementScore?: true
    contentScore?: true
    currentStreak?: true
    longestStreak?: true
    lastActiveDate?: true
    level?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationProgressCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    placeId?: true
    totalPoints?: true
    weeklyPoints?: true
    monthlyPoints?: true
    tasksCompleted?: true
    profileScore?: true
    engagementScore?: true
    contentScore?: true
    currentStreak?: true
    longestStreak?: true
    lastActiveDate?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationProgress to aggregate.
     */
    where?: LocationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationProgresses to fetch.
     */
    orderBy?: LocationProgressOrderByWithRelationInput | LocationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationProgresses
    **/
    _count?: true | LocationProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationProgressMaxAggregateInputType
  }

  export type GetLocationProgressAggregateType<T extends LocationProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationProgress[P]>
      : GetScalarType<T[P], AggregateLocationProgress[P]>
  }




  export type LocationProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationProgressWhereInput
    orderBy?: LocationProgressOrderByWithAggregationInput | LocationProgressOrderByWithAggregationInput[]
    by: LocationProgressScalarFieldEnum[] | LocationProgressScalarFieldEnum
    having?: LocationProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationProgressCountAggregateInputType | true
    _avg?: LocationProgressAvgAggregateInputType
    _sum?: LocationProgressSumAggregateInputType
    _min?: LocationProgressMinAggregateInputType
    _max?: LocationProgressMaxAggregateInputType
  }

  export type LocationProgressGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    placeId: string | null
    totalPoints: number
    weeklyPoints: number
    monthlyPoints: number
    tasksCompleted: number
    profileScore: number
    engagementScore: number
    contentScore: number
    currentStreak: number
    longestStreak: number
    lastActiveDate: Date
    level: number
    createdAt: Date
    updatedAt: Date
    _count: LocationProgressCountAggregateOutputType | null
    _avg: LocationProgressAvgAggregateOutputType | null
    _sum: LocationProgressSumAggregateOutputType | null
    _min: LocationProgressMinAggregateOutputType | null
    _max: LocationProgressMaxAggregateOutputType | null
  }

  type GetLocationProgressGroupByPayload<T extends LocationProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationProgressGroupByOutputType[P]>
            : GetScalarType<T[P], LocationProgressGroupByOutputType[P]>
        }
      >
    >


  export type LocationProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    placeId?: boolean
    totalPoints?: boolean
    weeklyPoints?: boolean
    monthlyPoints?: boolean
    tasksCompleted?: boolean
    profileScore?: boolean
    engagementScore?: boolean
    contentScore?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActiveDate?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["locationProgress"]>



  export type LocationProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    placeId?: boolean
    totalPoints?: boolean
    weeklyPoints?: boolean
    monthlyPoints?: boolean
    tasksCompleted?: boolean
    profileScore?: boolean
    engagementScore?: boolean
    contentScore?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastActiveDate?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "placeId" | "totalPoints" | "weeklyPoints" | "monthlyPoints" | "tasksCompleted" | "profileScore" | "engagementScore" | "contentScore" | "currentStreak" | "longestStreak" | "lastActiveDate" | "level" | "createdAt" | "updatedAt", ExtArgs["result"]["locationProgress"]>

  export type $LocationProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationProgress"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      placeId: string | null
      totalPoints: number
      weeklyPoints: number
      monthlyPoints: number
      tasksCompleted: number
      profileScore: number
      engagementScore: number
      contentScore: number
      currentStreak: number
      longestStreak: number
      lastActiveDate: Date
      level: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["locationProgress"]>
    composites: {}
  }

  type LocationProgressGetPayload<S extends boolean | null | undefined | LocationProgressDefaultArgs> = $Result.GetResult<Prisma.$LocationProgressPayload, S>

  type LocationProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationProgressCountAggregateInputType | true
    }

  export interface LocationProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationProgress'], meta: { name: 'LocationProgress' } }
    /**
     * Find zero or one LocationProgress that matches the filter.
     * @param {LocationProgressFindUniqueArgs} args - Arguments to find a LocationProgress
     * @example
     * // Get one LocationProgress
     * const locationProgress = await prisma.locationProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationProgressFindUniqueArgs>(args: SelectSubset<T, LocationProgressFindUniqueArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationProgressFindUniqueOrThrowArgs} args - Arguments to find a LocationProgress
     * @example
     * // Get one LocationProgress
     * const locationProgress = await prisma.locationProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressFindFirstArgs} args - Arguments to find a LocationProgress
     * @example
     * // Get one LocationProgress
     * const locationProgress = await prisma.locationProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationProgressFindFirstArgs>(args?: SelectSubset<T, LocationProgressFindFirstArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressFindFirstOrThrowArgs} args - Arguments to find a LocationProgress
     * @example
     * // Get one LocationProgress
     * const locationProgress = await prisma.locationProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationProgresses
     * const locationProgresses = await prisma.locationProgress.findMany()
     * 
     * // Get first 10 LocationProgresses
     * const locationProgresses = await prisma.locationProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationProgressWithIdOnly = await prisma.locationProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationProgressFindManyArgs>(args?: SelectSubset<T, LocationProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationProgress.
     * @param {LocationProgressCreateArgs} args - Arguments to create a LocationProgress.
     * @example
     * // Create one LocationProgress
     * const LocationProgress = await prisma.locationProgress.create({
     *   data: {
     *     // ... data to create a LocationProgress
     *   }
     * })
     * 
     */
    create<T extends LocationProgressCreateArgs>(args: SelectSubset<T, LocationProgressCreateArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationProgresses.
     * @param {LocationProgressCreateManyArgs} args - Arguments to create many LocationProgresses.
     * @example
     * // Create many LocationProgresses
     * const locationProgress = await prisma.locationProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationProgressCreateManyArgs>(args?: SelectSubset<T, LocationProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationProgress.
     * @param {LocationProgressDeleteArgs} args - Arguments to delete one LocationProgress.
     * @example
     * // Delete one LocationProgress
     * const LocationProgress = await prisma.locationProgress.delete({
     *   where: {
     *     // ... filter to delete one LocationProgress
     *   }
     * })
     * 
     */
    delete<T extends LocationProgressDeleteArgs>(args: SelectSubset<T, LocationProgressDeleteArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationProgress.
     * @param {LocationProgressUpdateArgs} args - Arguments to update one LocationProgress.
     * @example
     * // Update one LocationProgress
     * const locationProgress = await prisma.locationProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationProgressUpdateArgs>(args: SelectSubset<T, LocationProgressUpdateArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationProgresses.
     * @param {LocationProgressDeleteManyArgs} args - Arguments to filter LocationProgresses to delete.
     * @example
     * // Delete a few LocationProgresses
     * const { count } = await prisma.locationProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationProgressDeleteManyArgs>(args?: SelectSubset<T, LocationProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationProgresses
     * const locationProgress = await prisma.locationProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationProgressUpdateManyArgs>(args: SelectSubset<T, LocationProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationProgress.
     * @param {LocationProgressUpsertArgs} args - Arguments to update or create a LocationProgress.
     * @example
     * // Update or create a LocationProgress
     * const locationProgress = await prisma.locationProgress.upsert({
     *   create: {
     *     // ... data to create a LocationProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationProgress we want to update
     *   }
     * })
     */
    upsert<T extends LocationProgressUpsertArgs>(args: SelectSubset<T, LocationProgressUpsertArgs<ExtArgs>>): Prisma__LocationProgressClient<$Result.GetResult<Prisma.$LocationProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationProgresses that matches the filter.
     * @param {LocationProgressFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const locationProgress = await prisma.locationProgress.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LocationProgressFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LocationProgress.
     * @param {LocationProgressAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const locationProgress = await prisma.locationProgress.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocationProgressAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LocationProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressCountArgs} args - Arguments to filter LocationProgresses to count.
     * @example
     * // Count the number of LocationProgresses
     * const count = await prisma.locationProgress.count({
     *   where: {
     *     // ... the filter for the LocationProgresses we want to count
     *   }
     * })
    **/
    count<T extends LocationProgressCountArgs>(
      args?: Subset<T, LocationProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationProgressAggregateArgs>(args: Subset<T, LocationProgressAggregateArgs>): Prisma.PrismaPromise<GetLocationProgressAggregateType<T>>

    /**
     * Group by LocationProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationProgressGroupByArgs['orderBy'] }
        : { orderBy?: LocationProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationProgress model
   */
  readonly fields: LocationProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationProgress model
   */
  interface LocationProgressFieldRefs {
    readonly id: FieldRef<"LocationProgress", 'String'>
    readonly userId: FieldRef<"LocationProgress", 'String'>
    readonly locationId: FieldRef<"LocationProgress", 'String'>
    readonly placeId: FieldRef<"LocationProgress", 'String'>
    readonly totalPoints: FieldRef<"LocationProgress", 'Int'>
    readonly weeklyPoints: FieldRef<"LocationProgress", 'Int'>
    readonly monthlyPoints: FieldRef<"LocationProgress", 'Int'>
    readonly tasksCompleted: FieldRef<"LocationProgress", 'Int'>
    readonly profileScore: FieldRef<"LocationProgress", 'Int'>
    readonly engagementScore: FieldRef<"LocationProgress", 'Int'>
    readonly contentScore: FieldRef<"LocationProgress", 'Int'>
    readonly currentStreak: FieldRef<"LocationProgress", 'Int'>
    readonly longestStreak: FieldRef<"LocationProgress", 'Int'>
    readonly lastActiveDate: FieldRef<"LocationProgress", 'DateTime'>
    readonly level: FieldRef<"LocationProgress", 'Int'>
    readonly createdAt: FieldRef<"LocationProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"LocationProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationProgress findUnique
   */
  export type LocationProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * Filter, which LocationProgress to fetch.
     */
    where: LocationProgressWhereUniqueInput
  }

  /**
   * LocationProgress findUniqueOrThrow
   */
  export type LocationProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * Filter, which LocationProgress to fetch.
     */
    where: LocationProgressWhereUniqueInput
  }

  /**
   * LocationProgress findFirst
   */
  export type LocationProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * Filter, which LocationProgress to fetch.
     */
    where?: LocationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationProgresses to fetch.
     */
    orderBy?: LocationProgressOrderByWithRelationInput | LocationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationProgresses.
     */
    cursor?: LocationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationProgresses.
     */
    distinct?: LocationProgressScalarFieldEnum | LocationProgressScalarFieldEnum[]
  }

  /**
   * LocationProgress findFirstOrThrow
   */
  export type LocationProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * Filter, which LocationProgress to fetch.
     */
    where?: LocationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationProgresses to fetch.
     */
    orderBy?: LocationProgressOrderByWithRelationInput | LocationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationProgresses.
     */
    cursor?: LocationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationProgresses.
     */
    distinct?: LocationProgressScalarFieldEnum | LocationProgressScalarFieldEnum[]
  }

  /**
   * LocationProgress findMany
   */
  export type LocationProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * Filter, which LocationProgresses to fetch.
     */
    where?: LocationProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationProgresses to fetch.
     */
    orderBy?: LocationProgressOrderByWithRelationInput | LocationProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationProgresses.
     */
    cursor?: LocationProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationProgresses.
     */
    skip?: number
    distinct?: LocationProgressScalarFieldEnum | LocationProgressScalarFieldEnum[]
  }

  /**
   * LocationProgress create
   */
  export type LocationProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * The data needed to create a LocationProgress.
     */
    data: XOR<LocationProgressCreateInput, LocationProgressUncheckedCreateInput>
  }

  /**
   * LocationProgress createMany
   */
  export type LocationProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationProgresses.
     */
    data: LocationProgressCreateManyInput | LocationProgressCreateManyInput[]
  }

  /**
   * LocationProgress update
   */
  export type LocationProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * The data needed to update a LocationProgress.
     */
    data: XOR<LocationProgressUpdateInput, LocationProgressUncheckedUpdateInput>
    /**
     * Choose, which LocationProgress to update.
     */
    where: LocationProgressWhereUniqueInput
  }

  /**
   * LocationProgress updateMany
   */
  export type LocationProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationProgresses.
     */
    data: XOR<LocationProgressUpdateManyMutationInput, LocationProgressUncheckedUpdateManyInput>
    /**
     * Filter which LocationProgresses to update
     */
    where?: LocationProgressWhereInput
    /**
     * Limit how many LocationProgresses to update.
     */
    limit?: number
  }

  /**
   * LocationProgress upsert
   */
  export type LocationProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * The filter to search for the LocationProgress to update in case it exists.
     */
    where: LocationProgressWhereUniqueInput
    /**
     * In case the LocationProgress found by the `where` argument doesn't exist, create a new LocationProgress with this data.
     */
    create: XOR<LocationProgressCreateInput, LocationProgressUncheckedCreateInput>
    /**
     * In case the LocationProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationProgressUpdateInput, LocationProgressUncheckedUpdateInput>
  }

  /**
   * LocationProgress delete
   */
  export type LocationProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
    /**
     * Filter which LocationProgress to delete.
     */
    where: LocationProgressWhereUniqueInput
  }

  /**
   * LocationProgress deleteMany
   */
  export type LocationProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationProgresses to delete
     */
    where?: LocationProgressWhereInput
    /**
     * Limit how many LocationProgresses to delete.
     */
    limit?: number
  }

  /**
   * LocationProgress findRaw
   */
  export type LocationProgressFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationProgress aggregateRaw
   */
  export type LocationProgressAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationProgress without action
   */
  export type LocationProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationProgress
     */
    select?: LocationProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationProgress
     */
    omit?: LocationProgressOmit<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneAvgAggregateOutputType = {
    threshold: number | null
    points: number | null
  }

  export type MilestoneSumAggregateOutputType = {
    threshold: number | null
    points: number | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    threshold: number | null
    reward: string | null
    icon: string | null
    points: number | null
    createdAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: string | null
    threshold: number | null
    reward: string | null
    icon: string | null
    points: number | null
    createdAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    threshold: number
    reward: number
    icon: number
    points: number
    createdAt: number
    _all: number
  }


  export type MilestoneAvgAggregateInputType = {
    threshold?: true
    points?: true
  }

  export type MilestoneSumAggregateInputType = {
    threshold?: true
    points?: true
  }

  export type MilestoneMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    threshold?: true
    reward?: true
    icon?: true
    points?: true
    createdAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    threshold?: true
    reward?: true
    icon?: true
    points?: true
    createdAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    threshold?: true
    reward?: true
    icon?: true
    points?: true
    createdAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _avg?: MilestoneAvgAggregateInputType
    _sum?: MilestoneSumAggregateInputType
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    name: string
    description: string
    type: string
    threshold: number
    reward: string
    icon: string | null
    points: number
    createdAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _avg: MilestoneAvgAggregateOutputType | null
    _sum: MilestoneSumAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    threshold?: boolean
    reward?: boolean
    icon?: boolean
    points?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["milestone"]>



  export type MilestoneSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    threshold?: boolean
    reward?: boolean
    icon?: boolean
    points?: boolean
    createdAt?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "threshold" | "reward" | "icon" | "points" | "createdAt", ExtArgs["result"]["milestone"]>

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: string
      threshold: number
      reward: string
      icon: string | null
      points: number
      createdAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * @param {MilestoneFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const milestone = await prisma.milestone.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MilestoneFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Milestone.
     * @param {MilestoneAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const milestone = await prisma.milestone.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MilestoneAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly type: FieldRef<"Milestone", 'String'>
    readonly threshold: FieldRef<"Milestone", 'Int'>
    readonly reward: FieldRef<"Milestone", 'String'>
    readonly icon: FieldRef<"Milestone", 'String'>
    readonly points: FieldRef<"Milestone", 'Int'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone findRaw
   */
  export type MilestoneFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Milestone aggregateRaw
   */
  export type MilestoneAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
  }


  /**
   * Model LocationMilestone
   */

  export type AggregateLocationMilestone = {
    _count: LocationMilestoneCountAggregateOutputType | null
    _avg: LocationMilestoneAvgAggregateOutputType | null
    _sum: LocationMilestoneSumAggregateOutputType | null
    _min: LocationMilestoneMinAggregateOutputType | null
    _max: LocationMilestoneMaxAggregateOutputType | null
  }

  export type LocationMilestoneAvgAggregateOutputType = {
    value: number | null
  }

  export type LocationMilestoneSumAggregateOutputType = {
    value: number | null
  }

  export type LocationMilestoneMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    milestoneId: string | null
    milestoneName: string | null
    type: string | null
    title: string | null
    description: string | null
    value: number | null
    achievedAt: Date | null
    notified: boolean | null
  }

  export type LocationMilestoneMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    milestoneId: string | null
    milestoneName: string | null
    type: string | null
    title: string | null
    description: string | null
    value: number | null
    achievedAt: Date | null
    notified: boolean | null
  }

  export type LocationMilestoneCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    milestoneId: number
    milestoneName: number
    type: number
    title: number
    description: number
    value: number
    achievedAt: number
    notified: number
    _all: number
  }


  export type LocationMilestoneAvgAggregateInputType = {
    value?: true
  }

  export type LocationMilestoneSumAggregateInputType = {
    value?: true
  }

  export type LocationMilestoneMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    milestoneId?: true
    milestoneName?: true
    type?: true
    title?: true
    description?: true
    value?: true
    achievedAt?: true
    notified?: true
  }

  export type LocationMilestoneMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    milestoneId?: true
    milestoneName?: true
    type?: true
    title?: true
    description?: true
    value?: true
    achievedAt?: true
    notified?: true
  }

  export type LocationMilestoneCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    milestoneId?: true
    milestoneName?: true
    type?: true
    title?: true
    description?: true
    value?: true
    achievedAt?: true
    notified?: true
    _all?: true
  }

  export type LocationMilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationMilestone to aggregate.
     */
    where?: LocationMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationMilestones to fetch.
     */
    orderBy?: LocationMilestoneOrderByWithRelationInput | LocationMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationMilestones
    **/
    _count?: true | LocationMilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationMilestoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationMilestoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMilestoneMaxAggregateInputType
  }

  export type GetLocationMilestoneAggregateType<T extends LocationMilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationMilestone[P]>
      : GetScalarType<T[P], AggregateLocationMilestone[P]>
  }




  export type LocationMilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationMilestoneWhereInput
    orderBy?: LocationMilestoneOrderByWithAggregationInput | LocationMilestoneOrderByWithAggregationInput[]
    by: LocationMilestoneScalarFieldEnum[] | LocationMilestoneScalarFieldEnum
    having?: LocationMilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationMilestoneCountAggregateInputType | true
    _avg?: LocationMilestoneAvgAggregateInputType
    _sum?: LocationMilestoneSumAggregateInputType
    _min?: LocationMilestoneMinAggregateInputType
    _max?: LocationMilestoneMaxAggregateInputType
  }

  export type LocationMilestoneGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    milestoneId: string
    milestoneName: string
    type: string
    title: string
    description: string
    value: number
    achievedAt: Date
    notified: boolean
    _count: LocationMilestoneCountAggregateOutputType | null
    _avg: LocationMilestoneAvgAggregateOutputType | null
    _sum: LocationMilestoneSumAggregateOutputType | null
    _min: LocationMilestoneMinAggregateOutputType | null
    _max: LocationMilestoneMaxAggregateOutputType | null
  }

  type GetLocationMilestoneGroupByPayload<T extends LocationMilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationMilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationMilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationMilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], LocationMilestoneGroupByOutputType[P]>
        }
      >
    >


  export type LocationMilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    milestoneId?: boolean
    milestoneName?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    achievedAt?: boolean
    notified?: boolean
  }, ExtArgs["result"]["locationMilestone"]>



  export type LocationMilestoneSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    milestoneId?: boolean
    milestoneName?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    achievedAt?: boolean
    notified?: boolean
  }

  export type LocationMilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "milestoneId" | "milestoneName" | "type" | "title" | "description" | "value" | "achievedAt" | "notified", ExtArgs["result"]["locationMilestone"]>

  export type $LocationMilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationMilestone"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      milestoneId: string
      milestoneName: string
      type: string
      title: string
      description: string
      value: number
      achievedAt: Date
      notified: boolean
    }, ExtArgs["result"]["locationMilestone"]>
    composites: {}
  }

  type LocationMilestoneGetPayload<S extends boolean | null | undefined | LocationMilestoneDefaultArgs> = $Result.GetResult<Prisma.$LocationMilestonePayload, S>

  type LocationMilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationMilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationMilestoneCountAggregateInputType | true
    }

  export interface LocationMilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationMilestone'], meta: { name: 'LocationMilestone' } }
    /**
     * Find zero or one LocationMilestone that matches the filter.
     * @param {LocationMilestoneFindUniqueArgs} args - Arguments to find a LocationMilestone
     * @example
     * // Get one LocationMilestone
     * const locationMilestone = await prisma.locationMilestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationMilestoneFindUniqueArgs>(args: SelectSubset<T, LocationMilestoneFindUniqueArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationMilestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationMilestoneFindUniqueOrThrowArgs} args - Arguments to find a LocationMilestone
     * @example
     * // Get one LocationMilestone
     * const locationMilestone = await prisma.locationMilestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationMilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationMilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationMilestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneFindFirstArgs} args - Arguments to find a LocationMilestone
     * @example
     * // Get one LocationMilestone
     * const locationMilestone = await prisma.locationMilestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationMilestoneFindFirstArgs>(args?: SelectSubset<T, LocationMilestoneFindFirstArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationMilestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneFindFirstOrThrowArgs} args - Arguments to find a LocationMilestone
     * @example
     * // Get one LocationMilestone
     * const locationMilestone = await prisma.locationMilestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationMilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationMilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationMilestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationMilestones
     * const locationMilestones = await prisma.locationMilestone.findMany()
     * 
     * // Get first 10 LocationMilestones
     * const locationMilestones = await prisma.locationMilestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationMilestoneWithIdOnly = await prisma.locationMilestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationMilestoneFindManyArgs>(args?: SelectSubset<T, LocationMilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationMilestone.
     * @param {LocationMilestoneCreateArgs} args - Arguments to create a LocationMilestone.
     * @example
     * // Create one LocationMilestone
     * const LocationMilestone = await prisma.locationMilestone.create({
     *   data: {
     *     // ... data to create a LocationMilestone
     *   }
     * })
     * 
     */
    create<T extends LocationMilestoneCreateArgs>(args: SelectSubset<T, LocationMilestoneCreateArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationMilestones.
     * @param {LocationMilestoneCreateManyArgs} args - Arguments to create many LocationMilestones.
     * @example
     * // Create many LocationMilestones
     * const locationMilestone = await prisma.locationMilestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationMilestoneCreateManyArgs>(args?: SelectSubset<T, LocationMilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationMilestone.
     * @param {LocationMilestoneDeleteArgs} args - Arguments to delete one LocationMilestone.
     * @example
     * // Delete one LocationMilestone
     * const LocationMilestone = await prisma.locationMilestone.delete({
     *   where: {
     *     // ... filter to delete one LocationMilestone
     *   }
     * })
     * 
     */
    delete<T extends LocationMilestoneDeleteArgs>(args: SelectSubset<T, LocationMilestoneDeleteArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationMilestone.
     * @param {LocationMilestoneUpdateArgs} args - Arguments to update one LocationMilestone.
     * @example
     * // Update one LocationMilestone
     * const locationMilestone = await prisma.locationMilestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationMilestoneUpdateArgs>(args: SelectSubset<T, LocationMilestoneUpdateArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationMilestones.
     * @param {LocationMilestoneDeleteManyArgs} args - Arguments to filter LocationMilestones to delete.
     * @example
     * // Delete a few LocationMilestones
     * const { count } = await prisma.locationMilestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationMilestoneDeleteManyArgs>(args?: SelectSubset<T, LocationMilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationMilestones
     * const locationMilestone = await prisma.locationMilestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationMilestoneUpdateManyArgs>(args: SelectSubset<T, LocationMilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationMilestone.
     * @param {LocationMilestoneUpsertArgs} args - Arguments to update or create a LocationMilestone.
     * @example
     * // Update or create a LocationMilestone
     * const locationMilestone = await prisma.locationMilestone.upsert({
     *   create: {
     *     // ... data to create a LocationMilestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationMilestone we want to update
     *   }
     * })
     */
    upsert<T extends LocationMilestoneUpsertArgs>(args: SelectSubset<T, LocationMilestoneUpsertArgs<ExtArgs>>): Prisma__LocationMilestoneClient<$Result.GetResult<Prisma.$LocationMilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationMilestones that matches the filter.
     * @param {LocationMilestoneFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const locationMilestone = await prisma.locationMilestone.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LocationMilestoneFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LocationMilestone.
     * @param {LocationMilestoneAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const locationMilestone = await prisma.locationMilestone.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocationMilestoneAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LocationMilestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneCountArgs} args - Arguments to filter LocationMilestones to count.
     * @example
     * // Count the number of LocationMilestones
     * const count = await prisma.locationMilestone.count({
     *   where: {
     *     // ... the filter for the LocationMilestones we want to count
     *   }
     * })
    **/
    count<T extends LocationMilestoneCountArgs>(
      args?: Subset<T, LocationMilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationMilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationMilestoneAggregateArgs>(args: Subset<T, LocationMilestoneAggregateArgs>): Prisma.PrismaPromise<GetLocationMilestoneAggregateType<T>>

    /**
     * Group by LocationMilestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationMilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationMilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationMilestoneGroupByArgs['orderBy'] }
        : { orderBy?: LocationMilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationMilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationMilestone model
   */
  readonly fields: LocationMilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationMilestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationMilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationMilestone model
   */
  interface LocationMilestoneFieldRefs {
    readonly id: FieldRef<"LocationMilestone", 'String'>
    readonly userId: FieldRef<"LocationMilestone", 'String'>
    readonly locationId: FieldRef<"LocationMilestone", 'String'>
    readonly milestoneId: FieldRef<"LocationMilestone", 'String'>
    readonly milestoneName: FieldRef<"LocationMilestone", 'String'>
    readonly type: FieldRef<"LocationMilestone", 'String'>
    readonly title: FieldRef<"LocationMilestone", 'String'>
    readonly description: FieldRef<"LocationMilestone", 'String'>
    readonly value: FieldRef<"LocationMilestone", 'Int'>
    readonly achievedAt: FieldRef<"LocationMilestone", 'DateTime'>
    readonly notified: FieldRef<"LocationMilestone", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * LocationMilestone findUnique
   */
  export type LocationMilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * Filter, which LocationMilestone to fetch.
     */
    where: LocationMilestoneWhereUniqueInput
  }

  /**
   * LocationMilestone findUniqueOrThrow
   */
  export type LocationMilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * Filter, which LocationMilestone to fetch.
     */
    where: LocationMilestoneWhereUniqueInput
  }

  /**
   * LocationMilestone findFirst
   */
  export type LocationMilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * Filter, which LocationMilestone to fetch.
     */
    where?: LocationMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationMilestones to fetch.
     */
    orderBy?: LocationMilestoneOrderByWithRelationInput | LocationMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationMilestones.
     */
    cursor?: LocationMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationMilestones.
     */
    distinct?: LocationMilestoneScalarFieldEnum | LocationMilestoneScalarFieldEnum[]
  }

  /**
   * LocationMilestone findFirstOrThrow
   */
  export type LocationMilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * Filter, which LocationMilestone to fetch.
     */
    where?: LocationMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationMilestones to fetch.
     */
    orderBy?: LocationMilestoneOrderByWithRelationInput | LocationMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationMilestones.
     */
    cursor?: LocationMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationMilestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationMilestones.
     */
    distinct?: LocationMilestoneScalarFieldEnum | LocationMilestoneScalarFieldEnum[]
  }

  /**
   * LocationMilestone findMany
   */
  export type LocationMilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * Filter, which LocationMilestones to fetch.
     */
    where?: LocationMilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationMilestones to fetch.
     */
    orderBy?: LocationMilestoneOrderByWithRelationInput | LocationMilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationMilestones.
     */
    cursor?: LocationMilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationMilestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationMilestones.
     */
    skip?: number
    distinct?: LocationMilestoneScalarFieldEnum | LocationMilestoneScalarFieldEnum[]
  }

  /**
   * LocationMilestone create
   */
  export type LocationMilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * The data needed to create a LocationMilestone.
     */
    data: XOR<LocationMilestoneCreateInput, LocationMilestoneUncheckedCreateInput>
  }

  /**
   * LocationMilestone createMany
   */
  export type LocationMilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationMilestones.
     */
    data: LocationMilestoneCreateManyInput | LocationMilestoneCreateManyInput[]
  }

  /**
   * LocationMilestone update
   */
  export type LocationMilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * The data needed to update a LocationMilestone.
     */
    data: XOR<LocationMilestoneUpdateInput, LocationMilestoneUncheckedUpdateInput>
    /**
     * Choose, which LocationMilestone to update.
     */
    where: LocationMilestoneWhereUniqueInput
  }

  /**
   * LocationMilestone updateMany
   */
  export type LocationMilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationMilestones.
     */
    data: XOR<LocationMilestoneUpdateManyMutationInput, LocationMilestoneUncheckedUpdateManyInput>
    /**
     * Filter which LocationMilestones to update
     */
    where?: LocationMilestoneWhereInput
    /**
     * Limit how many LocationMilestones to update.
     */
    limit?: number
  }

  /**
   * LocationMilestone upsert
   */
  export type LocationMilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * The filter to search for the LocationMilestone to update in case it exists.
     */
    where: LocationMilestoneWhereUniqueInput
    /**
     * In case the LocationMilestone found by the `where` argument doesn't exist, create a new LocationMilestone with this data.
     */
    create: XOR<LocationMilestoneCreateInput, LocationMilestoneUncheckedCreateInput>
    /**
     * In case the LocationMilestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationMilestoneUpdateInput, LocationMilestoneUncheckedUpdateInput>
  }

  /**
   * LocationMilestone delete
   */
  export type LocationMilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
    /**
     * Filter which LocationMilestone to delete.
     */
    where: LocationMilestoneWhereUniqueInput
  }

  /**
   * LocationMilestone deleteMany
   */
  export type LocationMilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationMilestones to delete
     */
    where?: LocationMilestoneWhereInput
    /**
     * Limit how many LocationMilestones to delete.
     */
    limit?: number
  }

  /**
   * LocationMilestone findRaw
   */
  export type LocationMilestoneFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationMilestone aggregateRaw
   */
  export type LocationMilestoneAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationMilestone without action
   */
  export type LocationMilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationMilestone
     */
    select?: LocationMilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationMilestone
     */
    omit?: LocationMilestoneOmit<ExtArgs> | null
  }


  /**
   * Model LocationAchievement
   */

  export type AggregateLocationAchievement = {
    _count: LocationAchievementCountAggregateOutputType | null
    _avg: LocationAchievementAvgAggregateOutputType | null
    _sum: LocationAchievementSumAggregateOutputType | null
    _min: LocationAchievementMinAggregateOutputType | null
    _max: LocationAchievementMaxAggregateOutputType | null
  }

  export type LocationAchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type LocationAchievementSumAggregateOutputType = {
    points: number | null
  }

  export type LocationAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    type: string | null
    title: string | null
    description: string | null
    points: number | null
    earnedAt: Date | null
  }

  export type LocationAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    locationId: string | null
    type: string | null
    title: string | null
    description: string | null
    points: number | null
    earnedAt: Date | null
  }

  export type LocationAchievementCountAggregateOutputType = {
    id: number
    userId: number
    locationId: number
    type: number
    title: number
    description: number
    points: number
    earnedAt: number
    _all: number
  }


  export type LocationAchievementAvgAggregateInputType = {
    points?: true
  }

  export type LocationAchievementSumAggregateInputType = {
    points?: true
  }

  export type LocationAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    type?: true
    title?: true
    description?: true
    points?: true
    earnedAt?: true
  }

  export type LocationAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    type?: true
    title?: true
    description?: true
    points?: true
    earnedAt?: true
  }

  export type LocationAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    locationId?: true
    type?: true
    title?: true
    description?: true
    points?: true
    earnedAt?: true
    _all?: true
  }

  export type LocationAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationAchievement to aggregate.
     */
    where?: LocationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAchievements to fetch.
     */
    orderBy?: LocationAchievementOrderByWithRelationInput | LocationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationAchievements
    **/
    _count?: true | LocationAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationAchievementMaxAggregateInputType
  }

  export type GetLocationAchievementAggregateType<T extends LocationAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationAchievement[P]>
      : GetScalarType<T[P], AggregateLocationAchievement[P]>
  }




  export type LocationAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationAchievementWhereInput
    orderBy?: LocationAchievementOrderByWithAggregationInput | LocationAchievementOrderByWithAggregationInput[]
    by: LocationAchievementScalarFieldEnum[] | LocationAchievementScalarFieldEnum
    having?: LocationAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationAchievementCountAggregateInputType | true
    _avg?: LocationAchievementAvgAggregateInputType
    _sum?: LocationAchievementSumAggregateInputType
    _min?: LocationAchievementMinAggregateInputType
    _max?: LocationAchievementMaxAggregateInputType
  }

  export type LocationAchievementGroupByOutputType = {
    id: string
    userId: string
    locationId: string
    type: string
    title: string
    description: string
    points: number
    earnedAt: Date
    _count: LocationAchievementCountAggregateOutputType | null
    _avg: LocationAchievementAvgAggregateOutputType | null
    _sum: LocationAchievementSumAggregateOutputType | null
    _min: LocationAchievementMinAggregateOutputType | null
    _max: LocationAchievementMaxAggregateOutputType | null
  }

  type GetLocationAchievementGroupByPayload<T extends LocationAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], LocationAchievementGroupByOutputType[P]>
        }
      >
    >


  export type LocationAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    locationId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    earnedAt?: boolean
  }, ExtArgs["result"]["locationAchievement"]>



  export type LocationAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    locationId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    points?: boolean
    earnedAt?: boolean
  }

  export type LocationAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "locationId" | "type" | "title" | "description" | "points" | "earnedAt", ExtArgs["result"]["locationAchievement"]>

  export type $LocationAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationAchievement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      locationId: string
      type: string
      title: string
      description: string
      points: number
      earnedAt: Date
    }, ExtArgs["result"]["locationAchievement"]>
    composites: {}
  }

  type LocationAchievementGetPayload<S extends boolean | null | undefined | LocationAchievementDefaultArgs> = $Result.GetResult<Prisma.$LocationAchievementPayload, S>

  type LocationAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationAchievementCountAggregateInputType | true
    }

  export interface LocationAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationAchievement'], meta: { name: 'LocationAchievement' } }
    /**
     * Find zero or one LocationAchievement that matches the filter.
     * @param {LocationAchievementFindUniqueArgs} args - Arguments to find a LocationAchievement
     * @example
     * // Get one LocationAchievement
     * const locationAchievement = await prisma.locationAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationAchievementFindUniqueArgs>(args: SelectSubset<T, LocationAchievementFindUniqueArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationAchievementFindUniqueOrThrowArgs} args - Arguments to find a LocationAchievement
     * @example
     * // Get one LocationAchievement
     * const locationAchievement = await prisma.locationAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementFindFirstArgs} args - Arguments to find a LocationAchievement
     * @example
     * // Get one LocationAchievement
     * const locationAchievement = await prisma.locationAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationAchievementFindFirstArgs>(args?: SelectSubset<T, LocationAchievementFindFirstArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementFindFirstOrThrowArgs} args - Arguments to find a LocationAchievement
     * @example
     * // Get one LocationAchievement
     * const locationAchievement = await prisma.locationAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationAchievements
     * const locationAchievements = await prisma.locationAchievement.findMany()
     * 
     * // Get first 10 LocationAchievements
     * const locationAchievements = await prisma.locationAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationAchievementWithIdOnly = await prisma.locationAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationAchievementFindManyArgs>(args?: SelectSubset<T, LocationAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationAchievement.
     * @param {LocationAchievementCreateArgs} args - Arguments to create a LocationAchievement.
     * @example
     * // Create one LocationAchievement
     * const LocationAchievement = await prisma.locationAchievement.create({
     *   data: {
     *     // ... data to create a LocationAchievement
     *   }
     * })
     * 
     */
    create<T extends LocationAchievementCreateArgs>(args: SelectSubset<T, LocationAchievementCreateArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationAchievements.
     * @param {LocationAchievementCreateManyArgs} args - Arguments to create many LocationAchievements.
     * @example
     * // Create many LocationAchievements
     * const locationAchievement = await prisma.locationAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationAchievementCreateManyArgs>(args?: SelectSubset<T, LocationAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationAchievement.
     * @param {LocationAchievementDeleteArgs} args - Arguments to delete one LocationAchievement.
     * @example
     * // Delete one LocationAchievement
     * const LocationAchievement = await prisma.locationAchievement.delete({
     *   where: {
     *     // ... filter to delete one LocationAchievement
     *   }
     * })
     * 
     */
    delete<T extends LocationAchievementDeleteArgs>(args: SelectSubset<T, LocationAchievementDeleteArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationAchievement.
     * @param {LocationAchievementUpdateArgs} args - Arguments to update one LocationAchievement.
     * @example
     * // Update one LocationAchievement
     * const locationAchievement = await prisma.locationAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationAchievementUpdateArgs>(args: SelectSubset<T, LocationAchievementUpdateArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationAchievements.
     * @param {LocationAchievementDeleteManyArgs} args - Arguments to filter LocationAchievements to delete.
     * @example
     * // Delete a few LocationAchievements
     * const { count } = await prisma.locationAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationAchievementDeleteManyArgs>(args?: SelectSubset<T, LocationAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationAchievements
     * const locationAchievement = await prisma.locationAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationAchievementUpdateManyArgs>(args: SelectSubset<T, LocationAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationAchievement.
     * @param {LocationAchievementUpsertArgs} args - Arguments to update or create a LocationAchievement.
     * @example
     * // Update or create a LocationAchievement
     * const locationAchievement = await prisma.locationAchievement.upsert({
     *   create: {
     *     // ... data to create a LocationAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationAchievement we want to update
     *   }
     * })
     */
    upsert<T extends LocationAchievementUpsertArgs>(args: SelectSubset<T, LocationAchievementUpsertArgs<ExtArgs>>): Prisma__LocationAchievementClient<$Result.GetResult<Prisma.$LocationAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationAchievements that matches the filter.
     * @param {LocationAchievementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const locationAchievement = await prisma.locationAchievement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: LocationAchievementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a LocationAchievement.
     * @param {LocationAchievementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const locationAchievement = await prisma.locationAchievement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LocationAchievementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of LocationAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementCountArgs} args - Arguments to filter LocationAchievements to count.
     * @example
     * // Count the number of LocationAchievements
     * const count = await prisma.locationAchievement.count({
     *   where: {
     *     // ... the filter for the LocationAchievements we want to count
     *   }
     * })
    **/
    count<T extends LocationAchievementCountArgs>(
      args?: Subset<T, LocationAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAchievementAggregateArgs>(args: Subset<T, LocationAchievementAggregateArgs>): Prisma.PrismaPromise<GetLocationAchievementAggregateType<T>>

    /**
     * Group by LocationAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationAchievementGroupByArgs['orderBy'] }
        : { orderBy?: LocationAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationAchievement model
   */
  readonly fields: LocationAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationAchievement model
   */
  interface LocationAchievementFieldRefs {
    readonly id: FieldRef<"LocationAchievement", 'String'>
    readonly userId: FieldRef<"LocationAchievement", 'String'>
    readonly locationId: FieldRef<"LocationAchievement", 'String'>
    readonly type: FieldRef<"LocationAchievement", 'String'>
    readonly title: FieldRef<"LocationAchievement", 'String'>
    readonly description: FieldRef<"LocationAchievement", 'String'>
    readonly points: FieldRef<"LocationAchievement", 'Int'>
    readonly earnedAt: FieldRef<"LocationAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationAchievement findUnique
   */
  export type LocationAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * Filter, which LocationAchievement to fetch.
     */
    where: LocationAchievementWhereUniqueInput
  }

  /**
   * LocationAchievement findUniqueOrThrow
   */
  export type LocationAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * Filter, which LocationAchievement to fetch.
     */
    where: LocationAchievementWhereUniqueInput
  }

  /**
   * LocationAchievement findFirst
   */
  export type LocationAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * Filter, which LocationAchievement to fetch.
     */
    where?: LocationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAchievements to fetch.
     */
    orderBy?: LocationAchievementOrderByWithRelationInput | LocationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationAchievements.
     */
    cursor?: LocationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationAchievements.
     */
    distinct?: LocationAchievementScalarFieldEnum | LocationAchievementScalarFieldEnum[]
  }

  /**
   * LocationAchievement findFirstOrThrow
   */
  export type LocationAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * Filter, which LocationAchievement to fetch.
     */
    where?: LocationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAchievements to fetch.
     */
    orderBy?: LocationAchievementOrderByWithRelationInput | LocationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationAchievements.
     */
    cursor?: LocationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationAchievements.
     */
    distinct?: LocationAchievementScalarFieldEnum | LocationAchievementScalarFieldEnum[]
  }

  /**
   * LocationAchievement findMany
   */
  export type LocationAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * Filter, which LocationAchievements to fetch.
     */
    where?: LocationAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationAchievements to fetch.
     */
    orderBy?: LocationAchievementOrderByWithRelationInput | LocationAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationAchievements.
     */
    cursor?: LocationAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationAchievements.
     */
    skip?: number
    distinct?: LocationAchievementScalarFieldEnum | LocationAchievementScalarFieldEnum[]
  }

  /**
   * LocationAchievement create
   */
  export type LocationAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * The data needed to create a LocationAchievement.
     */
    data: XOR<LocationAchievementCreateInput, LocationAchievementUncheckedCreateInput>
  }

  /**
   * LocationAchievement createMany
   */
  export type LocationAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationAchievements.
     */
    data: LocationAchievementCreateManyInput | LocationAchievementCreateManyInput[]
  }

  /**
   * LocationAchievement update
   */
  export type LocationAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * The data needed to update a LocationAchievement.
     */
    data: XOR<LocationAchievementUpdateInput, LocationAchievementUncheckedUpdateInput>
    /**
     * Choose, which LocationAchievement to update.
     */
    where: LocationAchievementWhereUniqueInput
  }

  /**
   * LocationAchievement updateMany
   */
  export type LocationAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationAchievements.
     */
    data: XOR<LocationAchievementUpdateManyMutationInput, LocationAchievementUncheckedUpdateManyInput>
    /**
     * Filter which LocationAchievements to update
     */
    where?: LocationAchievementWhereInput
    /**
     * Limit how many LocationAchievements to update.
     */
    limit?: number
  }

  /**
   * LocationAchievement upsert
   */
  export type LocationAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * The filter to search for the LocationAchievement to update in case it exists.
     */
    where: LocationAchievementWhereUniqueInput
    /**
     * In case the LocationAchievement found by the `where` argument doesn't exist, create a new LocationAchievement with this data.
     */
    create: XOR<LocationAchievementCreateInput, LocationAchievementUncheckedCreateInput>
    /**
     * In case the LocationAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationAchievementUpdateInput, LocationAchievementUncheckedUpdateInput>
  }

  /**
   * LocationAchievement delete
   */
  export type LocationAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
    /**
     * Filter which LocationAchievement to delete.
     */
    where: LocationAchievementWhereUniqueInput
  }

  /**
   * LocationAchievement deleteMany
   */
  export type LocationAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationAchievements to delete
     */
    where?: LocationAchievementWhereInput
    /**
     * Limit how many LocationAchievements to delete.
     */
    limit?: number
  }

  /**
   * LocationAchievement findRaw
   */
  export type LocationAchievementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationAchievement aggregateRaw
   */
  export type LocationAchievementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * LocationAchievement without action
   */
  export type LocationAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationAchievement
     */
    select?: LocationAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationAchievement
     */
    omit?: LocationAchievementOmit<ExtArgs> | null
  }


  /**
   * Model UserTaskRefresh
   */

  export type AggregateUserTaskRefresh = {
    _count: UserTaskRefreshCountAggregateOutputType | null
    _avg: UserTaskRefreshAvgAggregateOutputType | null
    _sum: UserTaskRefreshSumAggregateOutputType | null
    _min: UserTaskRefreshMinAggregateOutputType | null
    _max: UserTaskRefreshMaxAggregateOutputType | null
  }

  export type UserTaskRefreshAvgAggregateOutputType = {
    totalTasks: number | null
  }

  export type UserTaskRefreshSumAggregateOutputType = {
    totalTasks: number | null
  }

  export type UserTaskRefreshMinAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    refreshedAt: Date | null
    nextRefresh: Date | null
    triggeredBy: string | null
    totalTasks: number | null
  }

  export type UserTaskRefreshMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    month: string | null
    refreshedAt: Date | null
    nextRefresh: Date | null
    triggeredBy: string | null
    totalTasks: number | null
  }

  export type UserTaskRefreshCountAggregateOutputType = {
    id: number
    userId: number
    month: number
    refreshedAt: number
    nextRefresh: number
    triggeredBy: number
    totalTasks: number
    locationIds: number
    _all: number
  }


  export type UserTaskRefreshAvgAggregateInputType = {
    totalTasks?: true
  }

  export type UserTaskRefreshSumAggregateInputType = {
    totalTasks?: true
  }

  export type UserTaskRefreshMinAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    refreshedAt?: true
    nextRefresh?: true
    triggeredBy?: true
    totalTasks?: true
  }

  export type UserTaskRefreshMaxAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    refreshedAt?: true
    nextRefresh?: true
    triggeredBy?: true
    totalTasks?: true
  }

  export type UserTaskRefreshCountAggregateInputType = {
    id?: true
    userId?: true
    month?: true
    refreshedAt?: true
    nextRefresh?: true
    triggeredBy?: true
    totalTasks?: true
    locationIds?: true
    _all?: true
  }

  export type UserTaskRefreshAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTaskRefresh to aggregate.
     */
    where?: UserTaskRefreshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskRefreshes to fetch.
     */
    orderBy?: UserTaskRefreshOrderByWithRelationInput | UserTaskRefreshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTaskRefreshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskRefreshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskRefreshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTaskRefreshes
    **/
    _count?: true | UserTaskRefreshCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTaskRefreshAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTaskRefreshSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTaskRefreshMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTaskRefreshMaxAggregateInputType
  }

  export type GetUserTaskRefreshAggregateType<T extends UserTaskRefreshAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTaskRefresh]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTaskRefresh[P]>
      : GetScalarType<T[P], AggregateUserTaskRefresh[P]>
  }




  export type UserTaskRefreshGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskRefreshWhereInput
    orderBy?: UserTaskRefreshOrderByWithAggregationInput | UserTaskRefreshOrderByWithAggregationInput[]
    by: UserTaskRefreshScalarFieldEnum[] | UserTaskRefreshScalarFieldEnum
    having?: UserTaskRefreshScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTaskRefreshCountAggregateInputType | true
    _avg?: UserTaskRefreshAvgAggregateInputType
    _sum?: UserTaskRefreshSumAggregateInputType
    _min?: UserTaskRefreshMinAggregateInputType
    _max?: UserTaskRefreshMaxAggregateInputType
  }

  export type UserTaskRefreshGroupByOutputType = {
    id: string
    userId: string
    month: string
    refreshedAt: Date
    nextRefresh: Date
    triggeredBy: string | null
    totalTasks: number | null
    locationIds: string[]
    _count: UserTaskRefreshCountAggregateOutputType | null
    _avg: UserTaskRefreshAvgAggregateOutputType | null
    _sum: UserTaskRefreshSumAggregateOutputType | null
    _min: UserTaskRefreshMinAggregateOutputType | null
    _max: UserTaskRefreshMaxAggregateOutputType | null
  }

  type GetUserTaskRefreshGroupByPayload<T extends UserTaskRefreshGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTaskRefreshGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTaskRefreshGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTaskRefreshGroupByOutputType[P]>
            : GetScalarType<T[P], UserTaskRefreshGroupByOutputType[P]>
        }
      >
    >


  export type UserTaskRefreshSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    month?: boolean
    refreshedAt?: boolean
    nextRefresh?: boolean
    triggeredBy?: boolean
    totalTasks?: boolean
    locationIds?: boolean
  }, ExtArgs["result"]["userTaskRefresh"]>



  export type UserTaskRefreshSelectScalar = {
    id?: boolean
    userId?: boolean
    month?: boolean
    refreshedAt?: boolean
    nextRefresh?: boolean
    triggeredBy?: boolean
    totalTasks?: boolean
    locationIds?: boolean
  }

  export type UserTaskRefreshOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "month" | "refreshedAt" | "nextRefresh" | "triggeredBy" | "totalTasks" | "locationIds", ExtArgs["result"]["userTaskRefresh"]>

  export type $UserTaskRefreshPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTaskRefresh"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      month: string
      refreshedAt: Date
      nextRefresh: Date
      triggeredBy: string | null
      totalTasks: number | null
      locationIds: string[]
    }, ExtArgs["result"]["userTaskRefresh"]>
    composites: {}
  }

  type UserTaskRefreshGetPayload<S extends boolean | null | undefined | UserTaskRefreshDefaultArgs> = $Result.GetResult<Prisma.$UserTaskRefreshPayload, S>

  type UserTaskRefreshCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserTaskRefreshFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserTaskRefreshCountAggregateInputType | true
    }

  export interface UserTaskRefreshDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTaskRefresh'], meta: { name: 'UserTaskRefresh' } }
    /**
     * Find zero or one UserTaskRefresh that matches the filter.
     * @param {UserTaskRefreshFindUniqueArgs} args - Arguments to find a UserTaskRefresh
     * @example
     * // Get one UserTaskRefresh
     * const userTaskRefresh = await prisma.userTaskRefresh.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTaskRefreshFindUniqueArgs>(args: SelectSubset<T, UserTaskRefreshFindUniqueArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserTaskRefresh that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserTaskRefreshFindUniqueOrThrowArgs} args - Arguments to find a UserTaskRefresh
     * @example
     * // Get one UserTaskRefresh
     * const userTaskRefresh = await prisma.userTaskRefresh.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTaskRefreshFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTaskRefreshFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTaskRefresh that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshFindFirstArgs} args - Arguments to find a UserTaskRefresh
     * @example
     * // Get one UserTaskRefresh
     * const userTaskRefresh = await prisma.userTaskRefresh.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTaskRefreshFindFirstArgs>(args?: SelectSubset<T, UserTaskRefreshFindFirstArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserTaskRefresh that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshFindFirstOrThrowArgs} args - Arguments to find a UserTaskRefresh
     * @example
     * // Get one UserTaskRefresh
     * const userTaskRefresh = await prisma.userTaskRefresh.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTaskRefreshFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTaskRefreshFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTaskRefreshes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTaskRefreshes
     * const userTaskRefreshes = await prisma.userTaskRefresh.findMany()
     * 
     * // Get first 10 UserTaskRefreshes
     * const userTaskRefreshes = await prisma.userTaskRefresh.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTaskRefreshWithIdOnly = await prisma.userTaskRefresh.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTaskRefreshFindManyArgs>(args?: SelectSubset<T, UserTaskRefreshFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserTaskRefresh.
     * @param {UserTaskRefreshCreateArgs} args - Arguments to create a UserTaskRefresh.
     * @example
     * // Create one UserTaskRefresh
     * const UserTaskRefresh = await prisma.userTaskRefresh.create({
     *   data: {
     *     // ... data to create a UserTaskRefresh
     *   }
     * })
     * 
     */
    create<T extends UserTaskRefreshCreateArgs>(args: SelectSubset<T, UserTaskRefreshCreateArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserTaskRefreshes.
     * @param {UserTaskRefreshCreateManyArgs} args - Arguments to create many UserTaskRefreshes.
     * @example
     * // Create many UserTaskRefreshes
     * const userTaskRefresh = await prisma.userTaskRefresh.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTaskRefreshCreateManyArgs>(args?: SelectSubset<T, UserTaskRefreshCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTaskRefresh.
     * @param {UserTaskRefreshDeleteArgs} args - Arguments to delete one UserTaskRefresh.
     * @example
     * // Delete one UserTaskRefresh
     * const UserTaskRefresh = await prisma.userTaskRefresh.delete({
     *   where: {
     *     // ... filter to delete one UserTaskRefresh
     *   }
     * })
     * 
     */
    delete<T extends UserTaskRefreshDeleteArgs>(args: SelectSubset<T, UserTaskRefreshDeleteArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserTaskRefresh.
     * @param {UserTaskRefreshUpdateArgs} args - Arguments to update one UserTaskRefresh.
     * @example
     * // Update one UserTaskRefresh
     * const userTaskRefresh = await prisma.userTaskRefresh.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTaskRefreshUpdateArgs>(args: SelectSubset<T, UserTaskRefreshUpdateArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserTaskRefreshes.
     * @param {UserTaskRefreshDeleteManyArgs} args - Arguments to filter UserTaskRefreshes to delete.
     * @example
     * // Delete a few UserTaskRefreshes
     * const { count } = await prisma.userTaskRefresh.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTaskRefreshDeleteManyArgs>(args?: SelectSubset<T, UserTaskRefreshDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTaskRefreshes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTaskRefreshes
     * const userTaskRefresh = await prisma.userTaskRefresh.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTaskRefreshUpdateManyArgs>(args: SelectSubset<T, UserTaskRefreshUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTaskRefresh.
     * @param {UserTaskRefreshUpsertArgs} args - Arguments to update or create a UserTaskRefresh.
     * @example
     * // Update or create a UserTaskRefresh
     * const userTaskRefresh = await prisma.userTaskRefresh.upsert({
     *   create: {
     *     // ... data to create a UserTaskRefresh
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTaskRefresh we want to update
     *   }
     * })
     */
    upsert<T extends UserTaskRefreshUpsertArgs>(args: SelectSubset<T, UserTaskRefreshUpsertArgs<ExtArgs>>): Prisma__UserTaskRefreshClient<$Result.GetResult<Prisma.$UserTaskRefreshPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserTaskRefreshes that matches the filter.
     * @param {UserTaskRefreshFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const userTaskRefresh = await prisma.userTaskRefresh.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserTaskRefreshFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UserTaskRefresh.
     * @param {UserTaskRefreshAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const userTaskRefresh = await prisma.userTaskRefresh.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserTaskRefreshAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UserTaskRefreshes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshCountArgs} args - Arguments to filter UserTaskRefreshes to count.
     * @example
     * // Count the number of UserTaskRefreshes
     * const count = await prisma.userTaskRefresh.count({
     *   where: {
     *     // ... the filter for the UserTaskRefreshes we want to count
     *   }
     * })
    **/
    count<T extends UserTaskRefreshCountArgs>(
      args?: Subset<T, UserTaskRefreshCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTaskRefreshCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTaskRefresh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTaskRefreshAggregateArgs>(args: Subset<T, UserTaskRefreshAggregateArgs>): Prisma.PrismaPromise<GetUserTaskRefreshAggregateType<T>>

    /**
     * Group by UserTaskRefresh.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskRefreshGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTaskRefreshGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTaskRefreshGroupByArgs['orderBy'] }
        : { orderBy?: UserTaskRefreshGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTaskRefreshGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTaskRefreshGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTaskRefresh model
   */
  readonly fields: UserTaskRefreshFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTaskRefresh.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTaskRefreshClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTaskRefresh model
   */
  interface UserTaskRefreshFieldRefs {
    readonly id: FieldRef<"UserTaskRefresh", 'String'>
    readonly userId: FieldRef<"UserTaskRefresh", 'String'>
    readonly month: FieldRef<"UserTaskRefresh", 'String'>
    readonly refreshedAt: FieldRef<"UserTaskRefresh", 'DateTime'>
    readonly nextRefresh: FieldRef<"UserTaskRefresh", 'DateTime'>
    readonly triggeredBy: FieldRef<"UserTaskRefresh", 'String'>
    readonly totalTasks: FieldRef<"UserTaskRefresh", 'Int'>
    readonly locationIds: FieldRef<"UserTaskRefresh", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * UserTaskRefresh findUnique
   */
  export type UserTaskRefreshFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * Filter, which UserTaskRefresh to fetch.
     */
    where: UserTaskRefreshWhereUniqueInput
  }

  /**
   * UserTaskRefresh findUniqueOrThrow
   */
  export type UserTaskRefreshFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * Filter, which UserTaskRefresh to fetch.
     */
    where: UserTaskRefreshWhereUniqueInput
  }

  /**
   * UserTaskRefresh findFirst
   */
  export type UserTaskRefreshFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * Filter, which UserTaskRefresh to fetch.
     */
    where?: UserTaskRefreshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskRefreshes to fetch.
     */
    orderBy?: UserTaskRefreshOrderByWithRelationInput | UserTaskRefreshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTaskRefreshes.
     */
    cursor?: UserTaskRefreshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskRefreshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskRefreshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTaskRefreshes.
     */
    distinct?: UserTaskRefreshScalarFieldEnum | UserTaskRefreshScalarFieldEnum[]
  }

  /**
   * UserTaskRefresh findFirstOrThrow
   */
  export type UserTaskRefreshFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * Filter, which UserTaskRefresh to fetch.
     */
    where?: UserTaskRefreshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskRefreshes to fetch.
     */
    orderBy?: UserTaskRefreshOrderByWithRelationInput | UserTaskRefreshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTaskRefreshes.
     */
    cursor?: UserTaskRefreshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskRefreshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskRefreshes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTaskRefreshes.
     */
    distinct?: UserTaskRefreshScalarFieldEnum | UserTaskRefreshScalarFieldEnum[]
  }

  /**
   * UserTaskRefresh findMany
   */
  export type UserTaskRefreshFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * Filter, which UserTaskRefreshes to fetch.
     */
    where?: UserTaskRefreshWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskRefreshes to fetch.
     */
    orderBy?: UserTaskRefreshOrderByWithRelationInput | UserTaskRefreshOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTaskRefreshes.
     */
    cursor?: UserTaskRefreshWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskRefreshes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskRefreshes.
     */
    skip?: number
    distinct?: UserTaskRefreshScalarFieldEnum | UserTaskRefreshScalarFieldEnum[]
  }

  /**
   * UserTaskRefresh create
   */
  export type UserTaskRefreshCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * The data needed to create a UserTaskRefresh.
     */
    data: XOR<UserTaskRefreshCreateInput, UserTaskRefreshUncheckedCreateInput>
  }

  /**
   * UserTaskRefresh createMany
   */
  export type UserTaskRefreshCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTaskRefreshes.
     */
    data: UserTaskRefreshCreateManyInput | UserTaskRefreshCreateManyInput[]
  }

  /**
   * UserTaskRefresh update
   */
  export type UserTaskRefreshUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * The data needed to update a UserTaskRefresh.
     */
    data: XOR<UserTaskRefreshUpdateInput, UserTaskRefreshUncheckedUpdateInput>
    /**
     * Choose, which UserTaskRefresh to update.
     */
    where: UserTaskRefreshWhereUniqueInput
  }

  /**
   * UserTaskRefresh updateMany
   */
  export type UserTaskRefreshUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTaskRefreshes.
     */
    data: XOR<UserTaskRefreshUpdateManyMutationInput, UserTaskRefreshUncheckedUpdateManyInput>
    /**
     * Filter which UserTaskRefreshes to update
     */
    where?: UserTaskRefreshWhereInput
    /**
     * Limit how many UserTaskRefreshes to update.
     */
    limit?: number
  }

  /**
   * UserTaskRefresh upsert
   */
  export type UserTaskRefreshUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * The filter to search for the UserTaskRefresh to update in case it exists.
     */
    where: UserTaskRefreshWhereUniqueInput
    /**
     * In case the UserTaskRefresh found by the `where` argument doesn't exist, create a new UserTaskRefresh with this data.
     */
    create: XOR<UserTaskRefreshCreateInput, UserTaskRefreshUncheckedCreateInput>
    /**
     * In case the UserTaskRefresh was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTaskRefreshUpdateInput, UserTaskRefreshUncheckedUpdateInput>
  }

  /**
   * UserTaskRefresh delete
   */
  export type UserTaskRefreshDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
    /**
     * Filter which UserTaskRefresh to delete.
     */
    where: UserTaskRefreshWhereUniqueInput
  }

  /**
   * UserTaskRefresh deleteMany
   */
  export type UserTaskRefreshDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTaskRefreshes to delete
     */
    where?: UserTaskRefreshWhereInput
    /**
     * Limit how many UserTaskRefreshes to delete.
     */
    limit?: number
  }

  /**
   * UserTaskRefresh findRaw
   */
  export type UserTaskRefreshFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserTaskRefresh aggregateRaw
   */
  export type UserTaskRefreshAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UserTaskRefresh without action
   */
  export type UserTaskRefreshDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskRefresh
     */
    select?: UserTaskRefreshSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserTaskRefresh
     */
    omit?: UserTaskRefreshOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const VersionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    version: 'version',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VersionScalarFieldEnum = (typeof VersionScalarFieldEnum)[keyof typeof VersionScalarFieldEnum]


  export const LocationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    location_id: 'location_id',
    location_name: 'location_name',
    website: 'website',
    categories: 'categories',
    last_rank_updated: 'last_rank_updated',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type LocationsScalarFieldEnum = (typeof LocationsScalarFieldEnum)[keyof typeof LocationsScalarFieldEnum]


  export const ScheduledPostScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    summary: 'summary',
    languageCode: 'languageCode',
    topicType: 'topicType',
    mediaFormat: 'mediaFormat',
    imageUrl: 'imageUrl',
    originalImageUrl: 'originalImageUrl',
    actionType: 'actionType',
    actionUrl: 'actionUrl',
    accountId: 'accountId',
    locationId: 'locationId',
    accessToken: 'accessToken',
    scheduledAt: 'scheduledAt',
    timezone: 'timezone',
    status: 'status',
    publishedAt: 'publishedAt',
    publishedPostId: 'publishedPostId',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    maxRetries: 'maxRetries',
    viewColor: 'viewColor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type ScheduledPostScalarFieldEnum = (typeof ScheduledPostScalarFieldEnum)[keyof typeof ScheduledPostScalarFieldEnum]


  export const GmbIntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    user_id: 'user_id',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiry: 'tokenExpiry',
    accountName: 'accountName',
    accountId: 'accountId',
    clientId: 'clientId',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GmbIntegrationScalarFieldEnum = (typeof GmbIntegrationScalarFieldEnum)[keyof typeof GmbIntegrationScalarFieldEnum]


  export const CompetitorAnalysisScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    businessType: 'businessType',
    lastUpdated: 'lastUpdated',
    nextUpdate: 'nextUpdate',
    competitors: 'competitors',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompetitorAnalysisScalarFieldEnum = (typeof CompetitorAnalysisScalarFieldEnum)[keyof typeof CompetitorAnalysisScalarFieldEnum]


  export const KeywordsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    location_id: 'location_id',
    keyword: 'keyword',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type KeywordsScalarFieldEnum = (typeof KeywordsScalarFieldEnum)[keyof typeof KeywordsScalarFieldEnum]


  export const KeywordRankScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    location: 'location',
    locationId: 'locationId',
    userId: 'userId',
    targetDomain: 'targetDomain',
    rank: 'rank',
    previousRank: 'previousRank',
    rankChange: 'rankChange',
    rankChangeValue: 'rankChangeValue',
    url: 'url',
    title: 'title',
    snippet: 'snippet',
    searchResults: 'searchResults',
    totalResults: 'totalResults',
    searchTime: 'searchTime',
    batchId: 'batchId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeywordRankScalarFieldEnum = (typeof KeywordRankScalarFieldEnum)[keyof typeof KeywordRankScalarFieldEnum]


  export const KeywordTrackingScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    locationId: 'locationId',
    location: 'location',
    userId: 'userId',
    targetDomain: 'targetDomain',
    isActive: 'isActive',
    refreshRate: 'refreshRate',
    lastChecked: 'lastChecked',
    nextBatchUpdate: 'nextBatchUpdate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeywordTrackingScalarFieldEnum = (typeof KeywordTrackingScalarFieldEnum)[keyof typeof KeywordTrackingScalarFieldEnum]


  export const BatchUpdateScalarFieldEnum: {
    id: 'id',
    status: 'status',
    totalKeywords: 'totalKeywords',
    processedKeywords: 'processedKeywords',
    failedKeywords: 'failedKeywords',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchUpdateScalarFieldEnum = (typeof BatchUpdateScalarFieldEnum)[keyof typeof BatchUpdateScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    defaultLocation: 'defaultLocation',
    defaultDomain: 'defaultDomain',
    autoRefreshHours: 'autoRefreshHours',
    emailAlerts: 'emailAlerts',
    alertThreshold: 'alertThreshold',
    batchUpdateTime: 'batchUpdateTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const RankAlertScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    keyword: 'keyword',
    location: 'location',
    alertType: 'alertType',
    threshold: 'threshold',
    currentRank: 'currentRank',
    previousRank: 'previousRank',
    isRead: 'isRead',
    batchId: 'batchId',
    createdAt: 'createdAt'
  };

  export type RankAlertScalarFieldEnum = (typeof RankAlertScalarFieldEnum)[keyof typeof RankAlertScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    placeId: 'placeId',
    title: 'title',
    description: 'description',
    category: 'category',
    type: 'type',
    priority: 'priority',
    impact: 'impact',
    points: 'points',
    week: 'week',
    status: 'status',
    repeatable: 'repeatable',
    estimatedTime: 'estimatedTime',
    repeatFrequency: 'repeatFrequency',
    businessType: 'businessType',
    actionType: 'actionType',
    editableViaAPI: 'editableViaAPI',
    verificationType: 'verificationType',
    caution: 'caution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const CompletedTaskScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    placeId: 'placeId',
    title: 'title',
    description: 'description',
    category: 'category',
    type: 'type',
    priority: 'priority',
    impact: 'impact',
    points: 'points',
    repeatable: 'repeatable',
    estimatedTime: 'estimatedTime',
    week: 'week',
    month: 'month',
    repeatFrequency: 'repeatFrequency',
    businessType: 'businessType',
    actionType: 'actionType',
    editableViaAPI: 'editableViaAPI',
    verificationType: 'verificationType',
    caution: 'caution',
    completedAt: 'completedAt',
    verificationConfidence: 'verificationConfidence',
    verificationReason: 'verificationReason',
    pointsAwarded: 'pointsAwarded',
    pointsPenalty: 'pointsPenalty',
    verifiedAt: 'verifiedAt'
  };

  export type CompletedTaskScalarFieldEnum = (typeof CompletedTaskScalarFieldEnum)[keyof typeof CompletedTaskScalarFieldEnum]


  export const TaskExclusionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    month: 'month',
    taskTitle: 'taskTitle',
    taskType: 'taskType',
    category: 'category',
    reason: 'reason',
    taskId: 'taskId',
    completedTaskId: 'completedTaskId',
    excludedAt: 'excludedAt',
    expiresAt: 'expiresAt'
  };

  export type TaskExclusionScalarFieldEnum = (typeof TaskExclusionScalarFieldEnum)[keyof typeof TaskExclusionScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalPoints: 'totalPoints',
    currentLevel: 'currentLevel',
    tasksCompleted: 'tasksCompleted',
    locationsCount: 'locationsCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const LocationProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    placeId: 'placeId',
    totalPoints: 'totalPoints',
    weeklyPoints: 'weeklyPoints',
    monthlyPoints: 'monthlyPoints',
    tasksCompleted: 'tasksCompleted',
    profileScore: 'profileScore',
    engagementScore: 'engagementScore',
    contentScore: 'contentScore',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastActiveDate: 'lastActiveDate',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationProgressScalarFieldEnum = (typeof LocationProgressScalarFieldEnum)[keyof typeof LocationProgressScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    threshold: 'threshold',
    reward: 'reward',
    icon: 'icon',
    points: 'points',
    createdAt: 'createdAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const LocationMilestoneScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    milestoneId: 'milestoneId',
    milestoneName: 'milestoneName',
    type: 'type',
    title: 'title',
    description: 'description',
    value: 'value',
    achievedAt: 'achievedAt',
    notified: 'notified'
  };

  export type LocationMilestoneScalarFieldEnum = (typeof LocationMilestoneScalarFieldEnum)[keyof typeof LocationMilestoneScalarFieldEnum]


  export const LocationAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    locationId: 'locationId',
    type: 'type',
    title: 'title',
    description: 'description',
    points: 'points',
    earnedAt: 'earnedAt'
  };

  export type LocationAchievementScalarFieldEnum = (typeof LocationAchievementScalarFieldEnum)[keyof typeof LocationAchievementScalarFieldEnum]


  export const UserTaskRefreshScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    month: 'month',
    refreshedAt: 'refreshedAt',
    nextRefresh: 'nextRefresh',
    triggeredBy: 'triggeredBy',
    totalTasks: 'totalTasks',
    locationIds: 'locationIds'
  };

  export type UserTaskRefreshScalarFieldEnum = (typeof UserTaskRefreshScalarFieldEnum)[keyof typeof UserTaskRefreshScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ScheduledPostStatus'
   */
  export type EnumScheduledPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledPostStatus'>
    


  /**
   * Reference to a field of type 'ScheduledPostStatus[]'
   */
  export type ListEnumScheduledPostStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduledPostStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'RankChangeType'
   */
  export type EnumRankChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RankChangeType'>
    


  /**
   * Reference to a field of type 'RankChangeType[]'
   */
  export type ListEnumRankChangeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RankChangeType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BatchUpdateStatus'
   */
  export type EnumBatchUpdateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchUpdateStatus'>
    


  /**
   * Reference to a field of type 'BatchUpdateStatus[]'
   */
  export type ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchUpdateStatus[]'>
    


  /**
   * Reference to a field of type 'RankAlertType'
   */
  export type EnumRankAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RankAlertType'>
    


  /**
   * Reference to a field of type 'RankAlertType[]'
   */
  export type ListEnumRankAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RankAlertType[]'>
    
  /**
   * Deep Input Types
   */


  export type VersionWhereInput = {
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    id?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    version?: StringFilter<"Version"> | string
    description?: StringNullableFilter<"Version"> | string | null
    isActive?: BoolFilter<"Version"> | boolean
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
  }

  export type VersionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    version?: string
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    name?: StringFilter<"Version"> | string
    description?: StringNullableFilter<"Version"> | string | null
    isActive?: BoolFilter<"Version"> | boolean
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
  }, "id" | "version">

  export type VersionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VersionCountOrderByAggregateInput
    _max?: VersionMaxOrderByAggregateInput
    _min?: VersionMinOrderByAggregateInput
  }

  export type VersionScalarWhereWithAggregatesInput = {
    AND?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    OR?: VersionScalarWhereWithAggregatesInput[]
    NOT?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Version"> | string
    name?: StringWithAggregatesFilter<"Version"> | string
    version?: StringWithAggregatesFilter<"Version"> | string
    description?: StringNullableWithAggregatesFilter<"Version"> | string | null
    isActive?: BoolWithAggregatesFilter<"Version"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Version"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Version"> | Date | string
  }

  export type locationsWhereInput = {
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    id?: StringFilter<"locations"> | string
    user_id?: StringFilter<"locations"> | string
    location_id?: StringFilter<"locations"> | string
    location_name?: StringFilter<"locations"> | string
    website?: StringNullableFilter<"locations"> | string | null
    categories?: StringNullableFilter<"locations"> | string | null
    last_rank_updated?: DateTimeNullableFilter<"locations"> | Date | string | null
    created_at?: DateTimeFilter<"locations"> | Date | string
    updated_at?: DateTimeFilter<"locations"> | Date | string
  }

  export type locationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    location_name?: SortOrder
    website?: SortOrder
    categories?: SortOrder
    last_rank_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: locationsWhereInput | locationsWhereInput[]
    OR?: locationsWhereInput[]
    NOT?: locationsWhereInput | locationsWhereInput[]
    user_id?: StringFilter<"locations"> | string
    location_id?: StringFilter<"locations"> | string
    location_name?: StringFilter<"locations"> | string
    website?: StringNullableFilter<"locations"> | string | null
    categories?: StringNullableFilter<"locations"> | string | null
    last_rank_updated?: DateTimeNullableFilter<"locations"> | Date | string | null
    created_at?: DateTimeFilter<"locations"> | Date | string
    updated_at?: DateTimeFilter<"locations"> | Date | string
  }, "id">

  export type locationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    location_name?: SortOrder
    website?: SortOrder
    categories?: SortOrder
    last_rank_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: locationsCountOrderByAggregateInput
    _max?: locationsMaxOrderByAggregateInput
    _min?: locationsMinOrderByAggregateInput
  }

  export type locationsScalarWhereWithAggregatesInput = {
    AND?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    OR?: locationsScalarWhereWithAggregatesInput[]
    NOT?: locationsScalarWhereWithAggregatesInput | locationsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"locations"> | string
    user_id?: StringWithAggregatesFilter<"locations"> | string
    location_id?: StringWithAggregatesFilter<"locations"> | string
    location_name?: StringWithAggregatesFilter<"locations"> | string
    website?: StringNullableWithAggregatesFilter<"locations"> | string | null
    categories?: StringNullableWithAggregatesFilter<"locations"> | string | null
    last_rank_updated?: DateTimeNullableWithAggregatesFilter<"locations"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"locations"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"locations"> | Date | string
  }

  export type ScheduledPostWhereInput = {
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    id?: StringFilter<"ScheduledPost"> | string
    user_id?: StringFilter<"ScheduledPost"> | string
    summary?: StringFilter<"ScheduledPost"> | string
    languageCode?: StringFilter<"ScheduledPost"> | string
    topicType?: StringFilter<"ScheduledPost"> | string
    mediaFormat?: StringFilter<"ScheduledPost"> | string
    imageUrl?: StringFilter<"ScheduledPost"> | string
    originalImageUrl?: StringNullableFilter<"ScheduledPost"> | string | null
    actionType?: StringNullableFilter<"ScheduledPost"> | string | null
    actionUrl?: StringNullableFilter<"ScheduledPost"> | string | null
    accountId?: StringFilter<"ScheduledPost"> | string
    locationId?: StringFilter<"ScheduledPost"> | string
    accessToken?: StringFilter<"ScheduledPost"> | string
    scheduledAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    timezone?: StringNullableFilter<"ScheduledPost"> | string | null
    status?: EnumScheduledPostStatusFilter<"ScheduledPost"> | $Enums.ScheduledPostStatus
    publishedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    publishedPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    errorMessage?: StringNullableFilter<"ScheduledPost"> | string | null
    retryCount?: IntFilter<"ScheduledPost"> | number
    maxRetries?: IntFilter<"ScheduledPost"> | number
    viewColor?: StringFilter<"ScheduledPost"> | string
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    createdBy?: StringNullableFilter<"ScheduledPost"> | string | null
  }

  export type ScheduledPostOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    summary?: SortOrder
    languageCode?: SortOrder
    topicType?: SortOrder
    mediaFormat?: SortOrder
    imageUrl?: SortOrder
    originalImageUrl?: SortOrder
    actionType?: SortOrder
    actionUrl?: SortOrder
    accountId?: SortOrder
    locationId?: SortOrder
    accessToken?: SortOrder
    scheduledAt?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    publishedPostId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    viewColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ScheduledPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    OR?: ScheduledPostWhereInput[]
    NOT?: ScheduledPostWhereInput | ScheduledPostWhereInput[]
    user_id?: StringFilter<"ScheduledPost"> | string
    summary?: StringFilter<"ScheduledPost"> | string
    languageCode?: StringFilter<"ScheduledPost"> | string
    topicType?: StringFilter<"ScheduledPost"> | string
    mediaFormat?: StringFilter<"ScheduledPost"> | string
    imageUrl?: StringFilter<"ScheduledPost"> | string
    originalImageUrl?: StringNullableFilter<"ScheduledPost"> | string | null
    actionType?: StringNullableFilter<"ScheduledPost"> | string | null
    actionUrl?: StringNullableFilter<"ScheduledPost"> | string | null
    accountId?: StringFilter<"ScheduledPost"> | string
    locationId?: StringFilter<"ScheduledPost"> | string
    accessToken?: StringFilter<"ScheduledPost"> | string
    scheduledAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    timezone?: StringNullableFilter<"ScheduledPost"> | string | null
    status?: EnumScheduledPostStatusFilter<"ScheduledPost"> | $Enums.ScheduledPostStatus
    publishedAt?: DateTimeNullableFilter<"ScheduledPost"> | Date | string | null
    publishedPostId?: StringNullableFilter<"ScheduledPost"> | string | null
    errorMessage?: StringNullableFilter<"ScheduledPost"> | string | null
    retryCount?: IntFilter<"ScheduledPost"> | number
    maxRetries?: IntFilter<"ScheduledPost"> | number
    viewColor?: StringFilter<"ScheduledPost"> | string
    createdAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduledPost"> | Date | string
    createdBy?: StringNullableFilter<"ScheduledPost"> | string | null
  }, "id">

  export type ScheduledPostOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    summary?: SortOrder
    languageCode?: SortOrder
    topicType?: SortOrder
    mediaFormat?: SortOrder
    imageUrl?: SortOrder
    originalImageUrl?: SortOrder
    actionType?: SortOrder
    actionUrl?: SortOrder
    accountId?: SortOrder
    locationId?: SortOrder
    accessToken?: SortOrder
    scheduledAt?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    publishedPostId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    viewColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
    _count?: ScheduledPostCountOrderByAggregateInput
    _avg?: ScheduledPostAvgOrderByAggregateInput
    _max?: ScheduledPostMaxOrderByAggregateInput
    _min?: ScheduledPostMinOrderByAggregateInput
    _sum?: ScheduledPostSumOrderByAggregateInput
  }

  export type ScheduledPostScalarWhereWithAggregatesInput = {
    AND?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    OR?: ScheduledPostScalarWhereWithAggregatesInput[]
    NOT?: ScheduledPostScalarWhereWithAggregatesInput | ScheduledPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduledPost"> | string
    user_id?: StringWithAggregatesFilter<"ScheduledPost"> | string
    summary?: StringWithAggregatesFilter<"ScheduledPost"> | string
    languageCode?: StringWithAggregatesFilter<"ScheduledPost"> | string
    topicType?: StringWithAggregatesFilter<"ScheduledPost"> | string
    mediaFormat?: StringWithAggregatesFilter<"ScheduledPost"> | string
    imageUrl?: StringWithAggregatesFilter<"ScheduledPost"> | string
    originalImageUrl?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    actionType?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    actionUrl?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    accountId?: StringWithAggregatesFilter<"ScheduledPost"> | string
    locationId?: StringWithAggregatesFilter<"ScheduledPost"> | string
    accessToken?: StringWithAggregatesFilter<"ScheduledPost"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    timezone?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    status?: EnumScheduledPostStatusWithAggregatesFilter<"ScheduledPost"> | $Enums.ScheduledPostStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ScheduledPost"> | Date | string | null
    publishedPostId?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
    retryCount?: IntWithAggregatesFilter<"ScheduledPost"> | number
    maxRetries?: IntWithAggregatesFilter<"ScheduledPost"> | number
    viewColor?: StringWithAggregatesFilter<"ScheduledPost"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduledPost"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"ScheduledPost"> | string | null
  }

  export type GmbIntegrationWhereInput = {
    AND?: GmbIntegrationWhereInput | GmbIntegrationWhereInput[]
    OR?: GmbIntegrationWhereInput[]
    NOT?: GmbIntegrationWhereInput | GmbIntegrationWhereInput[]
    id?: StringFilter<"GmbIntegration"> | string
    userId?: StringFilter<"GmbIntegration"> | string
    user_id?: StringFilter<"GmbIntegration"> | string
    accessToken?: StringFilter<"GmbIntegration"> | string
    refreshToken?: StringNullableFilter<"GmbIntegration"> | string | null
    tokenExpiry?: DateTimeFilter<"GmbIntegration"> | Date | string
    accountName?: StringNullableFilter<"GmbIntegration"> | string | null
    accountId?: StringNullableFilter<"GmbIntegration"> | string | null
    clientId?: StringNullableFilter<"GmbIntegration"> | string | null
    isActive?: BoolFilter<"GmbIntegration"> | boolean
    createdAt?: DateTimeFilter<"GmbIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"GmbIntegration"> | Date | string
  }

  export type GmbIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    user_id?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmbIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: GmbIntegrationWhereInput | GmbIntegrationWhereInput[]
    OR?: GmbIntegrationWhereInput[]
    NOT?: GmbIntegrationWhereInput | GmbIntegrationWhereInput[]
    user_id?: StringFilter<"GmbIntegration"> | string
    accessToken?: StringFilter<"GmbIntegration"> | string
    refreshToken?: StringNullableFilter<"GmbIntegration"> | string | null
    tokenExpiry?: DateTimeFilter<"GmbIntegration"> | Date | string
    accountName?: StringNullableFilter<"GmbIntegration"> | string | null
    accountId?: StringNullableFilter<"GmbIntegration"> | string | null
    clientId?: StringNullableFilter<"GmbIntegration"> | string | null
    isActive?: BoolFilter<"GmbIntegration"> | boolean
    createdAt?: DateTimeFilter<"GmbIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"GmbIntegration"> | Date | string
  }, "id" | "userId">

  export type GmbIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    user_id?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GmbIntegrationCountOrderByAggregateInput
    _max?: GmbIntegrationMaxOrderByAggregateInput
    _min?: GmbIntegrationMinOrderByAggregateInput
  }

  export type GmbIntegrationScalarWhereWithAggregatesInput = {
    AND?: GmbIntegrationScalarWhereWithAggregatesInput | GmbIntegrationScalarWhereWithAggregatesInput[]
    OR?: GmbIntegrationScalarWhereWithAggregatesInput[]
    NOT?: GmbIntegrationScalarWhereWithAggregatesInput | GmbIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GmbIntegration"> | string
    userId?: StringWithAggregatesFilter<"GmbIntegration"> | string
    user_id?: StringWithAggregatesFilter<"GmbIntegration"> | string
    accessToken?: StringWithAggregatesFilter<"GmbIntegration"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"GmbIntegration"> | string | null
    tokenExpiry?: DateTimeWithAggregatesFilter<"GmbIntegration"> | Date | string
    accountName?: StringNullableWithAggregatesFilter<"GmbIntegration"> | string | null
    accountId?: StringNullableWithAggregatesFilter<"GmbIntegration"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"GmbIntegration"> | string | null
    isActive?: BoolWithAggregatesFilter<"GmbIntegration"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GmbIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GmbIntegration"> | Date | string
  }

  export type CompetitorAnalysisWhereInput = {
    AND?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    OR?: CompetitorAnalysisWhereInput[]
    NOT?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    id?: StringFilter<"CompetitorAnalysis"> | string
    userId?: StringFilter<"CompetitorAnalysis"> | string
    locationId?: StringFilter<"CompetitorAnalysis"> | string
    businessType?: StringFilter<"CompetitorAnalysis"> | string
    lastUpdated?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    nextUpdate?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    competitors?: JsonFilter<"CompetitorAnalysis">
    createdAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
  }

  export type CompetitorAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    businessType?: SortOrder
    lastUpdated?: SortOrder
    nextUpdate?: SortOrder
    competitors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitorAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId_businessType?: CompetitorAnalysisUserIdLocationIdBusinessTypeCompoundUniqueInput
    AND?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    OR?: CompetitorAnalysisWhereInput[]
    NOT?: CompetitorAnalysisWhereInput | CompetitorAnalysisWhereInput[]
    userId?: StringFilter<"CompetitorAnalysis"> | string
    locationId?: StringFilter<"CompetitorAnalysis"> | string
    businessType?: StringFilter<"CompetitorAnalysis"> | string
    lastUpdated?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    nextUpdate?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    competitors?: JsonFilter<"CompetitorAnalysis">
    createdAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"CompetitorAnalysis"> | Date | string
  }, "id" | "userId_locationId_businessType">

  export type CompetitorAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    businessType?: SortOrder
    lastUpdated?: SortOrder
    nextUpdate?: SortOrder
    competitors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompetitorAnalysisCountOrderByAggregateInput
    _max?: CompetitorAnalysisMaxOrderByAggregateInput
    _min?: CompetitorAnalysisMinOrderByAggregateInput
  }

  export type CompetitorAnalysisScalarWhereWithAggregatesInput = {
    AND?: CompetitorAnalysisScalarWhereWithAggregatesInput | CompetitorAnalysisScalarWhereWithAggregatesInput[]
    OR?: CompetitorAnalysisScalarWhereWithAggregatesInput[]
    NOT?: CompetitorAnalysisScalarWhereWithAggregatesInput | CompetitorAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompetitorAnalysis"> | string
    userId?: StringWithAggregatesFilter<"CompetitorAnalysis"> | string
    locationId?: StringWithAggregatesFilter<"CompetitorAnalysis"> | string
    businessType?: StringWithAggregatesFilter<"CompetitorAnalysis"> | string
    lastUpdated?: DateTimeWithAggregatesFilter<"CompetitorAnalysis"> | Date | string
    nextUpdate?: DateTimeWithAggregatesFilter<"CompetitorAnalysis"> | Date | string
    competitors?: JsonWithAggregatesFilter<"CompetitorAnalysis">
    createdAt?: DateTimeWithAggregatesFilter<"CompetitorAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompetitorAnalysis"> | Date | string
  }

  export type keywordsWhereInput = {
    AND?: keywordsWhereInput | keywordsWhereInput[]
    OR?: keywordsWhereInput[]
    NOT?: keywordsWhereInput | keywordsWhereInput[]
    id?: StringFilter<"keywords"> | string
    user_id?: StringFilter<"keywords"> | string
    location_id?: StringFilter<"keywords"> | string
    keyword?: StringNullableFilter<"keywords"> | string | null
    created_at?: DateTimeFilter<"keywords"> | Date | string
    updated_at?: DateTimeNullableFilter<"keywords"> | Date | string | null
  }

  export type keywordsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    keyword?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type keywordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: keywordsWhereInput | keywordsWhereInput[]
    OR?: keywordsWhereInput[]
    NOT?: keywordsWhereInput | keywordsWhereInput[]
    user_id?: StringFilter<"keywords"> | string
    location_id?: StringFilter<"keywords"> | string
    keyword?: StringNullableFilter<"keywords"> | string | null
    created_at?: DateTimeFilter<"keywords"> | Date | string
    updated_at?: DateTimeNullableFilter<"keywords"> | Date | string | null
  }, "id">

  export type keywordsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    keyword?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: keywordsCountOrderByAggregateInput
    _max?: keywordsMaxOrderByAggregateInput
    _min?: keywordsMinOrderByAggregateInput
  }

  export type keywordsScalarWhereWithAggregatesInput = {
    AND?: keywordsScalarWhereWithAggregatesInput | keywordsScalarWhereWithAggregatesInput[]
    OR?: keywordsScalarWhereWithAggregatesInput[]
    NOT?: keywordsScalarWhereWithAggregatesInput | keywordsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"keywords"> | string
    user_id?: StringWithAggregatesFilter<"keywords"> | string
    location_id?: StringWithAggregatesFilter<"keywords"> | string
    keyword?: StringNullableWithAggregatesFilter<"keywords"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"keywords"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"keywords"> | Date | string | null
  }

  export type KeywordRankWhereInput = {
    AND?: KeywordRankWhereInput | KeywordRankWhereInput[]
    OR?: KeywordRankWhereInput[]
    NOT?: KeywordRankWhereInput | KeywordRankWhereInput[]
    id?: StringFilter<"KeywordRank"> | string
    keyword?: StringFilter<"KeywordRank"> | string
    location?: StringFilter<"KeywordRank"> | string
    locationId?: StringFilter<"KeywordRank"> | string
    userId?: StringFilter<"KeywordRank"> | string
    targetDomain?: StringNullableFilter<"KeywordRank"> | string | null
    rank?: IntNullableFilter<"KeywordRank"> | number | null
    previousRank?: IntNullableFilter<"KeywordRank"> | number | null
    rankChange?: EnumRankChangeTypeFilter<"KeywordRank"> | $Enums.RankChangeType
    rankChangeValue?: IntFilter<"KeywordRank"> | number
    url?: StringNullableFilter<"KeywordRank"> | string | null
    title?: StringNullableFilter<"KeywordRank"> | string | null
    snippet?: StringNullableFilter<"KeywordRank"> | string | null
    searchResults?: StringNullableFilter<"KeywordRank"> | string | null
    totalResults?: BigIntFilter<"KeywordRank"> | bigint | number
    searchTime?: FloatFilter<"KeywordRank"> | number
    batchId?: StringNullableFilter<"KeywordRank"> | string | null
    createdAt?: DateTimeFilter<"KeywordRank"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordRank"> | Date | string
  }

  export type KeywordRankOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    rankChange?: SortOrder
    rankChangeValue?: SortOrder
    url?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    searchResults?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordRankWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeywordRankWhereInput | KeywordRankWhereInput[]
    OR?: KeywordRankWhereInput[]
    NOT?: KeywordRankWhereInput | KeywordRankWhereInput[]
    keyword?: StringFilter<"KeywordRank"> | string
    location?: StringFilter<"KeywordRank"> | string
    locationId?: StringFilter<"KeywordRank"> | string
    userId?: StringFilter<"KeywordRank"> | string
    targetDomain?: StringNullableFilter<"KeywordRank"> | string | null
    rank?: IntNullableFilter<"KeywordRank"> | number | null
    previousRank?: IntNullableFilter<"KeywordRank"> | number | null
    rankChange?: EnumRankChangeTypeFilter<"KeywordRank"> | $Enums.RankChangeType
    rankChangeValue?: IntFilter<"KeywordRank"> | number
    url?: StringNullableFilter<"KeywordRank"> | string | null
    title?: StringNullableFilter<"KeywordRank"> | string | null
    snippet?: StringNullableFilter<"KeywordRank"> | string | null
    searchResults?: StringNullableFilter<"KeywordRank"> | string | null
    totalResults?: BigIntFilter<"KeywordRank"> | bigint | number
    searchTime?: FloatFilter<"KeywordRank"> | number
    batchId?: StringNullableFilter<"KeywordRank"> | string | null
    createdAt?: DateTimeFilter<"KeywordRank"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordRank"> | Date | string
  }, "id">

  export type KeywordRankOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    rankChange?: SortOrder
    rankChangeValue?: SortOrder
    url?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    searchResults?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeywordRankCountOrderByAggregateInput
    _avg?: KeywordRankAvgOrderByAggregateInput
    _max?: KeywordRankMaxOrderByAggregateInput
    _min?: KeywordRankMinOrderByAggregateInput
    _sum?: KeywordRankSumOrderByAggregateInput
  }

  export type KeywordRankScalarWhereWithAggregatesInput = {
    AND?: KeywordRankScalarWhereWithAggregatesInput | KeywordRankScalarWhereWithAggregatesInput[]
    OR?: KeywordRankScalarWhereWithAggregatesInput[]
    NOT?: KeywordRankScalarWhereWithAggregatesInput | KeywordRankScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeywordRank"> | string
    keyword?: StringWithAggregatesFilter<"KeywordRank"> | string
    location?: StringWithAggregatesFilter<"KeywordRank"> | string
    locationId?: StringWithAggregatesFilter<"KeywordRank"> | string
    userId?: StringWithAggregatesFilter<"KeywordRank"> | string
    targetDomain?: StringNullableWithAggregatesFilter<"KeywordRank"> | string | null
    rank?: IntNullableWithAggregatesFilter<"KeywordRank"> | number | null
    previousRank?: IntNullableWithAggregatesFilter<"KeywordRank"> | number | null
    rankChange?: EnumRankChangeTypeWithAggregatesFilter<"KeywordRank"> | $Enums.RankChangeType
    rankChangeValue?: IntWithAggregatesFilter<"KeywordRank"> | number
    url?: StringNullableWithAggregatesFilter<"KeywordRank"> | string | null
    title?: StringNullableWithAggregatesFilter<"KeywordRank"> | string | null
    snippet?: StringNullableWithAggregatesFilter<"KeywordRank"> | string | null
    searchResults?: StringNullableWithAggregatesFilter<"KeywordRank"> | string | null
    totalResults?: BigIntWithAggregatesFilter<"KeywordRank"> | bigint | number
    searchTime?: FloatWithAggregatesFilter<"KeywordRank"> | number
    batchId?: StringNullableWithAggregatesFilter<"KeywordRank"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KeywordRank"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KeywordRank"> | Date | string
  }

  export type KeywordTrackingWhereInput = {
    AND?: KeywordTrackingWhereInput | KeywordTrackingWhereInput[]
    OR?: KeywordTrackingWhereInput[]
    NOT?: KeywordTrackingWhereInput | KeywordTrackingWhereInput[]
    id?: StringFilter<"KeywordTracking"> | string
    keyword?: StringFilter<"KeywordTracking"> | string
    locationId?: StringFilter<"KeywordTracking"> | string
    location?: StringFilter<"KeywordTracking"> | string
    userId?: StringFilter<"KeywordTracking"> | string
    targetDomain?: StringNullableFilter<"KeywordTracking"> | string | null
    isActive?: BoolFilter<"KeywordTracking"> | boolean
    refreshRate?: IntFilter<"KeywordTracking"> | number
    lastChecked?: DateTimeNullableFilter<"KeywordTracking"> | Date | string | null
    nextBatchUpdate?: DateTimeNullableFilter<"KeywordTracking"> | Date | string | null
    createdAt?: DateTimeFilter<"KeywordTracking"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordTracking"> | Date | string
  }

  export type KeywordTrackingOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    isActive?: SortOrder
    refreshRate?: SortOrder
    lastChecked?: SortOrder
    nextBatchUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KeywordTrackingWhereInput | KeywordTrackingWhereInput[]
    OR?: KeywordTrackingWhereInput[]
    NOT?: KeywordTrackingWhereInput | KeywordTrackingWhereInput[]
    keyword?: StringFilter<"KeywordTracking"> | string
    locationId?: StringFilter<"KeywordTracking"> | string
    location?: StringFilter<"KeywordTracking"> | string
    userId?: StringFilter<"KeywordTracking"> | string
    targetDomain?: StringNullableFilter<"KeywordTracking"> | string | null
    isActive?: BoolFilter<"KeywordTracking"> | boolean
    refreshRate?: IntFilter<"KeywordTracking"> | number
    lastChecked?: DateTimeNullableFilter<"KeywordTracking"> | Date | string | null
    nextBatchUpdate?: DateTimeNullableFilter<"KeywordTracking"> | Date | string | null
    createdAt?: DateTimeFilter<"KeywordTracking"> | Date | string
    updatedAt?: DateTimeFilter<"KeywordTracking"> | Date | string
  }, "id">

  export type KeywordTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    isActive?: SortOrder
    refreshRate?: SortOrder
    lastChecked?: SortOrder
    nextBatchUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeywordTrackingCountOrderByAggregateInput
    _avg?: KeywordTrackingAvgOrderByAggregateInput
    _max?: KeywordTrackingMaxOrderByAggregateInput
    _min?: KeywordTrackingMinOrderByAggregateInput
    _sum?: KeywordTrackingSumOrderByAggregateInput
  }

  export type KeywordTrackingScalarWhereWithAggregatesInput = {
    AND?: KeywordTrackingScalarWhereWithAggregatesInput | KeywordTrackingScalarWhereWithAggregatesInput[]
    OR?: KeywordTrackingScalarWhereWithAggregatesInput[]
    NOT?: KeywordTrackingScalarWhereWithAggregatesInput | KeywordTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KeywordTracking"> | string
    keyword?: StringWithAggregatesFilter<"KeywordTracking"> | string
    locationId?: StringWithAggregatesFilter<"KeywordTracking"> | string
    location?: StringWithAggregatesFilter<"KeywordTracking"> | string
    userId?: StringWithAggregatesFilter<"KeywordTracking"> | string
    targetDomain?: StringNullableWithAggregatesFilter<"KeywordTracking"> | string | null
    isActive?: BoolWithAggregatesFilter<"KeywordTracking"> | boolean
    refreshRate?: IntWithAggregatesFilter<"KeywordTracking"> | number
    lastChecked?: DateTimeNullableWithAggregatesFilter<"KeywordTracking"> | Date | string | null
    nextBatchUpdate?: DateTimeNullableWithAggregatesFilter<"KeywordTracking"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KeywordTracking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KeywordTracking"> | Date | string
  }

  export type BatchUpdateWhereInput = {
    AND?: BatchUpdateWhereInput | BatchUpdateWhereInput[]
    OR?: BatchUpdateWhereInput[]
    NOT?: BatchUpdateWhereInput | BatchUpdateWhereInput[]
    id?: StringFilter<"BatchUpdate"> | string
    status?: EnumBatchUpdateStatusFilter<"BatchUpdate"> | $Enums.BatchUpdateStatus
    totalKeywords?: IntFilter<"BatchUpdate"> | number
    processedKeywords?: IntFilter<"BatchUpdate"> | number
    failedKeywords?: IntFilter<"BatchUpdate"> | number
    startedAt?: DateTimeNullableFilter<"BatchUpdate"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BatchUpdate"> | Date | string | null
    errorMessage?: StringNullableFilter<"BatchUpdate"> | string | null
    createdAt?: DateTimeFilter<"BatchUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"BatchUpdate"> | Date | string
  }

  export type BatchUpdateOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BatchUpdateWhereInput | BatchUpdateWhereInput[]
    OR?: BatchUpdateWhereInput[]
    NOT?: BatchUpdateWhereInput | BatchUpdateWhereInput[]
    status?: EnumBatchUpdateStatusFilter<"BatchUpdate"> | $Enums.BatchUpdateStatus
    totalKeywords?: IntFilter<"BatchUpdate"> | number
    processedKeywords?: IntFilter<"BatchUpdate"> | number
    failedKeywords?: IntFilter<"BatchUpdate"> | number
    startedAt?: DateTimeNullableFilter<"BatchUpdate"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"BatchUpdate"> | Date | string | null
    errorMessage?: StringNullableFilter<"BatchUpdate"> | string | null
    createdAt?: DateTimeFilter<"BatchUpdate"> | Date | string
    updatedAt?: DateTimeFilter<"BatchUpdate"> | Date | string
  }, "id">

  export type BatchUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchUpdateCountOrderByAggregateInput
    _avg?: BatchUpdateAvgOrderByAggregateInput
    _max?: BatchUpdateMaxOrderByAggregateInput
    _min?: BatchUpdateMinOrderByAggregateInput
    _sum?: BatchUpdateSumOrderByAggregateInput
  }

  export type BatchUpdateScalarWhereWithAggregatesInput = {
    AND?: BatchUpdateScalarWhereWithAggregatesInput | BatchUpdateScalarWhereWithAggregatesInput[]
    OR?: BatchUpdateScalarWhereWithAggregatesInput[]
    NOT?: BatchUpdateScalarWhereWithAggregatesInput | BatchUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BatchUpdate"> | string
    status?: EnumBatchUpdateStatusWithAggregatesFilter<"BatchUpdate"> | $Enums.BatchUpdateStatus
    totalKeywords?: IntWithAggregatesFilter<"BatchUpdate"> | number
    processedKeywords?: IntWithAggregatesFilter<"BatchUpdate"> | number
    failedKeywords?: IntWithAggregatesFilter<"BatchUpdate"> | number
    startedAt?: DateTimeNullableWithAggregatesFilter<"BatchUpdate"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"BatchUpdate"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"BatchUpdate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BatchUpdate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BatchUpdate"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    defaultLocation?: StringFilter<"UserSettings"> | string
    defaultDomain?: StringNullableFilter<"UserSettings"> | string | null
    autoRefreshHours?: IntFilter<"UserSettings"> | number
    emailAlerts?: BoolFilter<"UserSettings"> | boolean
    alertThreshold?: IntFilter<"UserSettings"> | number
    batchUpdateTime?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultLocation?: SortOrder
    defaultDomain?: SortOrder
    autoRefreshHours?: SortOrder
    emailAlerts?: SortOrder
    alertThreshold?: SortOrder
    batchUpdateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    defaultLocation?: StringFilter<"UserSettings"> | string
    defaultDomain?: StringNullableFilter<"UserSettings"> | string | null
    autoRefreshHours?: IntFilter<"UserSettings"> | number
    emailAlerts?: BoolFilter<"UserSettings"> | boolean
    alertThreshold?: IntFilter<"UserSettings"> | number
    batchUpdateTime?: StringFilter<"UserSettings"> | string
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultLocation?: SortOrder
    defaultDomain?: SortOrder
    autoRefreshHours?: SortOrder
    emailAlerts?: SortOrder
    alertThreshold?: SortOrder
    batchUpdateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _avg?: UserSettingsAvgOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
    _sum?: UserSettingsSumOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    defaultLocation?: StringWithAggregatesFilter<"UserSettings"> | string
    defaultDomain?: StringNullableWithAggregatesFilter<"UserSettings"> | string | null
    autoRefreshHours?: IntWithAggregatesFilter<"UserSettings"> | number
    emailAlerts?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    alertThreshold?: IntWithAggregatesFilter<"UserSettings"> | number
    batchUpdateTime?: StringWithAggregatesFilter<"UserSettings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type RankAlertWhereInput = {
    AND?: RankAlertWhereInput | RankAlertWhereInput[]
    OR?: RankAlertWhereInput[]
    NOT?: RankAlertWhereInput | RankAlertWhereInput[]
    id?: StringFilter<"RankAlert"> | string
    userId?: StringFilter<"RankAlert"> | string
    keyword?: StringFilter<"RankAlert"> | string
    location?: StringFilter<"RankAlert"> | string
    alertType?: EnumRankAlertTypeFilter<"RankAlert"> | $Enums.RankAlertType
    threshold?: IntFilter<"RankAlert"> | number
    currentRank?: IntNullableFilter<"RankAlert"> | number | null
    previousRank?: IntNullableFilter<"RankAlert"> | number | null
    isRead?: BoolFilter<"RankAlert"> | boolean
    batchId?: StringNullableFilter<"RankAlert"> | string | null
    createdAt?: DateTimeFilter<"RankAlert"> | Date | string
  }

  export type RankAlertOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
    isRead?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type RankAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RankAlertWhereInput | RankAlertWhereInput[]
    OR?: RankAlertWhereInput[]
    NOT?: RankAlertWhereInput | RankAlertWhereInput[]
    userId?: StringFilter<"RankAlert"> | string
    keyword?: StringFilter<"RankAlert"> | string
    location?: StringFilter<"RankAlert"> | string
    alertType?: EnumRankAlertTypeFilter<"RankAlert"> | $Enums.RankAlertType
    threshold?: IntFilter<"RankAlert"> | number
    currentRank?: IntNullableFilter<"RankAlert"> | number | null
    previousRank?: IntNullableFilter<"RankAlert"> | number | null
    isRead?: BoolFilter<"RankAlert"> | boolean
    batchId?: StringNullableFilter<"RankAlert"> | string | null
    createdAt?: DateTimeFilter<"RankAlert"> | Date | string
  }, "id">

  export type RankAlertOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
    isRead?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    _count?: RankAlertCountOrderByAggregateInput
    _avg?: RankAlertAvgOrderByAggregateInput
    _max?: RankAlertMaxOrderByAggregateInput
    _min?: RankAlertMinOrderByAggregateInput
    _sum?: RankAlertSumOrderByAggregateInput
  }

  export type RankAlertScalarWhereWithAggregatesInput = {
    AND?: RankAlertScalarWhereWithAggregatesInput | RankAlertScalarWhereWithAggregatesInput[]
    OR?: RankAlertScalarWhereWithAggregatesInput[]
    NOT?: RankAlertScalarWhereWithAggregatesInput | RankAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RankAlert"> | string
    userId?: StringWithAggregatesFilter<"RankAlert"> | string
    keyword?: StringWithAggregatesFilter<"RankAlert"> | string
    location?: StringWithAggregatesFilter<"RankAlert"> | string
    alertType?: EnumRankAlertTypeWithAggregatesFilter<"RankAlert"> | $Enums.RankAlertType
    threshold?: IntWithAggregatesFilter<"RankAlert"> | number
    currentRank?: IntNullableWithAggregatesFilter<"RankAlert"> | number | null
    previousRank?: IntNullableWithAggregatesFilter<"RankAlert"> | number | null
    isRead?: BoolWithAggregatesFilter<"RankAlert"> | boolean
    batchId?: StringNullableWithAggregatesFilter<"RankAlert"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RankAlert"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    userId?: StringFilter<"Task"> | string
    locationId?: StringFilter<"Task"> | string
    placeId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    impact?: StringFilter<"Task"> | string
    points?: IntFilter<"Task"> | number
    week?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    repeatable?: BoolFilter<"Task"> | boolean
    estimatedTime?: StringFilter<"Task"> | string
    repeatFrequency?: StringNullableFilter<"Task"> | string | null
    businessType?: StringFilter<"Task"> | string
    actionType?: StringFilter<"Task"> | string
    editableViaAPI?: BoolFilter<"Task"> | boolean
    verificationType?: StringFilter<"Task"> | string
    caution?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    week?: SortOrder
    status?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    userId?: StringFilter<"Task"> | string
    locationId?: StringFilter<"Task"> | string
    placeId?: StringNullableFilter<"Task"> | string | null
    title?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    category?: StringFilter<"Task"> | string
    type?: StringFilter<"Task"> | string
    priority?: StringFilter<"Task"> | string
    impact?: StringFilter<"Task"> | string
    points?: IntFilter<"Task"> | number
    week?: StringFilter<"Task"> | string
    status?: StringFilter<"Task"> | string
    repeatable?: BoolFilter<"Task"> | boolean
    estimatedTime?: StringFilter<"Task"> | string
    repeatFrequency?: StringNullableFilter<"Task"> | string | null
    businessType?: StringFilter<"Task"> | string
    actionType?: StringFilter<"Task"> | string
    editableViaAPI?: BoolFilter<"Task"> | boolean
    verificationType?: StringFilter<"Task"> | string
    caution?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    week?: SortOrder
    status?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    userId?: StringWithAggregatesFilter<"Task"> | string
    locationId?: StringWithAggregatesFilter<"Task"> | string
    placeId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    category?: StringWithAggregatesFilter<"Task"> | string
    type?: StringWithAggregatesFilter<"Task"> | string
    priority?: StringWithAggregatesFilter<"Task"> | string
    impact?: StringWithAggregatesFilter<"Task"> | string
    points?: IntWithAggregatesFilter<"Task"> | number
    week?: StringWithAggregatesFilter<"Task"> | string
    status?: StringWithAggregatesFilter<"Task"> | string
    repeatable?: BoolWithAggregatesFilter<"Task"> | boolean
    estimatedTime?: StringWithAggregatesFilter<"Task"> | string
    repeatFrequency?: StringNullableWithAggregatesFilter<"Task"> | string | null
    businessType?: StringWithAggregatesFilter<"Task"> | string
    actionType?: StringWithAggregatesFilter<"Task"> | string
    editableViaAPI?: BoolWithAggregatesFilter<"Task"> | boolean
    verificationType?: StringWithAggregatesFilter<"Task"> | string
    caution?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type CompletedTaskWhereInput = {
    AND?: CompletedTaskWhereInput | CompletedTaskWhereInput[]
    OR?: CompletedTaskWhereInput[]
    NOT?: CompletedTaskWhereInput | CompletedTaskWhereInput[]
    id?: StringFilter<"CompletedTask"> | string
    userId?: StringFilter<"CompletedTask"> | string
    locationId?: StringFilter<"CompletedTask"> | string
    placeId?: StringNullableFilter<"CompletedTask"> | string | null
    title?: StringFilter<"CompletedTask"> | string
    description?: StringNullableFilter<"CompletedTask"> | string | null
    category?: StringFilter<"CompletedTask"> | string
    type?: StringFilter<"CompletedTask"> | string
    priority?: StringFilter<"CompletedTask"> | string
    impact?: StringFilter<"CompletedTask"> | string
    points?: IntFilter<"CompletedTask"> | number
    repeatable?: BoolFilter<"CompletedTask"> | boolean
    estimatedTime?: StringFilter<"CompletedTask"> | string
    week?: StringFilter<"CompletedTask"> | string
    month?: StringFilter<"CompletedTask"> | string
    repeatFrequency?: StringNullableFilter<"CompletedTask"> | string | null
    businessType?: StringFilter<"CompletedTask"> | string
    actionType?: StringFilter<"CompletedTask"> | string
    editableViaAPI?: BoolFilter<"CompletedTask"> | boolean
    verificationType?: StringFilter<"CompletedTask"> | string
    caution?: StringNullableFilter<"CompletedTask"> | string | null
    completedAt?: DateTimeFilter<"CompletedTask"> | Date | string
    verificationConfidence?: StringNullableFilter<"CompletedTask"> | string | null
    verificationReason?: StringNullableFilter<"CompletedTask"> | string | null
    pointsAwarded?: IntNullableFilter<"CompletedTask"> | number | null
    pointsPenalty?: IntNullableFilter<"CompletedTask"> | number | null
    verifiedAt?: DateTimeNullableFilter<"CompletedTask"> | Date | string | null
  }

  export type CompletedTaskOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    week?: SortOrder
    month?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    completedAt?: SortOrder
    verificationConfidence?: SortOrder
    verificationReason?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CompletedTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompletedTaskWhereInput | CompletedTaskWhereInput[]
    OR?: CompletedTaskWhereInput[]
    NOT?: CompletedTaskWhereInput | CompletedTaskWhereInput[]
    userId?: StringFilter<"CompletedTask"> | string
    locationId?: StringFilter<"CompletedTask"> | string
    placeId?: StringNullableFilter<"CompletedTask"> | string | null
    title?: StringFilter<"CompletedTask"> | string
    description?: StringNullableFilter<"CompletedTask"> | string | null
    category?: StringFilter<"CompletedTask"> | string
    type?: StringFilter<"CompletedTask"> | string
    priority?: StringFilter<"CompletedTask"> | string
    impact?: StringFilter<"CompletedTask"> | string
    points?: IntFilter<"CompletedTask"> | number
    repeatable?: BoolFilter<"CompletedTask"> | boolean
    estimatedTime?: StringFilter<"CompletedTask"> | string
    week?: StringFilter<"CompletedTask"> | string
    month?: StringFilter<"CompletedTask"> | string
    repeatFrequency?: StringNullableFilter<"CompletedTask"> | string | null
    businessType?: StringFilter<"CompletedTask"> | string
    actionType?: StringFilter<"CompletedTask"> | string
    editableViaAPI?: BoolFilter<"CompletedTask"> | boolean
    verificationType?: StringFilter<"CompletedTask"> | string
    caution?: StringNullableFilter<"CompletedTask"> | string | null
    completedAt?: DateTimeFilter<"CompletedTask"> | Date | string
    verificationConfidence?: StringNullableFilter<"CompletedTask"> | string | null
    verificationReason?: StringNullableFilter<"CompletedTask"> | string | null
    pointsAwarded?: IntNullableFilter<"CompletedTask"> | number | null
    pointsPenalty?: IntNullableFilter<"CompletedTask"> | number | null
    verifiedAt?: DateTimeNullableFilter<"CompletedTask"> | Date | string | null
  }, "id">

  export type CompletedTaskOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    week?: SortOrder
    month?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    completedAt?: SortOrder
    verificationConfidence?: SortOrder
    verificationReason?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
    verifiedAt?: SortOrder
    _count?: CompletedTaskCountOrderByAggregateInput
    _avg?: CompletedTaskAvgOrderByAggregateInput
    _max?: CompletedTaskMaxOrderByAggregateInput
    _min?: CompletedTaskMinOrderByAggregateInput
    _sum?: CompletedTaskSumOrderByAggregateInput
  }

  export type CompletedTaskScalarWhereWithAggregatesInput = {
    AND?: CompletedTaskScalarWhereWithAggregatesInput | CompletedTaskScalarWhereWithAggregatesInput[]
    OR?: CompletedTaskScalarWhereWithAggregatesInput[]
    NOT?: CompletedTaskScalarWhereWithAggregatesInput | CompletedTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompletedTask"> | string
    userId?: StringWithAggregatesFilter<"CompletedTask"> | string
    locationId?: StringWithAggregatesFilter<"CompletedTask"> | string
    placeId?: StringNullableWithAggregatesFilter<"CompletedTask"> | string | null
    title?: StringWithAggregatesFilter<"CompletedTask"> | string
    description?: StringNullableWithAggregatesFilter<"CompletedTask"> | string | null
    category?: StringWithAggregatesFilter<"CompletedTask"> | string
    type?: StringWithAggregatesFilter<"CompletedTask"> | string
    priority?: StringWithAggregatesFilter<"CompletedTask"> | string
    impact?: StringWithAggregatesFilter<"CompletedTask"> | string
    points?: IntWithAggregatesFilter<"CompletedTask"> | number
    repeatable?: BoolWithAggregatesFilter<"CompletedTask"> | boolean
    estimatedTime?: StringWithAggregatesFilter<"CompletedTask"> | string
    week?: StringWithAggregatesFilter<"CompletedTask"> | string
    month?: StringWithAggregatesFilter<"CompletedTask"> | string
    repeatFrequency?: StringNullableWithAggregatesFilter<"CompletedTask"> | string | null
    businessType?: StringWithAggregatesFilter<"CompletedTask"> | string
    actionType?: StringWithAggregatesFilter<"CompletedTask"> | string
    editableViaAPI?: BoolWithAggregatesFilter<"CompletedTask"> | boolean
    verificationType?: StringWithAggregatesFilter<"CompletedTask"> | string
    caution?: StringNullableWithAggregatesFilter<"CompletedTask"> | string | null
    completedAt?: DateTimeWithAggregatesFilter<"CompletedTask"> | Date | string
    verificationConfidence?: StringNullableWithAggregatesFilter<"CompletedTask"> | string | null
    verificationReason?: StringNullableWithAggregatesFilter<"CompletedTask"> | string | null
    pointsAwarded?: IntNullableWithAggregatesFilter<"CompletedTask"> | number | null
    pointsPenalty?: IntNullableWithAggregatesFilter<"CompletedTask"> | number | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"CompletedTask"> | Date | string | null
  }

  export type TaskExclusionWhereInput = {
    AND?: TaskExclusionWhereInput | TaskExclusionWhereInput[]
    OR?: TaskExclusionWhereInput[]
    NOT?: TaskExclusionWhereInput | TaskExclusionWhereInput[]
    id?: StringFilter<"TaskExclusion"> | string
    userId?: StringFilter<"TaskExclusion"> | string
    locationId?: StringFilter<"TaskExclusion"> | string
    month?: StringFilter<"TaskExclusion"> | string
    taskTitle?: StringFilter<"TaskExclusion"> | string
    taskType?: StringFilter<"TaskExclusion"> | string
    category?: StringFilter<"TaskExclusion"> | string
    reason?: StringFilter<"TaskExclusion"> | string
    taskId?: StringNullableFilter<"TaskExclusion"> | string | null
    completedTaskId?: StringNullableFilter<"TaskExclusion"> | string | null
    excludedAt?: DateTimeFilter<"TaskExclusion"> | Date | string
    expiresAt?: DateTimeFilter<"TaskExclusion"> | Date | string
  }

  export type TaskExclusionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    taskTitle?: SortOrder
    taskType?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    taskId?: SortOrder
    completedTaskId?: SortOrder
    excludedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TaskExclusionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId_month_taskTitle_taskType?: TaskExclusionUserIdLocationIdMonthTaskTitleTaskTypeCompoundUniqueInput
    AND?: TaskExclusionWhereInput | TaskExclusionWhereInput[]
    OR?: TaskExclusionWhereInput[]
    NOT?: TaskExclusionWhereInput | TaskExclusionWhereInput[]
    userId?: StringFilter<"TaskExclusion"> | string
    locationId?: StringFilter<"TaskExclusion"> | string
    month?: StringFilter<"TaskExclusion"> | string
    taskTitle?: StringFilter<"TaskExclusion"> | string
    taskType?: StringFilter<"TaskExclusion"> | string
    category?: StringFilter<"TaskExclusion"> | string
    reason?: StringFilter<"TaskExclusion"> | string
    taskId?: StringNullableFilter<"TaskExclusion"> | string | null
    completedTaskId?: StringNullableFilter<"TaskExclusion"> | string | null
    excludedAt?: DateTimeFilter<"TaskExclusion"> | Date | string
    expiresAt?: DateTimeFilter<"TaskExclusion"> | Date | string
  }, "id" | "userId_locationId_month_taskTitle_taskType">

  export type TaskExclusionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    taskTitle?: SortOrder
    taskType?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    taskId?: SortOrder
    completedTaskId?: SortOrder
    excludedAt?: SortOrder
    expiresAt?: SortOrder
    _count?: TaskExclusionCountOrderByAggregateInput
    _max?: TaskExclusionMaxOrderByAggregateInput
    _min?: TaskExclusionMinOrderByAggregateInput
  }

  export type TaskExclusionScalarWhereWithAggregatesInput = {
    AND?: TaskExclusionScalarWhereWithAggregatesInput | TaskExclusionScalarWhereWithAggregatesInput[]
    OR?: TaskExclusionScalarWhereWithAggregatesInput[]
    NOT?: TaskExclusionScalarWhereWithAggregatesInput | TaskExclusionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskExclusion"> | string
    userId?: StringWithAggregatesFilter<"TaskExclusion"> | string
    locationId?: StringWithAggregatesFilter<"TaskExclusion"> | string
    month?: StringWithAggregatesFilter<"TaskExclusion"> | string
    taskTitle?: StringWithAggregatesFilter<"TaskExclusion"> | string
    taskType?: StringWithAggregatesFilter<"TaskExclusion"> | string
    category?: StringWithAggregatesFilter<"TaskExclusion"> | string
    reason?: StringWithAggregatesFilter<"TaskExclusion"> | string
    taskId?: StringNullableWithAggregatesFilter<"TaskExclusion"> | string | null
    completedTaskId?: StringNullableWithAggregatesFilter<"TaskExclusion"> | string | null
    excludedAt?: DateTimeWithAggregatesFilter<"TaskExclusion"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"TaskExclusion"> | Date | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    totalPoints?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    tasksCompleted?: IntFilter<"UserProgress"> | number
    locationsCount?: IntFilter<"UserProgress"> | number
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    totalPoints?: IntFilter<"UserProgress"> | number
    currentLevel?: IntFilter<"UserProgress"> | number
    tasksCompleted?: IntFilter<"UserProgress"> | number
    locationsCount?: IntFilter<"UserProgress"> | number
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
  }, "id" | "userId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    totalPoints?: IntWithAggregatesFilter<"UserProgress"> | number
    currentLevel?: IntWithAggregatesFilter<"UserProgress"> | number
    tasksCompleted?: IntWithAggregatesFilter<"UserProgress"> | number
    locationsCount?: IntWithAggregatesFilter<"UserProgress"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type LocationProgressWhereInput = {
    AND?: LocationProgressWhereInput | LocationProgressWhereInput[]
    OR?: LocationProgressWhereInput[]
    NOT?: LocationProgressWhereInput | LocationProgressWhereInput[]
    id?: StringFilter<"LocationProgress"> | string
    userId?: StringFilter<"LocationProgress"> | string
    locationId?: StringFilter<"LocationProgress"> | string
    placeId?: StringNullableFilter<"LocationProgress"> | string | null
    totalPoints?: IntFilter<"LocationProgress"> | number
    weeklyPoints?: IntFilter<"LocationProgress"> | number
    monthlyPoints?: IntFilter<"LocationProgress"> | number
    tasksCompleted?: IntFilter<"LocationProgress"> | number
    profileScore?: IntFilter<"LocationProgress"> | number
    engagementScore?: IntFilter<"LocationProgress"> | number
    contentScore?: IntFilter<"LocationProgress"> | number
    currentStreak?: IntFilter<"LocationProgress"> | number
    longestStreak?: IntFilter<"LocationProgress"> | number
    lastActiveDate?: DateTimeFilter<"LocationProgress"> | Date | string
    level?: IntFilter<"LocationProgress"> | number
    createdAt?: DateTimeFilter<"LocationProgress"> | Date | string
    updatedAt?: DateTimeFilter<"LocationProgress"> | Date | string
  }

  export type LocationProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveDate?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId?: LocationProgressUserIdLocationIdCompoundUniqueInput
    AND?: LocationProgressWhereInput | LocationProgressWhereInput[]
    OR?: LocationProgressWhereInput[]
    NOT?: LocationProgressWhereInput | LocationProgressWhereInput[]
    userId?: StringFilter<"LocationProgress"> | string
    locationId?: StringFilter<"LocationProgress"> | string
    placeId?: StringNullableFilter<"LocationProgress"> | string | null
    totalPoints?: IntFilter<"LocationProgress"> | number
    weeklyPoints?: IntFilter<"LocationProgress"> | number
    monthlyPoints?: IntFilter<"LocationProgress"> | number
    tasksCompleted?: IntFilter<"LocationProgress"> | number
    profileScore?: IntFilter<"LocationProgress"> | number
    engagementScore?: IntFilter<"LocationProgress"> | number
    contentScore?: IntFilter<"LocationProgress"> | number
    currentStreak?: IntFilter<"LocationProgress"> | number
    longestStreak?: IntFilter<"LocationProgress"> | number
    lastActiveDate?: DateTimeFilter<"LocationProgress"> | Date | string
    level?: IntFilter<"LocationProgress"> | number
    createdAt?: DateTimeFilter<"LocationProgress"> | Date | string
    updatedAt?: DateTimeFilter<"LocationProgress"> | Date | string
  }, "id" | "userId_locationId">

  export type LocationProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveDate?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationProgressCountOrderByAggregateInput
    _avg?: LocationProgressAvgOrderByAggregateInput
    _max?: LocationProgressMaxOrderByAggregateInput
    _min?: LocationProgressMinOrderByAggregateInput
    _sum?: LocationProgressSumOrderByAggregateInput
  }

  export type LocationProgressScalarWhereWithAggregatesInput = {
    AND?: LocationProgressScalarWhereWithAggregatesInput | LocationProgressScalarWhereWithAggregatesInput[]
    OR?: LocationProgressScalarWhereWithAggregatesInput[]
    NOT?: LocationProgressScalarWhereWithAggregatesInput | LocationProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationProgress"> | string
    userId?: StringWithAggregatesFilter<"LocationProgress"> | string
    locationId?: StringWithAggregatesFilter<"LocationProgress"> | string
    placeId?: StringNullableWithAggregatesFilter<"LocationProgress"> | string | null
    totalPoints?: IntWithAggregatesFilter<"LocationProgress"> | number
    weeklyPoints?: IntWithAggregatesFilter<"LocationProgress"> | number
    monthlyPoints?: IntWithAggregatesFilter<"LocationProgress"> | number
    tasksCompleted?: IntWithAggregatesFilter<"LocationProgress"> | number
    profileScore?: IntWithAggregatesFilter<"LocationProgress"> | number
    engagementScore?: IntWithAggregatesFilter<"LocationProgress"> | number
    contentScore?: IntWithAggregatesFilter<"LocationProgress"> | number
    currentStreak?: IntWithAggregatesFilter<"LocationProgress"> | number
    longestStreak?: IntWithAggregatesFilter<"LocationProgress"> | number
    lastActiveDate?: DateTimeWithAggregatesFilter<"LocationProgress"> | Date | string
    level?: IntWithAggregatesFilter<"LocationProgress"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LocationProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocationProgress"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    threshold?: IntFilter<"Milestone"> | number
    reward?: StringFilter<"Milestone"> | string
    icon?: StringNullableFilter<"Milestone"> | string | null
    points?: IntFilter<"Milestone"> | number
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    reward?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    description?: StringFilter<"Milestone"> | string
    type?: StringFilter<"Milestone"> | string
    threshold?: IntFilter<"Milestone"> | number
    reward?: StringFilter<"Milestone"> | string
    icon?: StringNullableFilter<"Milestone"> | string | null
    points?: IntFilter<"Milestone"> | number
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
  }, "id" | "name">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    reward?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _avg?: MilestoneAvgOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
    _sum?: MilestoneSumOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    name?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringWithAggregatesFilter<"Milestone"> | string
    type?: StringWithAggregatesFilter<"Milestone"> | string
    threshold?: IntWithAggregatesFilter<"Milestone"> | number
    reward?: StringWithAggregatesFilter<"Milestone"> | string
    icon?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    points?: IntWithAggregatesFilter<"Milestone"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type LocationMilestoneWhereInput = {
    AND?: LocationMilestoneWhereInput | LocationMilestoneWhereInput[]
    OR?: LocationMilestoneWhereInput[]
    NOT?: LocationMilestoneWhereInput | LocationMilestoneWhereInput[]
    id?: StringFilter<"LocationMilestone"> | string
    userId?: StringFilter<"LocationMilestone"> | string
    locationId?: StringFilter<"LocationMilestone"> | string
    milestoneId?: StringFilter<"LocationMilestone"> | string
    milestoneName?: StringFilter<"LocationMilestone"> | string
    type?: StringFilter<"LocationMilestone"> | string
    title?: StringFilter<"LocationMilestone"> | string
    description?: StringFilter<"LocationMilestone"> | string
    value?: IntFilter<"LocationMilestone"> | number
    achievedAt?: DateTimeFilter<"LocationMilestone"> | Date | string
    notified?: BoolFilter<"LocationMilestone"> | boolean
  }

  export type LocationMilestoneOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    milestoneId?: SortOrder
    milestoneName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    achievedAt?: SortOrder
    notified?: SortOrder
  }

  export type LocationMilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId_milestoneId?: LocationMilestoneUserIdLocationIdMilestoneIdCompoundUniqueInput
    AND?: LocationMilestoneWhereInput | LocationMilestoneWhereInput[]
    OR?: LocationMilestoneWhereInput[]
    NOT?: LocationMilestoneWhereInput | LocationMilestoneWhereInput[]
    userId?: StringFilter<"LocationMilestone"> | string
    locationId?: StringFilter<"LocationMilestone"> | string
    milestoneId?: StringFilter<"LocationMilestone"> | string
    milestoneName?: StringFilter<"LocationMilestone"> | string
    type?: StringFilter<"LocationMilestone"> | string
    title?: StringFilter<"LocationMilestone"> | string
    description?: StringFilter<"LocationMilestone"> | string
    value?: IntFilter<"LocationMilestone"> | number
    achievedAt?: DateTimeFilter<"LocationMilestone"> | Date | string
    notified?: BoolFilter<"LocationMilestone"> | boolean
  }, "id" | "userId_locationId_milestoneId">

  export type LocationMilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    milestoneId?: SortOrder
    milestoneName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    achievedAt?: SortOrder
    notified?: SortOrder
    _count?: LocationMilestoneCountOrderByAggregateInput
    _avg?: LocationMilestoneAvgOrderByAggregateInput
    _max?: LocationMilestoneMaxOrderByAggregateInput
    _min?: LocationMilestoneMinOrderByAggregateInput
    _sum?: LocationMilestoneSumOrderByAggregateInput
  }

  export type LocationMilestoneScalarWhereWithAggregatesInput = {
    AND?: LocationMilestoneScalarWhereWithAggregatesInput | LocationMilestoneScalarWhereWithAggregatesInput[]
    OR?: LocationMilestoneScalarWhereWithAggregatesInput[]
    NOT?: LocationMilestoneScalarWhereWithAggregatesInput | LocationMilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationMilestone"> | string
    userId?: StringWithAggregatesFilter<"LocationMilestone"> | string
    locationId?: StringWithAggregatesFilter<"LocationMilestone"> | string
    milestoneId?: StringWithAggregatesFilter<"LocationMilestone"> | string
    milestoneName?: StringWithAggregatesFilter<"LocationMilestone"> | string
    type?: StringWithAggregatesFilter<"LocationMilestone"> | string
    title?: StringWithAggregatesFilter<"LocationMilestone"> | string
    description?: StringWithAggregatesFilter<"LocationMilestone"> | string
    value?: IntWithAggregatesFilter<"LocationMilestone"> | number
    achievedAt?: DateTimeWithAggregatesFilter<"LocationMilestone"> | Date | string
    notified?: BoolWithAggregatesFilter<"LocationMilestone"> | boolean
  }

  export type LocationAchievementWhereInput = {
    AND?: LocationAchievementWhereInput | LocationAchievementWhereInput[]
    OR?: LocationAchievementWhereInput[]
    NOT?: LocationAchievementWhereInput | LocationAchievementWhereInput[]
    id?: StringFilter<"LocationAchievement"> | string
    userId?: StringFilter<"LocationAchievement"> | string
    locationId?: StringFilter<"LocationAchievement"> | string
    type?: StringFilter<"LocationAchievement"> | string
    title?: StringFilter<"LocationAchievement"> | string
    description?: StringFilter<"LocationAchievement"> | string
    points?: IntFilter<"LocationAchievement"> | number
    earnedAt?: DateTimeFilter<"LocationAchievement"> | Date | string
  }

  export type LocationAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    earnedAt?: SortOrder
  }

  export type LocationAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_locationId_type?: LocationAchievementUserIdLocationIdTypeCompoundUniqueInput
    AND?: LocationAchievementWhereInput | LocationAchievementWhereInput[]
    OR?: LocationAchievementWhereInput[]
    NOT?: LocationAchievementWhereInput | LocationAchievementWhereInput[]
    userId?: StringFilter<"LocationAchievement"> | string
    locationId?: StringFilter<"LocationAchievement"> | string
    type?: StringFilter<"LocationAchievement"> | string
    title?: StringFilter<"LocationAchievement"> | string
    description?: StringFilter<"LocationAchievement"> | string
    points?: IntFilter<"LocationAchievement"> | number
    earnedAt?: DateTimeFilter<"LocationAchievement"> | Date | string
  }, "id" | "userId_locationId_type">

  export type LocationAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    earnedAt?: SortOrder
    _count?: LocationAchievementCountOrderByAggregateInput
    _avg?: LocationAchievementAvgOrderByAggregateInput
    _max?: LocationAchievementMaxOrderByAggregateInput
    _min?: LocationAchievementMinOrderByAggregateInput
    _sum?: LocationAchievementSumOrderByAggregateInput
  }

  export type LocationAchievementScalarWhereWithAggregatesInput = {
    AND?: LocationAchievementScalarWhereWithAggregatesInput | LocationAchievementScalarWhereWithAggregatesInput[]
    OR?: LocationAchievementScalarWhereWithAggregatesInput[]
    NOT?: LocationAchievementScalarWhereWithAggregatesInput | LocationAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationAchievement"> | string
    userId?: StringWithAggregatesFilter<"LocationAchievement"> | string
    locationId?: StringWithAggregatesFilter<"LocationAchievement"> | string
    type?: StringWithAggregatesFilter<"LocationAchievement"> | string
    title?: StringWithAggregatesFilter<"LocationAchievement"> | string
    description?: StringWithAggregatesFilter<"LocationAchievement"> | string
    points?: IntWithAggregatesFilter<"LocationAchievement"> | number
    earnedAt?: DateTimeWithAggregatesFilter<"LocationAchievement"> | Date | string
  }

  export type UserTaskRefreshWhereInput = {
    AND?: UserTaskRefreshWhereInput | UserTaskRefreshWhereInput[]
    OR?: UserTaskRefreshWhereInput[]
    NOT?: UserTaskRefreshWhereInput | UserTaskRefreshWhereInput[]
    id?: StringFilter<"UserTaskRefresh"> | string
    userId?: StringFilter<"UserTaskRefresh"> | string
    month?: StringFilter<"UserTaskRefresh"> | string
    refreshedAt?: DateTimeFilter<"UserTaskRefresh"> | Date | string
    nextRefresh?: DateTimeFilter<"UserTaskRefresh"> | Date | string
    triggeredBy?: StringNullableFilter<"UserTaskRefresh"> | string | null
    totalTasks?: IntNullableFilter<"UserTaskRefresh"> | number | null
    locationIds?: StringNullableListFilter<"UserTaskRefresh">
  }

  export type UserTaskRefreshOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    refreshedAt?: SortOrder
    nextRefresh?: SortOrder
    triggeredBy?: SortOrder
    totalTasks?: SortOrder
    locationIds?: SortOrder
  }

  export type UserTaskRefreshWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_month?: UserTaskRefreshUserIdMonthCompoundUniqueInput
    AND?: UserTaskRefreshWhereInput | UserTaskRefreshWhereInput[]
    OR?: UserTaskRefreshWhereInput[]
    NOT?: UserTaskRefreshWhereInput | UserTaskRefreshWhereInput[]
    userId?: StringFilter<"UserTaskRefresh"> | string
    month?: StringFilter<"UserTaskRefresh"> | string
    refreshedAt?: DateTimeFilter<"UserTaskRefresh"> | Date | string
    nextRefresh?: DateTimeFilter<"UserTaskRefresh"> | Date | string
    triggeredBy?: StringNullableFilter<"UserTaskRefresh"> | string | null
    totalTasks?: IntNullableFilter<"UserTaskRefresh"> | number | null
    locationIds?: StringNullableListFilter<"UserTaskRefresh">
  }, "id" | "userId_month">

  export type UserTaskRefreshOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    refreshedAt?: SortOrder
    nextRefresh?: SortOrder
    triggeredBy?: SortOrder
    totalTasks?: SortOrder
    locationIds?: SortOrder
    _count?: UserTaskRefreshCountOrderByAggregateInput
    _avg?: UserTaskRefreshAvgOrderByAggregateInput
    _max?: UserTaskRefreshMaxOrderByAggregateInput
    _min?: UserTaskRefreshMinOrderByAggregateInput
    _sum?: UserTaskRefreshSumOrderByAggregateInput
  }

  export type UserTaskRefreshScalarWhereWithAggregatesInput = {
    AND?: UserTaskRefreshScalarWhereWithAggregatesInput | UserTaskRefreshScalarWhereWithAggregatesInput[]
    OR?: UserTaskRefreshScalarWhereWithAggregatesInput[]
    NOT?: UserTaskRefreshScalarWhereWithAggregatesInput | UserTaskRefreshScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTaskRefresh"> | string
    userId?: StringWithAggregatesFilter<"UserTaskRefresh"> | string
    month?: StringWithAggregatesFilter<"UserTaskRefresh"> | string
    refreshedAt?: DateTimeWithAggregatesFilter<"UserTaskRefresh"> | Date | string
    nextRefresh?: DateTimeWithAggregatesFilter<"UserTaskRefresh"> | Date | string
    triggeredBy?: StringNullableWithAggregatesFilter<"UserTaskRefresh"> | string | null
    totalTasks?: IntNullableWithAggregatesFilter<"UserTaskRefresh"> | number | null
    locationIds?: StringNullableListFilter<"UserTaskRefresh">
  }

  export type VersionCreateInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionUncheckedCreateInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionCreateManyInput = {
    id?: string
    name: string
    version: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsCreateInput = {
    id?: string
    user_id: string
    location_id: string
    location_name: string
    website?: string | null
    categories?: string | null
    last_rank_updated?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type locationsUncheckedCreateInput = {
    id?: string
    user_id: string
    location_id: string
    location_name: string
    website?: string | null
    categories?: string | null
    last_rank_updated?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type locationsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    location_name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    last_rank_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    location_name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    last_rank_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsCreateManyInput = {
    id?: string
    user_id: string
    location_id: string
    location_name: string
    website?: string | null
    categories?: string | null
    last_rank_updated?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type locationsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    location_name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    last_rank_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type locationsUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    location_name?: StringFieldUpdateOperationsInput | string
    website?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: NullableStringFieldUpdateOperationsInput | string | null
    last_rank_updated?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduledPostCreateInput = {
    id?: string
    user_id: string
    summary: string
    languageCode?: string
    topicType?: string
    mediaFormat?: string
    imageUrl: string
    originalImageUrl?: string | null
    actionType?: string | null
    actionUrl?: string | null
    accountId: string
    locationId: string
    accessToken: string
    scheduledAt: Date | string
    timezone?: string | null
    status?: $Enums.ScheduledPostStatus
    publishedAt?: Date | string | null
    publishedPostId?: string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
    viewColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type ScheduledPostUncheckedCreateInput = {
    id?: string
    user_id: string
    summary: string
    languageCode?: string
    topicType?: string
    mediaFormat?: string
    imageUrl: string
    originalImageUrl?: string | null
    actionType?: string | null
    actionUrl?: string | null
    accountId: string
    locationId: string
    accessToken: string
    scheduledAt: Date | string
    timezone?: string | null
    status?: $Enums.ScheduledPostStatus
    publishedAt?: Date | string | null
    publishedPostId?: string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
    viewColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type ScheduledPostUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    topicType?: StringFieldUpdateOperationsInput | string
    mediaFormat?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    originalImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumScheduledPostStatusFieldUpdateOperationsInput | $Enums.ScheduledPostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    viewColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduledPostUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    topicType?: StringFieldUpdateOperationsInput | string
    mediaFormat?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    originalImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumScheduledPostStatusFieldUpdateOperationsInput | $Enums.ScheduledPostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    viewColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduledPostCreateManyInput = {
    id?: string
    user_id: string
    summary: string
    languageCode?: string
    topicType?: string
    mediaFormat?: string
    imageUrl: string
    originalImageUrl?: string | null
    actionType?: string | null
    actionUrl?: string | null
    accountId: string
    locationId: string
    accessToken: string
    scheduledAt: Date | string
    timezone?: string | null
    status?: $Enums.ScheduledPostStatus
    publishedAt?: Date | string | null
    publishedPostId?: string | null
    errorMessage?: string | null
    retryCount?: number
    maxRetries?: number
    viewColor: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type ScheduledPostUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    topicType?: StringFieldUpdateOperationsInput | string
    mediaFormat?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    originalImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumScheduledPostStatusFieldUpdateOperationsInput | $Enums.ScheduledPostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    viewColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduledPostUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    languageCode?: StringFieldUpdateOperationsInput | string
    topicType?: StringFieldUpdateOperationsInput | string
    mediaFormat?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    originalImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumScheduledPostStatusFieldUpdateOperationsInput | $Enums.ScheduledPostStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishedPostId?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    viewColor?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GmbIntegrationCreateInput = {
    id?: string
    userId: string
    user_id: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiry: Date | string
    accountName?: string | null
    accountId?: string | null
    clientId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmbIntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    user_id: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiry: Date | string
    accountName?: string | null
    accountId?: string | null
    clientId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmbIntegrationUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmbIntegrationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmbIntegrationCreateManyInput = {
    id?: string
    userId: string
    user_id: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiry: Date | string
    accountName?: string | null
    accountId?: string | null
    clientId?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GmbIntegrationUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GmbIntegrationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    accountName?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisCreateInput = {
    id?: string
    userId: string
    locationId: string
    businessType: string
    lastUpdated?: Date | string
    nextUpdate: Date | string
    competitors: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    businessType: string
    lastUpdated?: Date | string
    nextUpdate: Date | string
    competitors: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    nextUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    competitors?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    nextUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    competitors?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    businessType: string
    lastUpdated?: Date | string
    nextUpdate: Date | string
    competitors: InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompetitorAnalysisUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    nextUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    competitors?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompetitorAnalysisUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    businessType?: StringFieldUpdateOperationsInput | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    nextUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    competitors?: InputJsonValue | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type keywordsCreateInput = {
    id?: string
    user_id: string
    location_id: string
    keyword?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type keywordsUncheckedCreateInput = {
    id?: string
    user_id: string
    location_id: string
    keyword?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type keywordsUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type keywordsUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type keywordsCreateManyInput = {
    id?: string
    user_id: string
    location_id: string
    keyword?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
  }

  export type keywordsUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type keywordsUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    location_id?: StringFieldUpdateOperationsInput | string
    keyword?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KeywordRankCreateInput = {
    id?: string
    keyword: string
    location?: string
    locationId: string
    userId?: string
    targetDomain?: string | null
    rank?: number | null
    previousRank?: number | null
    rankChange?: $Enums.RankChangeType
    rankChangeValue?: number
    url?: string | null
    title?: string | null
    snippet?: string | null
    searchResults?: string | null
    totalResults?: bigint | number
    searchTime?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordRankUncheckedCreateInput = {
    id?: string
    keyword: string
    location?: string
    locationId: string
    userId?: string
    targetDomain?: string | null
    rank?: number | null
    previousRank?: number | null
    rankChange?: $Enums.RankChangeType
    rankChangeValue?: number
    url?: string | null
    title?: string | null
    snippet?: string | null
    searchResults?: string | null
    totalResults?: bigint | number
    searchTime?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordRankUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    rankChange?: EnumRankChangeTypeFieldUpdateOperationsInput | $Enums.RankChangeType
    rankChangeValue?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    searchResults?: NullableStringFieldUpdateOperationsInput | string | null
    totalResults?: BigIntFieldUpdateOperationsInput | bigint | number
    searchTime?: FloatFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordRankUncheckedUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    rankChange?: EnumRankChangeTypeFieldUpdateOperationsInput | $Enums.RankChangeType
    rankChangeValue?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    searchResults?: NullableStringFieldUpdateOperationsInput | string | null
    totalResults?: BigIntFieldUpdateOperationsInput | bigint | number
    searchTime?: FloatFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordRankCreateManyInput = {
    id?: string
    keyword: string
    location?: string
    locationId: string
    userId?: string
    targetDomain?: string | null
    rank?: number | null
    previousRank?: number | null
    rankChange?: $Enums.RankChangeType
    rankChangeValue?: number
    url?: string | null
    title?: string | null
    snippet?: string | null
    searchResults?: string | null
    totalResults?: bigint | number
    searchTime?: number
    batchId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordRankUpdateManyMutationInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    rankChange?: EnumRankChangeTypeFieldUpdateOperationsInput | $Enums.RankChangeType
    rankChangeValue?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    searchResults?: NullableStringFieldUpdateOperationsInput | string | null
    totalResults?: BigIntFieldUpdateOperationsInput | bigint | number
    searchTime?: FloatFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordRankUncheckedUpdateManyInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    rankChange?: EnumRankChangeTypeFieldUpdateOperationsInput | $Enums.RankChangeType
    rankChangeValue?: IntFieldUpdateOperationsInput | number
    url?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    searchResults?: NullableStringFieldUpdateOperationsInput | string | null
    totalResults?: BigIntFieldUpdateOperationsInput | bigint | number
    searchTime?: FloatFieldUpdateOperationsInput | number
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordTrackingCreateInput = {
    id?: string
    keyword: string
    locationId?: string
    location?: string
    userId?: string
    targetDomain?: string | null
    isActive?: boolean
    refreshRate?: number
    lastChecked?: Date | string | null
    nextBatchUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordTrackingUncheckedCreateInput = {
    id?: string
    keyword: string
    locationId?: string
    location?: string
    userId?: string
    targetDomain?: string | null
    isActive?: boolean
    refreshRate?: number
    lastChecked?: Date | string | null
    nextBatchUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordTrackingUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshRate?: IntFieldUpdateOperationsInput | number
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBatchUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordTrackingUncheckedUpdateInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshRate?: IntFieldUpdateOperationsInput | number
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBatchUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordTrackingCreateManyInput = {
    id?: string
    keyword: string
    locationId?: string
    location?: string
    userId?: string
    targetDomain?: string | null
    isActive?: boolean
    refreshRate?: number
    lastChecked?: Date | string | null
    nextBatchUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordTrackingUpdateManyMutationInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshRate?: IntFieldUpdateOperationsInput | number
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBatchUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordTrackingUncheckedUpdateManyInput = {
    keyword?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    targetDomain?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    refreshRate?: IntFieldUpdateOperationsInput | number
    lastChecked?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextBatchUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateCreateInput = {
    id?: string
    status?: $Enums.BatchUpdateStatus
    totalKeywords?: number
    processedKeywords?: number
    failedKeywords?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateUncheckedCreateInput = {
    id?: string
    status?: $Enums.BatchUpdateStatus
    totalKeywords?: number
    processedKeywords?: number
    failedKeywords?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateUpdateInput = {
    status?: EnumBatchUpdateStatusFieldUpdateOperationsInput | $Enums.BatchUpdateStatus
    totalKeywords?: IntFieldUpdateOperationsInput | number
    processedKeywords?: IntFieldUpdateOperationsInput | number
    failedKeywords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateUncheckedUpdateInput = {
    status?: EnumBatchUpdateStatusFieldUpdateOperationsInput | $Enums.BatchUpdateStatus
    totalKeywords?: IntFieldUpdateOperationsInput | number
    processedKeywords?: IntFieldUpdateOperationsInput | number
    failedKeywords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateCreateManyInput = {
    id?: string
    status?: $Enums.BatchUpdateStatus
    totalKeywords?: number
    processedKeywords?: number
    failedKeywords?: number
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BatchUpdateUpdateManyMutationInput = {
    status?: EnumBatchUpdateStatusFieldUpdateOperationsInput | $Enums.BatchUpdateStatus
    totalKeywords?: IntFieldUpdateOperationsInput | number
    processedKeywords?: IntFieldUpdateOperationsInput | number
    failedKeywords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchUpdateUncheckedUpdateManyInput = {
    status?: EnumBatchUpdateStatusFieldUpdateOperationsInput | $Enums.BatchUpdateStatus
    totalKeywords?: IntFieldUpdateOperationsInput | number
    processedKeywords?: IntFieldUpdateOperationsInput | number
    failedKeywords?: IntFieldUpdateOperationsInput | number
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    userId: string
    defaultLocation?: string
    defaultDomain?: string | null
    autoRefreshHours?: number
    emailAlerts?: boolean
    alertThreshold?: number
    batchUpdateTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    defaultLocation?: string
    defaultDomain?: string | null
    autoRefreshHours?: number
    emailAlerts?: boolean
    alertThreshold?: number
    batchUpdateTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    defaultLocation?: StringFieldUpdateOperationsInput | string
    defaultDomain?: NullableStringFieldUpdateOperationsInput | string | null
    autoRefreshHours?: IntFieldUpdateOperationsInput | number
    emailAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    batchUpdateTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    defaultLocation?: StringFieldUpdateOperationsInput | string
    defaultDomain?: NullableStringFieldUpdateOperationsInput | string | null
    autoRefreshHours?: IntFieldUpdateOperationsInput | number
    emailAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    batchUpdateTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    defaultLocation?: string
    defaultDomain?: string | null
    autoRefreshHours?: number
    emailAlerts?: boolean
    alertThreshold?: number
    batchUpdateTime?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    defaultLocation?: StringFieldUpdateOperationsInput | string
    defaultDomain?: NullableStringFieldUpdateOperationsInput | string | null
    autoRefreshHours?: IntFieldUpdateOperationsInput | number
    emailAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    batchUpdateTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    defaultLocation?: StringFieldUpdateOperationsInput | string
    defaultDomain?: NullableStringFieldUpdateOperationsInput | string | null
    autoRefreshHours?: IntFieldUpdateOperationsInput | number
    emailAlerts?: BoolFieldUpdateOperationsInput | boolean
    alertThreshold?: IntFieldUpdateOperationsInput | number
    batchUpdateTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankAlertCreateInput = {
    id?: string
    userId: string
    keyword: string
    location: string
    alertType: $Enums.RankAlertType
    threshold: number
    currentRank?: number | null
    previousRank?: number | null
    isRead?: boolean
    batchId?: string | null
    createdAt?: Date | string
  }

  export type RankAlertUncheckedCreateInput = {
    id?: string
    userId: string
    keyword: string
    location: string
    alertType: $Enums.RankAlertType
    threshold: number
    currentRank?: number | null
    previousRank?: number | null
    isRead?: boolean
    batchId?: string | null
    createdAt?: Date | string
  }

  export type RankAlertUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    alertType?: EnumRankAlertTypeFieldUpdateOperationsInput | $Enums.RankAlertType
    threshold?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankAlertUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    alertType?: EnumRankAlertTypeFieldUpdateOperationsInput | $Enums.RankAlertType
    threshold?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankAlertCreateManyInput = {
    id?: string
    userId: string
    keyword: string
    location: string
    alertType: $Enums.RankAlertType
    threshold: number
    currentRank?: number | null
    previousRank?: number | null
    isRead?: boolean
    batchId?: string | null
    createdAt?: Date | string
  }

  export type RankAlertUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    alertType?: EnumRankAlertTypeFieldUpdateOperationsInput | $Enums.RankAlertType
    threshold?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RankAlertUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    alertType?: EnumRankAlertTypeFieldUpdateOperationsInput | $Enums.RankAlertType
    threshold?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    batchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    title: string
    description: string
    category: string
    type: string
    priority: string
    impact: string
    points?: number
    week: string
    status?: string
    repeatable?: boolean
    estimatedTime: string
    repeatFrequency?: string | null
    businessType?: string
    actionType: string
    editableViaAPI?: boolean
    verificationType?: string
    caution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    title: string
    description: string
    category: string
    type: string
    priority: string
    impact: string
    points?: number
    week: string
    status?: string
    repeatable?: boolean
    estimatedTime: string
    repeatFrequency?: string | null
    businessType?: string
    actionType: string
    editableViaAPI?: boolean
    verificationType?: string
    caution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    week?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    week?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    title: string
    description: string
    category: string
    type: string
    priority: string
    impact: string
    points?: number
    week: string
    status?: string
    repeatable?: boolean
    estimatedTime: string
    repeatFrequency?: string | null
    businessType?: string
    actionType: string
    editableViaAPI?: boolean
    verificationType?: string
    caution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    week?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    week?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompletedTaskCreateInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    title: string
    description?: string | null
    category: string
    type: string
    priority: string
    impact: string
    points: number
    repeatable: boolean
    estimatedTime: string
    week: string
    month: string
    repeatFrequency?: string | null
    businessType: string
    actionType: string
    editableViaAPI: boolean
    verificationType: string
    caution?: string | null
    completedAt?: Date | string
    verificationConfidence?: string | null
    verificationReason?: string | null
    pointsAwarded?: number | null
    pointsPenalty?: number | null
    verifiedAt?: Date | string | null
  }

  export type CompletedTaskUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    title: string
    description?: string | null
    category: string
    type: string
    priority: string
    impact: string
    points: number
    repeatable: boolean
    estimatedTime: string
    week: string
    month: string
    repeatFrequency?: string | null
    businessType: string
    actionType: string
    editableViaAPI: boolean
    verificationType: string
    caution?: string | null
    completedAt?: Date | string
    verificationConfidence?: string | null
    verificationReason?: string | null
    pointsAwarded?: number | null
    pointsPenalty?: number | null
    verifiedAt?: Date | string | null
  }

  export type CompletedTaskUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationConfidence?: NullableStringFieldUpdateOperationsInput | string | null
    verificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    pointsPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompletedTaskUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationConfidence?: NullableStringFieldUpdateOperationsInput | string | null
    verificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    pointsPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompletedTaskCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    title: string
    description?: string | null
    category: string
    type: string
    priority: string
    impact: string
    points: number
    repeatable: boolean
    estimatedTime: string
    week: string
    month: string
    repeatFrequency?: string | null
    businessType: string
    actionType: string
    editableViaAPI: boolean
    verificationType: string
    caution?: string | null
    completedAt?: Date | string
    verificationConfidence?: string | null
    verificationReason?: string | null
    pointsAwarded?: number | null
    pointsPenalty?: number | null
    verifiedAt?: Date | string | null
  }

  export type CompletedTaskUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationConfidence?: NullableStringFieldUpdateOperationsInput | string | null
    verificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    pointsPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CompletedTaskUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    repeatable?: BoolFieldUpdateOperationsInput | boolean
    estimatedTime?: StringFieldUpdateOperationsInput | string
    week?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    repeatFrequency?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: StringFieldUpdateOperationsInput | string
    actionType?: StringFieldUpdateOperationsInput | string
    editableViaAPI?: BoolFieldUpdateOperationsInput | boolean
    verificationType?: StringFieldUpdateOperationsInput | string
    caution?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationConfidence?: NullableStringFieldUpdateOperationsInput | string | null
    verificationReason?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    pointsPenalty?: NullableIntFieldUpdateOperationsInput | number | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TaskExclusionCreateInput = {
    id?: string
    userId: string
    locationId: string
    month: string
    taskTitle: string
    taskType: string
    category: string
    reason: string
    taskId?: string | null
    completedTaskId?: string | null
    excludedAt?: Date | string
    expiresAt: Date | string
  }

  export type TaskExclusionUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    month: string
    taskTitle: string
    taskType: string
    category: string
    reason: string
    taskId?: string | null
    completedTaskId?: string | null
    excludedAt?: Date | string
    expiresAt: Date | string
  }

  export type TaskExclusionUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    taskTitle?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    excludedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskExclusionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    taskTitle?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    excludedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskExclusionCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    month: string
    taskTitle: string
    taskType: string
    category: string
    reason: string
    taskId?: string | null
    completedTaskId?: string | null
    excludedAt?: Date | string
    expiresAt: Date | string
  }

  export type TaskExclusionUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    taskTitle?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    excludedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskExclusionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    taskTitle?: StringFieldUpdateOperationsInput | string
    taskType?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    taskId?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskId?: NullableStringFieldUpdateOperationsInput | string | null
    excludedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateInput = {
    id?: string
    userId: string
    totalPoints?: number
    currentLevel?: number
    tasksCompleted?: number
    locationsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    totalPoints?: number
    currentLevel?: number
    tasksCompleted?: number
    locationsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    locationsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    locationsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    totalPoints?: number
    currentLevel?: number
    tasksCompleted?: number
    locationsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    locationsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentLevel?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    locationsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationProgressCreateInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    totalPoints?: number
    weeklyPoints?: number
    monthlyPoints?: number
    tasksCompleted?: number
    profileScore?: number
    engagementScore?: number
    contentScore?: number
    currentStreak?: number
    longestStreak?: number
    lastActiveDate?: Date | string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationProgressUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    totalPoints?: number
    weeklyPoints?: number
    monthlyPoints?: number
    tasksCompleted?: number
    profileScore?: number
    engagementScore?: number
    contentScore?: number
    currentStreak?: number
    longestStreak?: number
    lastActiveDate?: Date | string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationProgressUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    weeklyPoints?: IntFieldUpdateOperationsInput | number
    monthlyPoints?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    profileScore?: IntFieldUpdateOperationsInput | number
    engagementScore?: IntFieldUpdateOperationsInput | number
    contentScore?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationProgressUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    weeklyPoints?: IntFieldUpdateOperationsInput | number
    monthlyPoints?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    profileScore?: IntFieldUpdateOperationsInput | number
    engagementScore?: IntFieldUpdateOperationsInput | number
    contentScore?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationProgressCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    placeId?: string | null
    totalPoints?: number
    weeklyPoints?: number
    monthlyPoints?: number
    tasksCompleted?: number
    profileScore?: number
    engagementScore?: number
    contentScore?: number
    currentStreak?: number
    longestStreak?: number
    lastActiveDate?: Date | string
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationProgressUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    weeklyPoints?: IntFieldUpdateOperationsInput | number
    monthlyPoints?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    profileScore?: IntFieldUpdateOperationsInput | number
    engagementScore?: IntFieldUpdateOperationsInput | number
    contentScore?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationProgressUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    placeId?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    weeklyPoints?: IntFieldUpdateOperationsInput | number
    monthlyPoints?: IntFieldUpdateOperationsInput | number
    tasksCompleted?: IntFieldUpdateOperationsInput | number
    profileScore?: IntFieldUpdateOperationsInput | number
    engagementScore?: IntFieldUpdateOperationsInput | number
    contentScore?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastActiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    id?: string
    name: string
    description: string
    type: string
    threshold: number
    reward: string
    icon?: string | null
    points?: number
    createdAt?: Date | string
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: string
    threshold: number
    reward: string
    icon?: string | null
    points?: number
    createdAt?: Date | string
  }

  export type MilestoneUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    threshold?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    threshold?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateManyInput = {
    id?: string
    name: string
    description: string
    type: string
    threshold: number
    reward: string
    icon?: string | null
    points?: number
    createdAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    threshold?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    threshold?: IntFieldUpdateOperationsInput | number
    reward?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationMilestoneCreateInput = {
    id?: string
    userId: string
    locationId: string
    milestoneId: string
    milestoneName: string
    type: string
    title: string
    description: string
    value: number
    achievedAt?: Date | string
    notified?: boolean
  }

  export type LocationMilestoneUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    milestoneId: string
    milestoneName: string
    type: string
    title: string
    description: string
    value: number
    achievedAt?: Date | string
    notified?: boolean
  }

  export type LocationMilestoneUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationMilestoneUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationMilestoneCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    milestoneId: string
    milestoneName: string
    type: string
    title: string
    description: string
    value: number
    achievedAt?: Date | string
    notified?: boolean
  }

  export type LocationMilestoneUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationMilestoneUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    milestoneId?: StringFieldUpdateOperationsInput | string
    milestoneName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    achievedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocationAchievementCreateInput = {
    id?: string
    userId: string
    locationId: string
    type: string
    title: string
    description: string
    points?: number
    earnedAt?: Date | string
  }

  export type LocationAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    locationId: string
    type: string
    title: string
    description: string
    points?: number
    earnedAt?: Date | string
  }

  export type LocationAchievementUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationAchievementUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationAchievementCreateManyInput = {
    id?: string
    userId: string
    locationId: string
    type: string
    title: string
    description: string
    points?: number
    earnedAt?: Date | string
  }

  export type LocationAchievementUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationAchievementUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserTaskRefreshCreateInput = {
    id?: string
    userId: string
    month: string
    refreshedAt?: Date | string
    nextRefresh: Date | string
    triggeredBy?: string | null
    totalTasks?: number | null
    locationIds?: UserTaskRefreshCreatelocationIdsInput | string[]
  }

  export type UserTaskRefreshUncheckedCreateInput = {
    id?: string
    userId: string
    month: string
    refreshedAt?: Date | string
    nextRefresh: Date | string
    triggeredBy?: string | null
    totalTasks?: number | null
    locationIds?: UserTaskRefreshCreatelocationIdsInput | string[]
  }

  export type UserTaskRefreshUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    refreshedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRefresh?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalTasks?: NullableIntFieldUpdateOperationsInput | number | null
    locationIds?: UserTaskRefreshUpdatelocationIdsInput | string[]
  }

  export type UserTaskRefreshUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    refreshedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRefresh?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalTasks?: NullableIntFieldUpdateOperationsInput | number | null
    locationIds?: UserTaskRefreshUpdatelocationIdsInput | string[]
  }

  export type UserTaskRefreshCreateManyInput = {
    id?: string
    userId: string
    month: string
    refreshedAt?: Date | string
    nextRefresh: Date | string
    triggeredBy?: string | null
    totalTasks?: number | null
    locationIds?: UserTaskRefreshCreatelocationIdsInput | string[]
  }

  export type UserTaskRefreshUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    refreshedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRefresh?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalTasks?: NullableIntFieldUpdateOperationsInput | number | null
    locationIds?: UserTaskRefreshUpdatelocationIdsInput | string[]
  }

  export type UserTaskRefreshUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    refreshedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nextRefresh?: DateTimeFieldUpdateOperationsInput | Date | string
    triggeredBy?: NullableStringFieldUpdateOperationsInput | string | null
    totalTasks?: NullableIntFieldUpdateOperationsInput | number | null
    locationIds?: UserTaskRefreshUpdatelocationIdsInput | string[]
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VersionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type locationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    location_name?: SortOrder
    website?: SortOrder
    categories?: SortOrder
    last_rank_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    location_name?: SortOrder
    website?: SortOrder
    categories?: SortOrder
    last_rank_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type locationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    location_name?: SortOrder
    website?: SortOrder
    categories?: SortOrder
    last_rank_updated?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumScheduledPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPostStatus | EnumScheduledPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledPostStatusFilter<$PrismaModel> | $Enums.ScheduledPostStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ScheduledPostCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    summary?: SortOrder
    languageCode?: SortOrder
    topicType?: SortOrder
    mediaFormat?: SortOrder
    imageUrl?: SortOrder
    originalImageUrl?: SortOrder
    actionType?: SortOrder
    actionUrl?: SortOrder
    accountId?: SortOrder
    locationId?: SortOrder
    accessToken?: SortOrder
    scheduledAt?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    publishedPostId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    viewColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ScheduledPostAvgOrderByAggregateInput = {
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type ScheduledPostMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    summary?: SortOrder
    languageCode?: SortOrder
    topicType?: SortOrder
    mediaFormat?: SortOrder
    imageUrl?: SortOrder
    originalImageUrl?: SortOrder
    actionType?: SortOrder
    actionUrl?: SortOrder
    accountId?: SortOrder
    locationId?: SortOrder
    accessToken?: SortOrder
    scheduledAt?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    publishedPostId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    viewColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ScheduledPostMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    summary?: SortOrder
    languageCode?: SortOrder
    topicType?: SortOrder
    mediaFormat?: SortOrder
    imageUrl?: SortOrder
    originalImageUrl?: SortOrder
    actionType?: SortOrder
    actionUrl?: SortOrder
    accountId?: SortOrder
    locationId?: SortOrder
    accessToken?: SortOrder
    scheduledAt?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    publishedPostId?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    maxRetries?: SortOrder
    viewColor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ScheduledPostSumOrderByAggregateInput = {
    retryCount?: SortOrder
    maxRetries?: SortOrder
  }

  export type EnumScheduledPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPostStatus | EnumScheduledPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledPostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledPostStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduledPostStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type GmbIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    user_id?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmbIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    user_id?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GmbIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    user_id?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiry?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    clientId?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type CompetitorAnalysisUserIdLocationIdBusinessTypeCompoundUniqueInput = {
    userId: string
    locationId: string
    businessType: string
  }

  export type CompetitorAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    businessType?: SortOrder
    lastUpdated?: SortOrder
    nextUpdate?: SortOrder
    competitors?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitorAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    businessType?: SortOrder
    lastUpdated?: SortOrder
    nextUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompetitorAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    businessType?: SortOrder
    lastUpdated?: SortOrder
    nextUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type keywordsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    keyword?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type keywordsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    keyword?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type keywordsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    location_id?: SortOrder
    keyword?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type EnumRankChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RankChangeType | EnumRankChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankChangeTypeFilter<$PrismaModel> | $Enums.RankChangeType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type KeywordRankCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    rankChange?: SortOrder
    rankChangeValue?: SortOrder
    url?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    searchResults?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordRankAvgOrderByAggregateInput = {
    rank?: SortOrder
    previousRank?: SortOrder
    rankChangeValue?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
  }

  export type KeywordRankMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    rankChange?: SortOrder
    rankChangeValue?: SortOrder
    url?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    searchResults?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordRankMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    locationId?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    rankChange?: SortOrder
    rankChangeValue?: SortOrder
    url?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    searchResults?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordRankSumOrderByAggregateInput = {
    rank?: SortOrder
    previousRank?: SortOrder
    rankChangeValue?: SortOrder
    totalResults?: SortOrder
    searchTime?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumRankChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RankChangeType | EnumRankChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.RankChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRankChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumRankChangeTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type KeywordTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    isActive?: SortOrder
    refreshRate?: SortOrder
    lastChecked?: SortOrder
    nextBatchUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordTrackingAvgOrderByAggregateInput = {
    refreshRate?: SortOrder
  }

  export type KeywordTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    isActive?: SortOrder
    refreshRate?: SortOrder
    lastChecked?: SortOrder
    nextBatchUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    locationId?: SortOrder
    location?: SortOrder
    userId?: SortOrder
    targetDomain?: SortOrder
    isActive?: SortOrder
    refreshRate?: SortOrder
    lastChecked?: SortOrder
    nextBatchUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordTrackingSumOrderByAggregateInput = {
    refreshRate?: SortOrder
  }

  export type EnumBatchUpdateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchUpdateStatus | EnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchUpdateStatusFilter<$PrismaModel> | $Enums.BatchUpdateStatus
  }

  export type BatchUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchUpdateAvgOrderByAggregateInput = {
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
  }

  export type BatchUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchUpdateSumOrderByAggregateInput = {
    totalKeywords?: SortOrder
    processedKeywords?: SortOrder
    failedKeywords?: SortOrder
  }

  export type EnumBatchUpdateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchUpdateStatus | EnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchUpdateStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchUpdateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchUpdateStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchUpdateStatusFilter<$PrismaModel>
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultLocation?: SortOrder
    defaultDomain?: SortOrder
    autoRefreshHours?: SortOrder
    emailAlerts?: SortOrder
    alertThreshold?: SortOrder
    batchUpdateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsAvgOrderByAggregateInput = {
    autoRefreshHours?: SortOrder
    alertThreshold?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultLocation?: SortOrder
    defaultDomain?: SortOrder
    autoRefreshHours?: SortOrder
    emailAlerts?: SortOrder
    alertThreshold?: SortOrder
    batchUpdateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    defaultLocation?: SortOrder
    defaultDomain?: SortOrder
    autoRefreshHours?: SortOrder
    emailAlerts?: SortOrder
    alertThreshold?: SortOrder
    batchUpdateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsSumOrderByAggregateInput = {
    autoRefreshHours?: SortOrder
    alertThreshold?: SortOrder
  }

  export type EnumRankAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RankAlertType | EnumRankAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankAlertTypeFilter<$PrismaModel> | $Enums.RankAlertType
  }

  export type RankAlertCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
    isRead?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type RankAlertAvgOrderByAggregateInput = {
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
  }

  export type RankAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
    isRead?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type RankAlertMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    keyword?: SortOrder
    location?: SortOrder
    alertType?: SortOrder
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
    isRead?: SortOrder
    batchId?: SortOrder
    createdAt?: SortOrder
  }

  export type RankAlertSumOrderByAggregateInput = {
    threshold?: SortOrder
    currentRank?: SortOrder
    previousRank?: SortOrder
  }

  export type EnumRankAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RankAlertType | EnumRankAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.RankAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRankAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumRankAlertTypeFilter<$PrismaModel>
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    week?: SortOrder
    status?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    week?: SortOrder
    status?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    week?: SortOrder
    status?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type CompletedTaskCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    week?: SortOrder
    month?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    completedAt?: SortOrder
    verificationConfidence?: SortOrder
    verificationReason?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CompletedTaskAvgOrderByAggregateInput = {
    points?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
  }

  export type CompletedTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    week?: SortOrder
    month?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    completedAt?: SortOrder
    verificationConfidence?: SortOrder
    verificationReason?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CompletedTaskMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    impact?: SortOrder
    points?: SortOrder
    repeatable?: SortOrder
    estimatedTime?: SortOrder
    week?: SortOrder
    month?: SortOrder
    repeatFrequency?: SortOrder
    businessType?: SortOrder
    actionType?: SortOrder
    editableViaAPI?: SortOrder
    verificationType?: SortOrder
    caution?: SortOrder
    completedAt?: SortOrder
    verificationConfidence?: SortOrder
    verificationReason?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
    verifiedAt?: SortOrder
  }

  export type CompletedTaskSumOrderByAggregateInput = {
    points?: SortOrder
    pointsAwarded?: SortOrder
    pointsPenalty?: SortOrder
  }

  export type TaskExclusionUserIdLocationIdMonthTaskTitleTaskTypeCompoundUniqueInput = {
    userId: string
    locationId: string
    month: string
    taskTitle: string
    taskType: string
  }

  export type TaskExclusionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    taskTitle?: SortOrder
    taskType?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    taskId?: SortOrder
    completedTaskId?: SortOrder
    excludedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TaskExclusionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    taskTitle?: SortOrder
    taskType?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    taskId?: SortOrder
    completedTaskId?: SortOrder
    excludedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TaskExclusionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    month?: SortOrder
    taskTitle?: SortOrder
    taskType?: SortOrder
    category?: SortOrder
    reason?: SortOrder
    taskId?: SortOrder
    completedTaskId?: SortOrder
    excludedAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    totalPoints?: SortOrder
    currentLevel?: SortOrder
    tasksCompleted?: SortOrder
    locationsCount?: SortOrder
  }

  export type LocationProgressUserIdLocationIdCompoundUniqueInput = {
    userId: string
    locationId: string
  }

  export type LocationProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveDate?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationProgressAvgOrderByAggregateInput = {
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
  }

  export type LocationProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveDate?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    placeId?: SortOrder
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastActiveDate?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationProgressSumOrderByAggregateInput = {
    totalPoints?: SortOrder
    weeklyPoints?: SortOrder
    monthlyPoints?: SortOrder
    tasksCompleted?: SortOrder
    profileScore?: SortOrder
    engagementScore?: SortOrder
    contentScore?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    reward?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneAvgOrderByAggregateInput = {
    threshold?: SortOrder
    points?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    reward?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    threshold?: SortOrder
    reward?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    createdAt?: SortOrder
  }

  export type MilestoneSumOrderByAggregateInput = {
    threshold?: SortOrder
    points?: SortOrder
  }

  export type LocationMilestoneUserIdLocationIdMilestoneIdCompoundUniqueInput = {
    userId: string
    locationId: string
    milestoneId: string
  }

  export type LocationMilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    milestoneId?: SortOrder
    milestoneName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    achievedAt?: SortOrder
    notified?: SortOrder
  }

  export type LocationMilestoneAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type LocationMilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    milestoneId?: SortOrder
    milestoneName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    achievedAt?: SortOrder
    notified?: SortOrder
  }

  export type LocationMilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    milestoneId?: SortOrder
    milestoneName?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    achievedAt?: SortOrder
    notified?: SortOrder
  }

  export type LocationMilestoneSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type LocationAchievementUserIdLocationIdTypeCompoundUniqueInput = {
    userId: string
    locationId: string
    type: string
  }

  export type LocationAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    earnedAt?: SortOrder
  }

  export type LocationAchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type LocationAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    earnedAt?: SortOrder
  }

  export type LocationAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    locationId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    points?: SortOrder
    earnedAt?: SortOrder
  }

  export type LocationAchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type UserTaskRefreshUserIdMonthCompoundUniqueInput = {
    userId: string
    month: string
  }

  export type UserTaskRefreshCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    refreshedAt?: SortOrder
    nextRefresh?: SortOrder
    triggeredBy?: SortOrder
    totalTasks?: SortOrder
    locationIds?: SortOrder
  }

  export type UserTaskRefreshAvgOrderByAggregateInput = {
    totalTasks?: SortOrder
  }

  export type UserTaskRefreshMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    refreshedAt?: SortOrder
    nextRefresh?: SortOrder
    triggeredBy?: SortOrder
    totalTasks?: SortOrder
  }

  export type UserTaskRefreshMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    month?: SortOrder
    refreshedAt?: SortOrder
    nextRefresh?: SortOrder
    triggeredBy?: SortOrder
    totalTasks?: SortOrder
  }

  export type UserTaskRefreshSumOrderByAggregateInput = {
    totalTasks?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type EnumScheduledPostStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduledPostStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type EnumRankChangeTypeFieldUpdateOperationsInput = {
    set?: $Enums.RankChangeType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBatchUpdateStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchUpdateStatus
  }

  export type EnumRankAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.RankAlertType
  }

  export type UserTaskRefreshCreatelocationIdsInput = {
    set: string[]
  }

  export type UserTaskRefreshUpdatelocationIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumScheduledPostStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPostStatus | EnumScheduledPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledPostStatusFilter<$PrismaModel> | $Enums.ScheduledPostStatus
  }

  export type NestedEnumScheduledPostStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduledPostStatus | EnumScheduledPostStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduledPostStatus[] | ListEnumScheduledPostStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduledPostStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduledPostStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduledPostStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduledPostStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedEnumRankChangeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RankChangeType | EnumRankChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankChangeTypeFilter<$PrismaModel> | $Enums.RankChangeType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumRankChangeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RankChangeType | EnumRankChangeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankChangeType[] | ListEnumRankChangeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankChangeTypeWithAggregatesFilter<$PrismaModel> | $Enums.RankChangeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRankChangeTypeFilter<$PrismaModel>
    _max?: NestedEnumRankChangeTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumBatchUpdateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchUpdateStatus | EnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchUpdateStatusFilter<$PrismaModel> | $Enums.BatchUpdateStatus
  }

  export type NestedEnumBatchUpdateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchUpdateStatus | EnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchUpdateStatus[] | ListEnumBatchUpdateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchUpdateStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchUpdateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchUpdateStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchUpdateStatusFilter<$PrismaModel>
  }

  export type NestedEnumRankAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RankAlertType | EnumRankAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankAlertTypeFilter<$PrismaModel> | $Enums.RankAlertType
  }

  export type NestedEnumRankAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RankAlertType | EnumRankAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RankAlertType[] | ListEnumRankAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRankAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.RankAlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRankAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumRankAlertTypeFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}